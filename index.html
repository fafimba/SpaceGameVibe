<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Stellar Swarm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100dvh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        #gameContainer {
            position: relative;
            background: #020617;
        }
        
        #game {
            display: block;
        }
        
        /* Touch Controls */
        #touchControls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .touch-zone {
            position: absolute;
            pointer-events: auto;
        }
        
        #joystickZone {
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }

        #joystickBase {
            position: fixed;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 50%;
            display: none;
            pointer-events: none;
        }

        @media (pointer: coarse) {
            #joystickBase {
                display: block;
                left: 50%;
                bottom: 140px;
                transform: translateX(-50%);
            }
        }

        #joystickKnob {
            position: absolute;
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 50%;
            left: 12px;
            top: 12px;
            transition: none;
        }
        
        @media (pointer: coarse) {
            #touchControls {
                display: block;
            }
        }

        /* Upgrade Selection Panel */
        #upgradePanel {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 20, 0.95);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #upgradePanel.active {
            display: flex;
        }

        .upgrade-title {
            color: #FFD700;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            text-align: center;
        }

        .upgrade-subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 30px;
            text-align: center;
        }

        .upgrade-cards {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 380px;
        }

        .upgrade-card {
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.95) 0%, rgba(30, 40, 70, 0.9) 100%);
            border: 2px solid rgba(100, 100, 140, 0.4);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .upgrade-card:hover {
            transform: scale(1.02);
            border-color: var(--skill-color);
            box-shadow: 0 0 25px var(--skill-color-glow);
            background: linear-gradient(135deg, rgba(30, 40, 60, 0.95) 0%, rgba(40, 50, 80, 0.9) 100%);
        }

        .upgrade-card:active {
            transform: scale(0.98);
        }

        .upgrade-icon {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        .upgrade-info {
            flex: 1;
            min-width: 0;
        }

        .upgrade-name {
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .upgrade-desc {
            font-size: 13px;
            color: #aaa;
            line-height: 1.35;
        }

        .upgrade-key {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #666;
            flex-shrink: 0;
        }

        @media (max-height: 500px) {
            .upgrade-title {
                font-size: 24px;
                margin-bottom: 4px;
            }
            .upgrade-subtitle {
                font-size: 14px;
                margin-bottom: 15px;
            }
            .upgrade-card {
                padding: 12px;
            }
            .upgrade-icon {
                width: 44px;
                height: 44px;
            }
            .upgrade-name {
                font-size: 15px;
            }
            .upgrade-desc {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="touchControls">
            <div id="joystickZone" class="touch-zone"></div>
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <div id="upgradePanel">
            <div class="upgrade-title">LEVEL UP!</div>
            <div class="upgrade-subtitle">Choose an upgrade</div>
            <div class="upgrade-cards" id="upgradeCards"></div>
        </div>
    </div>

    <script>
    // ============================================================
    // STELLAR SWARM - Single File Game
    // ============================================================

    (function() {
        'use strict';

        // ============================================================
        // CONSTANTS
        // ============================================================
        
        // Canvas dimensions - set dynamically based on device
        let CANVAS_WIDTH = 1920;
        let CANVAS_HEIGHT = 1080;

        // Detect mobile device
        function isMobile() {
            return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) && window.innerWidth < 1024;
        }
        
        // Physics
        const ROTATION_SPEED = 300;          // deg/sec
        const THRUST_ACCEL = 2200;           // px/secÂ²
        const REVERSE_ACCEL = 450;           // px/secÂ²
        const MAX_SPEED = 600;               // px/sec
        const DRAG_FACTOR = 0.5;             // Increased drag to reduce inertia
        const BULLET_SPEED = 2000;           // px/sec
        const ORBITAL_RADIUS = 130;          // px - Radio base de los escudos orbitales
        const ORBITAL_SIZE = 26;             // px - TamaÃ±o base de cada esfera orbital
        const ORBITAL_SPEED = 3;           // rad/sec - Velocidad base de rotacion

        // Garlic Aura
        const AURA_BASE_RADIUS = 100;      // px
        const AURA_BASE_DAMAGE = 4;        // damage per tick
        const AURA_BASE_TICK_RATE = 0.5;   // seconds between ticks

        // Alien Drone
        const DRONE_SPEED = 450;           // px/sec
        const DRONE_BASE_DAMAGE = 1;       // damage on impact
        const DRONE_EXPLOSION_RADIUS = 80; // px - explosion AoE radius
        const DRONE_EXPLOSION_DAMAGE = 1;  // damage in explosion area
        const DRONE_TURN_RATE = 360;       // degrees/sec
        const DRONE_SIZE = 5;              // px - small drones

        // Player
        const PLAYER_SIZE = 48;
        const PLAYER_COLLISION_RADIUS = 20;
        const PLAYER_VISUAL_RADIUS = 24;
        const PLAYER_MAX_HP = 3;
        const PLAYER_PIVOT_OFFSET = -5;
        const PLAYER_MASS = 2.5;             // Mass factor: higher = more inertia, harder to change direction       // Offset del punto de pivote: positivo = hacia el morro, negativo = hacia la cola
        const THRUSTER_PARTICLE_INTERVAL = 0.08; // Segundos entre partÃ­culas del thruster (menor = mÃ¡s partÃ­culas)

        // Pickups
        const PICKUP_MAGNET_RADIUS = 150;    // Radio de atracciÃ³n de pickups hacia el jugador

        // Shield System
        const PLAYER_MAX_SHIELD = 400;           // Escudo mÃ¡ximo (16 golpes para vaciarlo)
        const SHIELD_REGEN_RATE = 50;            // Puntos por segundo
        const SHIELD_REGEN_DELAY = 2.5;          // Segundos sin daÃ±o para regenerar
        const SHIELD_DAMAGE_ABSORPTION = 25;     // DaÃ±o por golpe (4 golpes = escudo vacÃ­o)

        // Weapons
        const AUTO_FIRE_INTERVAL = 0.35;
        const BULLET_LIFETIME = 1.2;
        
        // Enemies
        const ENEMY_TYPES = {
            SCOUT: { radius: 10, speed: 120, turnRate: 90, hp: 4, points: 10, color: '#FF6B6B', outline: '#C04848' },
            KAMIKAZE: { radius: 10, speed: 180, turnRate: 60, hp: 4, points: 25, color: '#FF9A6B', outline: '#D86A3A' },
            SPINNER: { radius: 14, speed: 90, turnRate: 60, hp: 4, points: 40, color: '#3A9AD9', outline: '#1E6F9A', fireRate: 1.2 },
            TANK: { radius: 22, speed: 70, turnRate: 45, hp: 12, points: 75, color: '#C792FF', outline: '#8A5DBF' },
            ALIEN: { radius: 34, speed: 55, turnRate: 35, hp: 60, points: 0, color: '#39FF14', outline: '#1A5C1A' }
        };
        
        const INITIAL_SPAWN_INTERVAL_MIN = 0.15;
        const INITIAL_SPAWN_INTERVAL_MAX = 0.35;
        const MIN_SPAWN_INTERVAL = 0.03;
        const SPAWN_DECAY_RATE = 0.05;
        const SPAWN_DECAY_INTERVAL = 10;
        const MAX_ENEMIES = 500;
        const MAX_ENEMIES_LOW_PERF = 200;
        
        // Scoring
        const NEAR_MISS_RADIUS = 12;
        const NEAR_MISS_POINTS = 5;
        const MILESTONE_INTERVAL = 5000;
        
        // Effects
        const SHAKE_INTENSITY_HIT = 6;
        const SHAKE_DURATION_HIT = 220;
        const SHAKE_DURATION_DEATH = 420;
        const SLOWMO_FACTOR = 0.45;
        const SLOWMO_DURATION = 180;
        
        // Colors
        const COLORS = {
            PLAYER: '#7FDBFF',
            PLAYER_OUTLINE: '#3A9AD9',
            SHIELD: '#3A9AD9',
            SHIELD_BG: '#1A4A6A',
            THRUSTER: '#FFDD57',
            BULLET: '#7FDBFF',
            ENEMY_BULLET: '#FF6B6B',
            POWERUP: '#00FFAA',
            GOLD: '#FFDD57',
            RARE: '#C792FF',
            XP: '#00FFAA',
            UI_PRIMARY: '#FFFFFF',
            UI_SECONDARY: '#AAAAAA',
            BG_TOP: '#0a1628',
            BG_BOTTOM: '#020610',
            // HUD Colors
            HUD_CYAN: '#7FDBFF',
            HUD_CYAN_DIM: '#3A9AD9',
            HUD_CYAN_GLOW: 'rgba(127, 219, 255, 0.4)',
            HUD_RED: '#FF6B6B',
            HUD_RED_DIM: '#C04848',
            HUD_GOLD: '#FFDD57',
            HUD_GREEN: '#00FFAA',
            HUD_GREEN_DIM: '#00AA66',
            HUD_PURPLE: '#9F7AEA',
            HUD_SHIELD: '#44C8FF',
            HUD_SHIELD_DIM: '#1A6B99',
            HUD_SHIELD_GLOW: 'rgba(68, 200, 255, 0.35)',
            HUD_SHIELD_REGEN: '#66EEFF',
            HUD_WARNING: '#FF8844',
            HUD_TEXT_PRIMARY: '#E8F0FF',
            HUD_TEXT_SECONDARY: 'rgba(200, 215, 240, 0.55)',
            HUD_PANEL_BG: 'rgba(5, 12, 30, 0.85)',
            HUD_PANEL_BORDER: 'rgba(127, 219, 255, 0.15)'
        };

        // Shield Arc Constants (around player)
        const SHIELD_ARC_RADIUS = 42;
        const SHIELD_ARC_STROKE = 3;
        const SHIELD_ARC_TRACK_STROKE = 3;
        const SHIELD_ARC_IDLE_OPACITY = 0;
        const SHIELD_ARC_HIT_OPACITY = 1.0;
        const SHIELD_ARC_REGEN_OPACITY = 0.6;
        const SHIELD_ARC_LOW_THRESHOLD = 0.25;
        const SHIELD_ARC_FADE_DELAY = 2.0;
        const SHIELD_ARC_FLASH_DURATION = 0.12;

        // XP & Level System
        const XP_PER_LEVEL_BASE = 25;
        const XP_PER_LEVEL_GROWTH = 1.4;

        // Touch Controls
        const JOYSTICK_MAX_DISTANCE = 38;
        const JOYSTICK_DEADZONE = 0;
        const JOYSTICK_THRUST_THRESHOLD = 0.3;

        // Auto-Aim
        const AUTO_AIM_CONE_DEGREES = 30; // Â±30Â° = 60Â° total cone
        const AUTO_AIM_MAX_DISTANCE = 700; // px - max range for laser auto-aim

        // Enemy Spawn
        const ENEMY_SPAWN_OFFSET_MIN = 50;
        const ENEMY_SPAWN_OFFSET_RANGE = 30;
        const ENEMY_SEPARATION_PADDING = 8;

        // Wave System - Vampire Survivor style
        const WAVE_INTERVAL_BASE = 2.5;       // Base seconds between waves (gets faster with level)
        const WAVE_INTERVAL_VARIANCE = 1.5;   // Random variance in seconds
        const WAVE_SPAWN_DISTANCE = 850;      // Distance from player
        const WAVE_PATTERNS = [
            'arc',           // Enemies in an arc around player
            'side',          // All enemies from one side
            'pincer',        // Enemies from two opposite sides
            'circle',        // Hexagonal staggered pattern (3 inner, 3 outer)
            'line',          // Horizontal or vertical line
            'cluster',       // Tight cluster from one direction
            'spiral',        // Spiral pattern converging on player
            'corners',       // From all 4 corners
            'rush',          // Dense column rushing from one direction
            'scatter',       // Random positions all around
            'v_formation'    // V-shape formation
        ];

        // Sector System - Infinite World
        const SECTOR_WIDTH = 3840;      // 2x viewport width
        const SECTOR_HEIGHT = 2160;     // 2x viewport height
        const GRID_SIZE = 3;            // 3x3 grid
        const WORLD_WIDTH = SECTOR_WIDTH * GRID_SIZE;   // 11520
        const WORLD_HEIGHT = SECTOR_HEIGHT * GRID_SIZE; // 6480

        const SECTOR_BOUNDS = {
            minX: -SECTOR_WIDTH / 2,     // -1920
            maxX: SECTOR_WIDTH / 2,      // +1920
            minY: -SECTOR_HEIGHT / 2,    // -1080
            maxY: SECTOR_HEIGHT / 2      // +1080
        };

        // Player Rotation
        const JOYSTICK_ROTATION_THRESHOLD = 5; // degrees
        
        // Weapon Definitions with multi-level upgrade branches
        const WEAPONS = {
            'laser_cannon': {
                name: 'LASER CANNON',
                color: '#FF6B5B',
                icon: 'laser',
                description: 'Auto-fire laser cannon',
                shopPrice: 0,
                branches: {
                    'rapid_fire': {
                        name: 'Rapid Fire',
                        icon: 'rate',
                        levels: [
                            { description: 'Fire rate: 0.35s â†’ 0.28s (-20%)', effect: { fireRate: 0.28 } },
                            { description: 'Fire rate: 0.28s â†’ 0.22s (-21%)', effect: { fireRate: 0.22 } },
                            { description: 'Fire rate: 0.22s â†’ 0.16s (-27%)', effect: { fireRate: 0.16 } }
                        ]
                    },
                    'beam_splitter': {
                        name: 'Beam Splitter',
                        icon: 'spread',
                        levels: [
                            { description: '3 projectiles in cone', effect: { spreadCount: 3 } },
                            { description: '5 projectiles, focused cone', effect: { spreadCount: 5 } },
                            { description: '7 projectiles, dense cone', effect: { spreadCount: 7 } }
                        ]
                    },
                    'piercing_lens': {
                        name: 'Piercing Lens',
                        icon: 'beam',
                        levels: [
                            { description: 'Bullets pierce 1 extra enemy', effect: { pierce: 2 } },
                            { description: 'Damage: 10 â†’ 14 (+40%)', effect: { pierce: 2, damage: 14 } },
                            { description: 'Unlimited pierce, Damage: 18', effect: { pierceInfinite: true, damage: 18 } }
                        ]
                    }
                },
                evolution: {
                    name: 'NOVA BEAM',
                    icon: 'nova',
                    description: 'Every 5th shot fires a massive piercing cone beam',
                    effect: { novaBeam: true }
                }
            },
            'missile_launcher': {
                name: 'MISSILE LAUNCHER',
                color: '#FFD93D',
                icon: 'rocket',
                description: 'Homing missile system',
                shopPrice: 150,
                branches: {
                    'barrage': {
                        name: 'Barrage',
                        icon: 'target',
                        levels: [
                            { description: '3 â†’ 4 missiles per burst', effect: { rocketBurstCount: 4 } },
                            { description: '4 â†’ 5 missiles per burst', effect: { rocketBurstCount: 5 } },
                            { description: '5 â†’ 7 missiles per burst', effect: { rocketBurstCount: 7 } }
                        ]
                    },
                    'cluster_payload': {
                        name: 'Cluster Payload',
                        icon: 'cluster',
                        levels: [
                            { description: 'Explosion radius: 120 â†’ 160px', effect: { rocketExplosionRadius: 160 } },
                            { description: 'Explosion spawns 2 mini-missiles', effect: { rocketExplosionRadius: 160, rocketRicochetCount: 2 } },
                            { description: 'Explosion: 30 â†’ 45 dmg, 3 mini-missiles', effect: { rocketExplosionDamage: 45, rocketRicochetCount: 3 } }
                        ]
                    },
                    'heavy_payload': {
                        name: 'Heavy Payload',
                        icon: 'damage',
                        levels: [
                            { description: 'Impact damage: 22 â†’ 30', effect: { rocketDamage: 30 } },
                            { description: 'Impact damage: 30 â†’ 40', effect: { rocketDamage: 40 } },
                            { description: 'Damage: 50 + 20% crit chance', effect: { rocketDamage: 50, rocketCritChance: 0.20 } }
                        ]
                    }
                },
                evolution: {
                    name: 'ARMAGEDDON PROTOCOL',
                    icon: 'armageddon',
                    description: 'Every 8s, mega-missile with massive explosion',
                    effect: { armageddon: true }
                }
            },
            'orbital_shield': {
                name: 'ORBITAL SHIELD',
                color: '#00DFFF',
                icon: 'orbital',
                description: '3 orbiting damage orbs',
                shopPrice: 150,
                branches: {
                    'orbital_expansion': {
                        name: 'Orbital Expansion',
                        icon: 'regen',
                        levels: [
                            { description: '3 â†’ 4 orbs', effect: { orbCount: 4 } },
                            { description: '4 â†’ 5 orbs', effect: { orbCount: 5 } },
                            { description: '5 â†’ 7 orbs', effect: { orbCount: 7 } }
                        ]
                    },
                    'shockwave': {
                        name: 'Shockwave',
                        icon: 'shockwave',
                        levels: [
                            { description: 'Orb size +30%', effect: { orbSizeMulti: 1.3 } },
                            { description: 'Orb size +60%, light knockback', effect: { orbSizeMulti: 1.6, orbKnockback: 1 } },
                            { description: 'Orb size +100%, strong knockback', effect: { orbSizeMulti: 2.0, orbKnockback: 2 } }
                        ]
                    },
                    'energy_absorption': {
                        name: 'Energy Absorption',
                        icon: 'absorb',
                        levels: [
                            { description: 'Contact damage: 16 â†’ 24 (+50%)', effect: { orbDamage: 24 } },
                            { description: 'Contact damage: 24 â†’ 32', effect: { orbDamage: 32 } },
                            { description: 'Damage: 40 + enemies slowed 25%', effect: { orbDamage: 40, orbSlow: 0.25 } }
                        ]
                    }
                },
                evolution: {
                    name: 'SINGULARITY CORE',
                    icon: 'singularity',
                    description: 'Gravity field: slow + passive damage. Kills emit pulse.',
                    effect: { singularity: true }
                }
            },
            'lightning_ray': {
                name: 'LIGHTNING RAY',
                color: '#9F7AEA',
                icon: 'lightning',
                description: 'Chain lightning between enemies',
                shopPrice: 200,
                branches: {
                    'chain_amplifier': {
                        name: 'Chain Amplifier',
                        icon: 'chain',
                        levels: [
                            { description: '6 â†’ 8 chain bounces', effect: { lightningBounces: 8 } },
                            { description: '8 â†’ 10 bounces', effect: { lightningBounces: 10 } },
                            { description: '10 â†’ 14 bounces', effect: { lightningBounces: 14 } }
                        ]
                    },
                    'rapid_discharge': {
                        name: 'Rapid Discharge',
                        icon: 'discharge',
                        levels: [
                            { description: 'Cadence: 1.2s â†’ 1.0s', effect: { lightningCadence: 1.0 } },
                            { description: 'Cadence: 1.0s â†’ 0.8s', effect: { lightningCadence: 0.8 } },
                            { description: 'Cadence: 0.8s â†’ 0.6s', effect: { lightningCadence: 0.6 } }
                        ]
                    },
                    'extended_arc': {
                        name: 'Extended Arc',
                        icon: 'arc',
                        levels: [
                            { description: 'Detection: 300px, Chain: 270px', effect: { lightningRange: 300, lightningChainRange: 270 } },
                            { description: 'Damage: 8 â†’ 12', effect: { lightningRange: 300, lightningChainRange: 270, lightningDamage: 12 } },
                            { description: 'Detection: 400px, Chain: 350px, Damage: 16', effect: { lightningRange: 400, lightningChainRange: 350, lightningDamage: 16 } }
                        ]
                    }
                },
                evolution: {
                    name: 'STORM NEXUS',
                    icon: 'storm',
                    description: 'Lightning leaves electric field. Enemies stunned on entry.',
                    effect: { stormNexus: true }
                }
            },
            'plasma_field': {
                name: 'PLASMA FIELD',
                color: '#7FDBFF',
                icon: 'aura',
                description: 'Damage aura around the ship',
                shopPrice: 200,
                branches: {
                    'field_expansion': {
                        name: 'Field Expansion',
                        icon: 'expand',
                        levels: [
                            { description: 'Radius: 100 â†’ 130px', effect: { auraRadius: 130 } },
                            { description: 'Radius: 130 â†’ 170px', effect: { auraRadius: 170 } },
                            { description: 'Radius: 170 â†’ 220px', effect: { auraRadius: 220 } }
                        ]
                    },
                    'field_intensity': {
                        name: 'Field Intensity',
                        icon: 'damage',
                        levels: [
                            { description: 'Damage: 8 â†’ 12 per tick', effect: { auraDamage: 12 } },
                            { description: 'Damage: 12 â†’ 17 per tick', effect: { auraDamage: 17 } },
                            { description: 'Damage: 24 + 20% slow in zone', effect: { auraDamage: 24, auraSlow: 0.20 } }
                        ]
                    },
                    'rapid_pulse': {
                        name: 'Rapid Pulse',
                        icon: 'pulse',
                        levels: [
                            { description: 'Tick rate: 0.50s â†’ 0.40s', effect: { auraTickRate: 0.40 } },
                            { description: 'Tick rate: 0.40s â†’ 0.30s', effect: { auraTickRate: 0.30 } },
                            { description: 'Tick rate: 0.30s â†’ 0.22s', effect: { auraTickRate: 0.22 } }
                        ]
                    }
                },
                evolution: {
                    name: 'ANNIHILATION SPHERE',
                    icon: 'annihilation',
                    description: 'Kills in field create chain-reaction explosions.',
                    effect: { annihilation: true }
                }
            },
            'alien_drone': {
                name: 'ALIEN DRONE',
                color: '#39FF14',
                icon: 'drone',
                description: 'Kamikaze drones from killed enemies',
                shopPrice: 250,
                branches: {
                    'drone_swarm': {
                        name: 'Drone Swarm',
                        icon: 'swarm',
                        levels: [
                            { description: '1 drone + 30% chance 2nd drone', effect: { droneExtraChance: 0.30, droneExtraCount: 1 } },
                            { description: '1 drone + 60% chance 2nd drone', effect: { droneExtraChance: 0.60, droneExtraCount: 1 } },
                            { description: '2 drones + 40% chance 3rd', effect: { droneBaseCount: 2, droneExtraChance: 0.40, droneExtraCount: 1 } }
                        ]
                    },
                    'drone_power': {
                        name: 'Drone Power',
                        icon: 'duration',
                        levels: [
                            { description: 'Damage: 15 â†’ 22', effect: { droneDamage: 22 } },
                            { description: 'Damage: 30, Range: 400 â†’ 550px', effect: { droneDamage: 30, droneRange: 550 } },
                            { description: 'Damage: 40, Speed: +30%', effect: { droneDamage: 40, droneRange: 550, droneSpeedMulti: 1.3 } }
                        ]
                    },
                    'volatile_core': {
                        name: 'Volatile Core',
                        icon: 'explosion',
                        levels: [
                            { description: '30% chance explosion (60px, 12 dmg)', effect: { droneExplosionChance: 0.30, droneExplosionRadius: 60, droneExplosionDamage: 12 } },
                            { description: '55% chance explosion (80px, 18 dmg)', effect: { droneExplosionChance: 0.55, droneExplosionRadius: 80, droneExplosionDamage: 18 } },
                            { description: '80% chance explosion (100px, 25 dmg)', effect: { droneExplosionChance: 0.80, droneExplosionRadius: 100, droneExplosionDamage: 25 } }
                        ]
                    }
                },
                evolution: {
                    name: 'HIVE MIND',
                    icon: 'hive',
                    description: 'Drones orbit and shoot mini-lasers. Explode on expiry.',
                    effect: { hiveMind: true }
                }
            }
        };

        // ============================================================
        // GAME STATE
        // ============================================================
        
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        
        let gameState = 'menu'; // menu, playing, paused, gameOver, skilltree, tutorial, shop

        // â”€â”€ Audio System (disabled during development) â”€â”€
        const AudioManager = {
            initialized: false,
            init() {},
            resume() {},
            setMusicVolume() {}
        };
        let lastTime = 0;
        let deltaTime = 0;
        let timeScale = 1;
        let gameTime = 0;
        let score = 0;
        let highScore = 0;
        let isNewHighScore = false;
        let totalKills = 0;

        // Wave Alert System
        let waveAlertActive = false;
        let waveAlertTimer = 0;
        let waveAlertNumber = 0;
        let waveAlertSubtitle = '';
        const WAVE_ALERT_DURATION = 2.5;

        // Safe localStorage access
        try {
            highScore = parseInt(localStorage.getItem('StellarSwarm_highscore_v1')) || 0;
        } catch (e) {
            console.warn('localStorage not available:', e);
            highScore = 0;
        }

        // ============================================================
        // META-PROGRESSION SYSTEM
        // ============================================================
        const PROGRESSION_SAVE_KEY = 'StellarSwarm_progression_v1';
        const WEAPON_IDS = ['laser_cannon', 'orbital_shield', 'missile_launcher', 'lightning_ray', 'plasma_field', 'alien_drone'];

        // Difficulty system
        const DIFFICULTY_THRESHOLDS = [0, 5000, 15000, 40000];
        const DIFFICULTY_NAMES = ['NORMAL', 'HARD', 'EXTREME', 'NIGHTMARE'];
        const DIFFICULTY_COLORS = ['#4A90D9', '#9F7AEA', '#FF4444', '#39FF14'];
        const DIFFICULTY_MULTIPLIERS = [
            { enemyHP: 1.0, enemySpeed: 1.0, spawnRate: 1.0, crystals: 1.0, xp: 1.0, score: 1.0 },
            { enemyHP: 1.4, enemySpeed: 1.2, spawnRate: 1.3, crystals: 1.5, xp: 1.2, score: 1.5 },
            { enemyHP: 2.0, enemySpeed: 1.4, spawnRate: 1.6, crystals: 2.0, xp: 1.5, score: 2.5 },
            { enemyHP: 3.0, enemySpeed: 1.6, spawnRate: 2.0, crystals: 3.0, xp: 2.0, score: 4.0 }
        ];

        function getDiffMultipliers() {
            return DIFFICULTY_MULTIPLIERS[currentDifficulty] || DIFFICULTY_MULTIPLIERS[0];
        }

        function getUnlockedDifficulties(prog) {
            const unlocked = [0]; // Normal always unlocked
            for (let i = 1; i < DIFFICULTY_THRESHOLDS.length; i++) {
                // Check if any high score exceeds the threshold for this difficulty
                const scores = prog.highScores || {};
                const maxScore = Math.max(scores.normal || 0, scores.hard || 0, scores.extreme || 0, scores.nightmare || 0);
                if (maxScore >= DIFFICULTY_THRESHOLDS[i]) {
                    unlocked.push(i);
                }
            }
            return unlocked;
        }

        // Shop: weapon purchase requirements (number of weapons already bought, excluding laser)
        const WEAPON_PURCHASE_REQUIREMENTS = {
            'laser_cannon': 0,
            'orbital_shield': 0,
            'missile_launcher': 0,
            'lightning_ray': 1,
            'plasma_field': 2,
            'alien_drone': 3
        };

        // Permanent upgrades definition
        const PERMANENT_UPGRADES = {
            powerCore:        { name: 'POWER CORE',        description: '+4% damage per level',   icon: 'âš¡', color: '#FF6B5B', baseCost: 50,  maxLevel: 10 },
            hullPlating:      { name: 'HULL PLATING',      description: '+1 max HP per 2 levels', icon: 'ðŸ›¡', color: '#00DFFF', baseCost: 40,  maxLevel: 10 },
            engineBoost:      { name: 'ENGINE BOOST',       description: '+3% speed per level',    icon: 'ðŸš€', color: '#FFD93D', baseCost: 40,  maxLevel: 10 },
            xpAmplifier:      { name: 'XP AMPLIFIER',      description: '+5% XP per level',       icon: 'âœ¦',  color: '#9F7AEA', baseCost: 60,  maxLevel: 10 },
            crystalAttractor: { name: 'CRYSTAL ATTRACTOR', description: '+5% crystals per level', icon: 'â—†',  color: '#E0F0FF', baseCost: 80,  maxLevel: 10 }
        };

        function getUpgradeCost(upgradeKey, currentLevel) {
            const def = PERMANENT_UPGRADES[upgradeKey];
            if (!def || currentLevel >= def.maxLevel) return Infinity;
            const nextLevel = currentLevel + 1;
            return Math.round(def.baseCost * (1 + (nextLevel - 1) * 0.8));
        }

        function canBuyWeapon(weaponId, prog) {
            if (prog.unlockedWeapons[weaponId]) return false;
            const purchasedCount = Object.values(prog.unlockedWeapons).filter(v => v).length - 1; // -1 for free laser
            const price = WEAPONS[weaponId].shopPrice;
            return purchasedCount >= WEAPON_PURCHASE_REQUIREMENTS[weaponId] && (prog.crystals || 0) >= price;
        }

        function getWeaponRequirementText(weaponId, prog) {
            const purchasedCount = Object.values(prog.unlockedWeapons).filter(v => v).length - 1;
            const required = WEAPON_PURCHASE_REQUIREMENTS[weaponId];
            if (purchasedCount < required) {
                return 'Unlock ' + (required - purchasedCount) + ' more weapon' + (required - purchasedCount > 1 ? 's' : '') + ' first';
            }
            return null;
        }

        // Cached progression for current run (set in resetGame, avoids localStorage reads per frame)
        let cachedProgression = null;

        function createDefaultProgression() {
            return {
                unlockedWeapons: {
                    laser_cannon: true,
                    orbital_shield: false,
                    missile_launcher: false,
                    lightning_ray: false,
                    plasma_field: false,
                    alien_drone: false
                },
                crystals: 0,
                permanentUpgrades: {
                    powerCore: 0,
                    hullPlating: 0,
                    engineBoost: 0,
                    xpAmplifier: 0,
                    crystalAttractor: 0
                },
                highScores: { normal: 0, hard: 0, extreme: 0, nightmare: 0 },
                currentDifficulty: 0,
                tutorialDone: false,
                stats: { totalRuns: 0, totalKills: 0, totalCrystalsEarned: 0 }
            };
        }

        function loadProgression() {
            try {
                const raw = localStorage.getItem(PROGRESSION_SAVE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    // Fresh start migration: if old format (no crystals field), wipe to defaults
                    if (data.crystals === undefined) {
                        return createDefaultProgression();
                    }
                    // Ensure all fields exist (forward compat)
                    if (!data.stats) data.stats = { totalRuns: 0, totalKills: 0, totalCrystalsEarned: 0 };
                    if (!data.permanentUpgrades) data.permanentUpgrades = { powerCore: 0, hullPlating: 0, engineBoost: 0, xpAmplifier: 0, crystalAttractor: 0 };
                    if (!data.highScores) data.highScores = { normal: 0, hard: 0, extreme: 0, nightmare: 0 };
                    if (data.currentDifficulty === undefined) data.currentDifficulty = 0;
                    if (data.tutorialDone === undefined) data.tutorialDone = false;
                    return data;
                }
            } catch (e) {
                console.warn('Could not load progression:', e);
            }
            return createDefaultProgression();
        }

        function saveProgression(data) {
            try {
                localStorage.setItem(PROGRESSION_SAVE_KEY, JSON.stringify(data));
            } catch (e) {
                console.warn('Could not save progression:', e);
            }
        }

        
        // Performance monitoring
        let frameTimeAccum = 0;
        let frameCount = 0;
        let avgFrameTime = 16;
        let lowPerfMode = false;

        // Disable glow effects for massive performance boost
        // shadowBlur is extremely expensive on canvas
        const ENABLE_GLOW_EFFECTS = false;

        // Helper to set glow only when enabled
        function setGlow(context, color, blur) {
            if (ENABLE_GLOW_EFFECTS) {
                context.shadowColor = color;
                context.shadowBlur = blur;
            }
        }

        function clearGlow(context) {
            if (ENABLE_GLOW_EFFECTS) {
                context.shadowBlur = 0;
            }
        }
        
        // Input state
        const keys = {};
        const input = {
            rotateLeft: false,
            rotateRight: false,
            thrust: false,
            reverse: false,
            pause: false
        };
        
        // Cheat code system
        let cheatCodeBuffer = '';
        let cheatCodeTimer = 0; // auto-clear buffer after inactivity
        const CHEAT_CODES = {
            'rocket': () => {
                if (!activeWeapons.includes('missile_launcher')) activeWeapons.push('missile_launcher');
                ['barrage', 'cluster_payload', 'heavy_payload'].forEach(b => { upgradeLevels[b] = 3; });
                spawnFloatingText(player.x, player.y - 50, 'MISSILES MAXED', '#FFD93D');
            },
            'orbit': () => {
                if (!activeWeapons.includes('orbital_shield')) activeWeapons.push('orbital_shield');
                ['orbital_expansion', 'shockwave', 'energy_absorption'].forEach(b => { upgradeLevels[b] = 3; });
                spawnFloatingText(player.x, player.y - 50, 'ORBITAL MAXED', '#00DFFF');
            },
            'chain': () => {
                if (!activeWeapons.includes('lightning_ray')) activeWeapons.push('lightning_ray');
                ['chain_amplifier', 'rapid_discharge', 'extended_arc'].forEach(b => { upgradeLevels[b] = 3; });
                spawnFloatingText(player.x, player.y - 50, 'LIGHTNING MAXED', '#9F7AEA');
            },
            'drone': () => {
                if (!activeWeapons.includes('alien_drone')) activeWeapons.push('alien_drone');
                ['drone_swarm', 'drone_power', 'volatile_core'].forEach(b => { upgradeLevels[b] = 3; });
                spawnFloatingText(player.x, player.y - 50, 'DRONES MAXED', '#39FF14');
            },
            'full': () => {
                for (const [wid, weapon] of Object.entries(WEAPONS)) {
                    if (!activeWeapons.includes(wid)) activeWeapons.push(wid);
                    for (const branchId of Object.keys(weapon.branches)) {
                        upgradeLevels[branchId] = 3;
                    }
                }
                spawnFloatingText(player.x, player.y - 50, 'ALL WEAPONS MAXED', '#FFD700');
            },
            'reset': () => {
                resetGame();
                spawnFloatingText(player.x, player.y - 50, 'GAME RESET', '#FF6B6B');
            },
        };
        
        // Touch state
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickMagnitude = 0;
        
        // Player
        let player = null;
        
        // Entity pools
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let particles = [];
        let floatingTexts = [];
        let pickups = [];
        let orbitals = [];
        let lightningEffects = [];
        let drones = [];
        let auraState = {
            tickTimer: 0,
            pulseAnimation: 0
        };

        // Camera system
        let camera = {
            x: 0,              // World X position (center of viewport)
            y: 0,              // World Y position (center of viewport)
            targetX: 0,        // Target X to follow (player.x)
            targetY: 0,        // Target Y to follow (player.y)
            smoothing: 0.1     // Camera lag for smooth follow (0.1 = 10% per frame)
        };


        // XP & Level state
        let playerXP = 0;
        let playerLevel = 1;
        let xpToNextLevel = XP_PER_LEVEL_BASE;
        
        // Upgrade state (multi-level system)
        let skillPoints = 0;
        let activeWeapons = ['laser_cannon']; // Weapons activated this run
        let upgradeLevels = {}; // { branchId: level (0-3) }
        let activeEvolutions = []; // weaponIds with evolution active
        let upgradeOptions = [];
        let upgradeSelectionActive = false;
        let crystalsThisRun = 0;
        let tempDamageMultiplier = 1;
        let tempDamageTimer = 0;
        let lastRunCrystals = null; // Breakdown for game over screen
        // Permanent upgrade effects (set from cachedProgression in resetGame)
        let playerMaxHP = PLAYER_MAX_HP;
        let permDamageMulti = 1;
        let permSpeedMulti = 1;
        let permXPMulti = 1;
        let permCrystalMulti = 1;
        // Current difficulty (loaded from progression)
        let currentDifficulty = 0;
        let shopReturnState = 'menu'; // Where to go when leaving shop

        // Spawn system
        let spawnTimer = 0;
        let spawnInterval = INITIAL_SPAWN_INTERVAL_MAX;
        let lastSpawnDecayTime = 0;
        let waveNumber = 0;

        // Wave system
        let waveTimer = WAVE_INTERVAL_BASE + Math.random() * WAVE_INTERVAL_VARIANCE;
        let lastWavePattern = null;

        // Effects
        let shakeIntensity = 0;
        let shakeDuration = 0;
        let shakeTimer = 0;
        let flashColor = null;
        let flashOpacity = 0;
        let flashDuration = 0;
        let slowmoTimer = 0;
        let slowmoDuration = 0;

        // Milestones
        let lastMilestone = 0;
        let milestoneActive = false;
        let milestoneTimer = 0;
        
        // Background
        let nebulas = [];
        let cachedBgGradient = null;
        let cachedScanlinePattern = null;
        let cachedVignetteGradient = null;
        let lastCacheWidth = 0;
        let lastCacheHeight = 0;

        // Idle state
        let idleTimer = 0;

        // ============================================================
        // PERFORMANCE OPTIMIZATIONS
        // ============================================================

        // Spatial Grid for collision detection optimization
        const SPATIAL_GRID_CELL_SIZE = 250;

        const spatialGrid = {
            cellSize: SPATIAL_GRID_CELL_SIZE,
            cells: new Map(),
            // Reusable arrays to avoid allocations
            _queryResults: [],
            _querySeen: new Set(),
            _cellKeys: [],

            getCellKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            },

            clear() {
                for (const cell of this.cells.values()) {
                    cell.length = 0;
                }
            },

            insert(entity, radius = 50) {
                const minCellX = Math.floor((entity.x - radius) / this.cellSize);
                const maxCellX = Math.floor((entity.x + radius) / this.cellSize);
                const minCellY = Math.floor((entity.y - radius) / this.cellSize);
                const maxCellY = Math.floor((entity.y + radius) / this.cellSize);

                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    for (let cy = minCellY; cy <= maxCellY; cy++) {
                        const key = `${cx},${cy}`;
                        if (!this.cells.has(key)) {
                            this.cells.set(key, []);
                        }
                        this.cells.get(key).push(entity);
                    }
                }
            },

            queryRadius(x, y, radius) {
                // Reuse arrays to avoid garbage collection
                const results = this._queryResults;
                const seen = this._querySeen;
                results.length = 0;
                seen.clear();

                const minCellX = Math.floor((x - radius) / this.cellSize);
                const maxCellX = Math.floor((x + radius) / this.cellSize);
                const minCellY = Math.floor((y - radius) / this.cellSize);
                const maxCellY = Math.floor((y + radius) / this.cellSize);

                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    for (let cy = minCellY; cy <= maxCellY; cy++) {
                        const cell = this.cells.get(`${cx},${cy}`);
                        if (cell) {
                            for (let i = 0; i < cell.length; i++) {
                                const entity = cell[i];
                                if (!seen.has(entity)) {
                                    seen.add(entity);
                                    results.push(entity);
                                }
                            }
                        }
                    }
                }
                return results;
            }
        };

        // Object Pool for reducing garbage collection
        class ObjectPool {
            constructor(factory, resetFn, capacity) {
                this.factory = factory;
                this.resetFn = resetFn;
                this.capacity = capacity;
                this.available = [];

                for (let i = 0; i < capacity; i++) {
                    this.available.push(factory());
                }
            }

            acquire() {
                if (this.available.length > 0) {
                    return this.available.pop();
                }
                return this.factory();
            }

            release(obj) {
                if (this.available.length < this.capacity) {
                    this.resetFn(obj);
                    this.available.push(obj);
                }
            }

            releaseAll(array) {
                for (const obj of array) {
                    this.release(obj);
                }
                array.length = 0;
            }
        }

        // Create object pools for all entity types (sized to support 1000+ entities)
        const pools = {
            bullet: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, damage: 1, type: 'laser', color: '', piercing: false, pierceCount: 0, hitEnemies: null, turnRate: 0, ricochetCount: 0, critChance: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.hitEnemies = null; obj.piercing = false; obj.pierceCount = 0; obj.turnRate = 0; obj.ricochetCount = 0; obj.critChance = 0; },
                500
            ),

            enemy: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, angle: 0, type: '', hp: 1, maxHp: 1, fireTimer: 0, burstCooldown: 0, spawnTime: 0, offScreenTime: 0, nearMissTriggered: false }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.hp = 1; obj.nearMissTriggered = false; obj.offScreenTime = 0; },
                400
            ),

            particle: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, size: 0, color: '', type: '', angle: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.angle = 0; },
                400
            ),

            enemyBullet: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, nearMissTriggered: false }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.nearMissTriggered = false; },
                300
            ),

            floatingText: new ObjectPool(
                () => ({ x: 0, y: 0, text: '', color: '', life: 0, maxLife: 0, vy: -50 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.text = ''; obj.life = 0; },
                100
            ),

            pickup: new ObjectPool(
                () => ({ x: 0, y: 0, type: '', life: 0, bobTimer: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.type = ''; obj.life = 0; obj.bobTimer = 0; },
                50
            ),

            drone: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, angle: 0, life: 0, damage: 15, explosionChance: 0, explosionRadius: 0, explosionDamage: 0, speedMulti: 1, trail: [] }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.angle = 0; obj.life = 0; obj.explosionChance = 0; obj.explosionRadius = 0; obj.explosionDamage = 0; obj.speedMulti = 1; obj.trail = []; },
                100
            )
        };

        // Culling distance thresholds
        const CULLING_DISTANCES = {
            enemies: 6000,
            particles: 4000,
            pickups: 5000,
            floatingTexts: 3000,
            bullets: 5760,
            enemyBullets: 5760,
            drones: 5000
        };

        // Fast removal helper: swap-and-pop is O(1) instead of splice's O(n)
        function fastRemove(array, index) {
            if (index < array.length - 1) {
                array[index] = array[array.length - 1];
            }
            array.pop();
        }

        // Performance monitoring
        const perfMonitor = {
            frameTimeAccum: 0,
            frameCount: 0,
            avgFrameTime: 16,
            fps: 60,

            entityCounts: {
                bullets: 0,
                enemies: 0,
                particles: 0,
                enemyBullets: 0,
                pickups: 0
            },

            optimizationStats: {
                spatialGridCells: 0,
                entitiesCulled: 0
            },

            update(dt) {
                this.frameTimeAccum += dt * 1000;
                this.frameCount++;

                if (this.frameCount >= 30) {
                    this.avgFrameTime = this.frameTimeAccum / this.frameCount;
                    this.fps = Math.round(1000 / this.avgFrameTime);
                    this.frameTimeAccum = 0;
                    this.frameCount = 0;
                }

                this.entityCounts.bullets = bullets.length;
                this.entityCounts.enemies = enemies.length;
                this.entityCounts.particles = particles.length;
                this.entityCounts.enemyBullets = enemyBullets.length;
                this.entityCounts.pickups = pickups.length;

                this.optimizationStats.spatialGridCells = spatialGrid.cells.size;
            },

            renderDebug() {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 100, 220, 220);

                ctx.font = '12px monospace';
                ctx.fillStyle = '#00FF00';
                ctx.textAlign = 'left';

                let y = 120;
                ctx.fillText(`FPS: ${this.fps}`, 20, y); y += 18;
                ctx.fillText(`Frame: ${this.avgFrameTime.toFixed(2)}ms`, 20, y); y += 18;
                ctx.fillText(`---`, 20, y); y += 18;
                ctx.fillText(`Bullets: ${this.entityCounts.bullets}`, 20, y); y += 18;
                ctx.fillText(`Enemies: ${this.entityCounts.enemies}`, 20, y); y += 18;
                ctx.fillText(`Particles: ${this.entityCounts.particles}`, 20, y); y += 18;
                ctx.fillText(`EnemyBullets: ${this.entityCounts.enemyBullets}`, 20, y); y += 18;
                ctx.fillText(`Pickups: ${this.entityCounts.pickups}`, 20, y); y += 18;
                ctx.fillText(`---`, 20, y); y += 18;
                ctx.fillText(`Grid Cells: ${this.optimizationStats.spatialGridCells}`, 20, y); y += 18;

                ctx.restore();
            }
        };

        let showDebugOverlay = false;

        // ============================================================
        // INITIALIZATION
        // ============================================================

        function initBackgroundCache() {
            // Only regenerate if dimensions changed
            if (lastCacheWidth === CANVAS_WIDTH && lastCacheHeight === CANVAS_HEIGHT) {
                return;
            }
            lastCacheWidth = CANVAS_WIDTH;
            lastCacheHeight = CANVAS_HEIGHT;

            // Regenerate background gradient (radial, lighter in center)
            const bgCenterX = CANVAS_WIDTH / 2;
            const bgCenterY = CANVAS_HEIGHT / 2;
            const bgOuterRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
            cachedBgGradient = ctx.createRadialGradient(
                bgCenterX, bgCenterY, 0,
                bgCenterX, bgCenterY, bgOuterRadius
            );
            cachedBgGradient.addColorStop(0, COLORS.BG_TOP);
            cachedBgGradient.addColorStop(1, COLORS.BG_BOTTOM);

            // Create scanline pattern (1x4 canvas with alternating lines)
            const scanlineCanvas = document.createElement('canvas');
            scanlineCanvas.width = 1;
            scanlineCanvas.height = 4;
            const scanlineCtx = scanlineCanvas.getContext('2d');
            scanlineCtx.fillStyle = 'rgba(127, 219, 255, 0.04)';
            scanlineCtx.fillRect(0, 0, 1, 2);
            // Lines 2-3 remain transparent
            cachedScanlinePattern = ctx.createPattern(scanlineCanvas, 'repeat');

            // Create vignette gradient
            const centerX = CANVAS_WIDTH / 2;
            const centerY = CANVAS_HEIGHT / 2;
            const innerRadius = CANVAS_HEIGHT * 0.3;
            const outerRadius = CANVAS_HEIGHT * 0.8;
            cachedVignetteGradient = ctx.createRadialGradient(
                centerX, centerY, innerRadius,
                centerX, centerY, outerRadius
            );
            cachedVignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            cachedVignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        }

        function init() {
            // Set canvas dimensions based on device
            if (isMobile()) {
                CANVAS_WIDTH = 720;
                CANVAS_HEIGHT = 1280;
            } else {
                CANVAS_WIDTH = 1920;
                CANVAS_HEIGHT = 1080;
            }

            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            // Load saved difficulty
            const initProg = loadProgression();
            currentDifficulty = initProg.currentDifficulty || 0;

            generateBackground();
            initBackgroundCache();
            setupInput();
            setupTouchControls();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Pause/resume audio when tab visibility changes
            document.addEventListener('visibilitychange', () => {
                if (!AudioManager.initialized) return;
                if (document.hidden) {
                    AudioManager.ctx.suspend();
                } else {
                    AudioManager.ctx.resume();
                }
            });

            requestAnimationFrame(gameLoop);
        }
        
        function resizeCanvas() {
            const windowRatio = window.innerWidth / window.innerHeight;
            const gameRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            
            let width, height;
            if (windowRatio > gameRatio) {
                height = window.innerHeight;
                width = height * gameRatio;
            } else {
                width = window.innerWidth;
                height = width / gameRatio;
            }
            
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        
        function generateBackground() {
            // Generate nebula blobs
            nebulas = [];
            for (let i = 0; i < 5; i++) {
                nebulas.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    radius: Math.random() * 100 + 50,
                    color: Math.random() > 0.5 ? 'rgba(199, 146, 255, 0.05)' : 'rgba(58, 154, 217, 0.05)'
                });
            }
        }
        
        function startGame() {
            const prog = loadProgression();
            if (!prog.tutorialDone) {
                gameState = 'tutorial';
                return;
            }
            gameState = 'playing';
            resetGame();
        }

        function selectTutorialWeapon(weaponId) {
            const prog = loadProgression();
            prog.unlockedWeapons[weaponId] = true;
            prog.tutorialDone = true;
            saveProgression(prog);
            gameState = 'playing';
            resetGame();
        }

        function resetGame() {
            player = {
                x: WORLD_WIDTH / 2,   // Center of world (5760)
                y: WORLD_HEIGHT / 2,  // Center of world (3240)
                vx: 0,
                vy: 0,
                angle: -90, // Pointing up
                hp: playerMaxHP,
                shield: PLAYER_MAX_SHIELD,
                shieldRegenTimer: 0,
                shieldFlashTimer: 0,
                fireTimer: 0,
                invulnerable: 0,
                thrusterScale: 0,
                thrusterParticleTimer: 0,
                bobOffset: 0,
                bobTimer: 0,
                // Shield Arc State
                shieldArcOpacity: SHIELD_ARC_IDLE_OPACITY,
                shieldArcTargetOpacity: SHIELD_ARC_IDLE_OPACITY,
                shieldArcIdleTimer: 0,
                shieldArcFlashTimer: 0,
                shieldArcFlashColor: null,
                shieldArcPulsePhase: 0,
                shieldArcLastValue: PLAYER_MAX_SHIELD
            };

            // Initialize camera at player position
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;

            // Release all pooled objects
            pools.bullet.releaseAll(bullets);
            pools.enemy.releaseAll(enemies);
            pools.particle.releaseAll(particles);
            pools.enemyBullet.releaseAll(enemyBullets);
            pools.floatingText.releaseAll(floatingTexts);
            pools.pickup.releaseAll(pickups);
            pools.drone.releaseAll(drones);

            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            floatingTexts = [];
            pickups = [];
            orbitals = [];
            lightningEffects = [];
            drones = [];
            auraState = { tickTimer: 0, pulseAnimation: 0 };

            score = 0;
            gameTime = 0;
            totalKills = 0;

            // Wave alert reset
            waveAlertActive = false;
            waveAlertTimer = 0;
            waveAlertNumber = 0;
            waveAlertSubtitle = '';
            
            // XP & Level reset
            playerXP = 0;
            playerLevel = 1;
            xpToNextLevel = XP_PER_LEVEL_BASE;
            
            // Upgrade system reset
            skillPoints = 0;
            activeWeapons = ['laser_cannon'];
            upgradeLevels = {};
            activeEvolutions = [];
            crystalsThisRun = 0;
            lastRunCrystals = null;
            tempDamageMultiplier = 1;
            tempDamageTimer = 0;
            upgradeOptions = [];
            upgradeSelectionActive = false;

            // Load and cache progression, apply permanent upgrades
            const prog = loadProgression();
            prog.stats.totalRuns++;
            saveProgression(prog);
            cachedProgression = prog;
            currentDifficulty = prog.currentDifficulty || 0;

            // Apply permanent upgrades
            const pu = prog.permanentUpgrades || {};
            permDamageMulti = 1 + (pu.powerCore || 0) * 0.04;
            playerMaxHP = PLAYER_MAX_HP + Math.floor((pu.hullPlating || 0) / 2);
            player.hp = playerMaxHP;
            permSpeedMulti = 1 + (pu.engineBoost || 0) * 0.03;
            permXPMulti = 1 + (pu.xpAmplifier || 0) * 0.05;
            permCrystalMulti = 1 + (pu.crystalAttractor || 0) * 0.05;

            document.getElementById('upgradePanel').classList.remove('active');
            
            spawnTimer = 0;
            spawnInterval = INITIAL_SPAWN_INTERVAL_MAX;
            lastSpawnDecayTime = 0;
            waveNumber = 0;
            waveTimer = WAVE_INTERVAL_BASE + Math.random() * WAVE_INTERVAL_VARIANCE;
            lastWavePattern = null;

            shakeIntensity = 0;
            shakeDuration = 0;
            flashColor = null;
            slowmoTimer = 0;
            
            lastMilestone = 0;
            milestoneActive = false;
            isNewHighScore = false;
            idleTimer = 0;
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================
        
        function setupInput() {
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;

                // Init audio on first interaction
                AudioManager.init();

                // Handle cheat codes (only when playing)
                if (gameState === 'playing' && e.key.length === 1) {
                    cheatCodeBuffer += e.key.toLowerCase();
                    cheatCodeTimer = 2.0; // clear buffer after 2s of inactivity

                    // Check if any cheat code matches the buffer
                    for (const [code, action] of Object.entries(CHEAT_CODES)) {
                        if (cheatCodeBuffer.includes(code)) {
                            action();
                            cheatCodeBuffer = '';
                            cheatCodeTimer = 0;
                            break;
                        }
                    }

                    // Keep buffer manageable
                    if (cheatCodeBuffer.length > 20) {
                        cheatCodeBuffer = cheatCodeBuffer.slice(-10);
                    }
                }
                
                if (e.code === 'Escape') {
                    if (gameState === 'playing') {
                        gameState = 'paused';
                    } else if (gameState === 'paused') {
                        gameState = 'playing';
                    }
                    // skilltree: no ESC close - must choose an upgrade
                }

                // P key pauses the game (skip if cheat code buffer is active)
                if (e.code === 'KeyP' && !cheatCodeBuffer) {
                    if (gameState === 'playing') {
                        gameState = 'paused';
                    } else if (gameState === 'paused') {
                        gameState = 'playing';
                    }
                }

                if (e.code === 'Enter' || e.code === 'Space') {
                    if (gameState === 'menu') {
                        startGame();
                    }
                }

                // D key cycles difficulty in menu
                if (gameState === 'menu' && e.code === 'KeyD') {
                    const prog = loadProgression();
                    const unlocked = getUnlockedDifficulties(prog);
                    const currentIdx = unlocked.indexOf(currentDifficulty);
                    const nextIdx = (currentIdx + 1) % unlocked.length;
                    currentDifficulty = unlocked[nextIdx];
                    prog.currentDifficulty = currentDifficulty;
                    saveProgression(prog);
                }

                // Tutorial: 1 = Orbital Shield, 2 = Missile Launcher
                if (gameState === 'tutorial') {
                    if (e.code === 'Digit1') selectTutorialWeapon('orbital_shield');
                    else if (e.code === 'Digit2') selectTutorialWeapon('missile_launcher');
                }

                // Shop navigation
                if (gameState === 'shop' && (e.code === 'Escape' || e.code === 'KeyS')) {
                    gameState = shopReturnState || 'menu';
                }
                if ((gameState === 'menu' || gameState === 'gameOver') && e.code === 'KeyS') {
                    shopReturnState = gameState;
                    gameState = 'shop';
                }

                if (e.code === 'KeyR' && gameState === 'gameOver') {
                    startGame();
                }

                // Toggle debug overlay with B key
                if (e.code === 'KeyB') {
                    showDebugOverlay = !showDebugOverlay;
                }

                // Upgrade panel: select with 1, 2, 3 keys
                if (gameState === 'skilltree' && upgradeSelectionActive) {
                    if (e.code === 'Digit1' && upgradeOptions[0]) {
                        selectUpgrade(upgradeOptions[0]);
                    } else if (e.code === 'Digit2' && upgradeOptions[1]) {
                        selectUpgrade(upgradeOptions[1]);
                    } else if (e.code === 'Digit3' && upgradeOptions[2]) {
                        selectUpgrade(upgradeOptions[2]);
                    }
                }
                
                e.preventDefault();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Canvas click for shop + tutorial + menu
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = CANVAS_WIDTH / rect.width;
                const scaleY = CANVAS_HEIGHT / rect.height;
                const clickX = (e.clientX - rect.left) * scaleX;
                const clickY = (e.clientY - rect.top) * scaleY;

                if (gameState === 'shop') {
                    handleShopClick(clickX, clickY);
                } else if (gameState === 'tutorial') {
                    handleTutorialClick(clickX, clickY);
                } else if (gameState === 'menu' || gameState === 'gameOver') {
                    handleMenuClick(clickX, clickY);
                }
            });
        }
        
        function updateInput() {
            input.rotateLeft = keys['ArrowLeft'] || keys['KeyA'];
            input.rotateRight = keys['ArrowRight'] || keys['KeyD'];
            input.thrust = keys['ArrowUp'] || keys['KeyW'];
            input.reverse = keys['ArrowDown'] || keys['KeyS'];
            // Apply touch input
            if (joystickActive) {
                if (joystickMagnitude > JOYSTICK_THRUST_THRESHOLD) {
                    input.thrust = true;
                }
                // Joystick rotation handled directly in player update
            }
            
        }
        
        function setupTouchControls() {
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');

            let joystickTouch = null;
            const baseRect = { x: 30, y: 0, cx: 90, cy: 0 };
            
            joystickZone.addEventListener('touchstart', (e) => {

                // Init audio on first touch
                AudioManager.init();

                // Helper to convert touch to canvas coordinates
                function touchToCanvas(touch) {
                    const rect = canvas.getBoundingClientRect();
                    return {
                        x: (touch.clientX - rect.left) * (CANVAS_WIDTH / rect.width),
                        y: (touch.clientY - rect.top) * (CANVAS_HEIGHT / rect.height)
                    };
                }

                if (gameState === 'menu') {
                    const coords = touchToCanvas(e.touches[0]);
                    if (!handleMenuClick(coords.x, coords.y)) {
                        startGame();
                    }
                    return;
                }

                if (gameState === 'gameOver') {
                    const coords = touchToCanvas(e.touches[0]);
                    if (!handleMenuClick(coords.x, coords.y)) {
                        startGame();
                    }
                    return;
                }

                if (gameState === 'shop') {
                    const coords = touchToCanvas(e.touches[0]);
                    handleShopClick(coords.x, coords.y);
                    return;
                }

                if (gameState === 'tutorial') {
                    const coords = touchToCanvas(e.touches[0]);
                    handleTutorialClick(coords.x, coords.y);
                    return;
                }

                if (gameState === 'skilltree') {
                    return; // Don't activate joystick during skill tree overlay
                }

                joystickTouch = e.touches[0];
                joystickActive = true;

                // Position joystick centered at touch point
                joystickBase.style.left = (joystickTouch.clientX - 40) + 'px';
                joystickBase.style.top = (joystickTouch.clientY - 40) + 'px';
                joystickBase.style.bottom = 'auto';
                joystickBase.style.transform = 'none';

                // Reset knob to center
                joystickKnob.style.left = '12px';
                joystickKnob.style.top = '12px';
                joystickMagnitude = 0;

                e.preventDefault();
            });
            
            joystickZone.addEventListener('touchmove', (e) => {
                if (joystickActive) {
                    joystickTouch = e.touches[0];
                    updateJoystick(joystickTouch);
                }
                e.preventDefault();
            });
            
            joystickZone.addEventListener('touchend', () => {
                joystickActive = false;
                joystickMagnitude = 0;
                joystickKnob.style.left = '12px';
                joystickKnob.style.top = '12px';

                // Reset joystick to default position (bottom center)
                joystickBase.style.left = '50%';
                joystickBase.style.top = 'auto';
                joystickBase.style.bottom = '140px';
                joystickBase.style.transform = 'translateX(-50%)';
            });
            
            function updateJoystick(touch) {
                const rect = joystickBase.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > JOYSTICK_MAX_DISTANCE) {
                    dx = (dx / dist) * JOYSTICK_MAX_DISTANCE;
                    dy = (dy / dist) * JOYSTICK_MAX_DISTANCE;
                }

                joystickKnob.style.left = (12 + dx) + 'px';
                joystickKnob.style.top = (12 + dy) + 'px';

                joystickMagnitude = Math.min(dist / JOYSTICK_MAX_DISTANCE, 1);
                joystickAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            }

        }

        // ============================================================
        // COORDINATE SYSTEM
        // ============================================================

        // Convert world coordinates to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: worldX - camera.x + CANVAS_WIDTH / 2,
                y: worldY - camera.y + CANVAS_HEIGHT / 2
            };
        }

        // Convert screen coordinates to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: screenX + camera.x - CANVAS_WIDTH / 2,
                y: screenY + camera.y - CANVAS_HEIGHT / 2
            };
        }

        // Check if position is within camera view (with padding)
        function isInView(worldX, worldY, padding = 100) {
            const screen = worldToScreen(worldX, worldY);
            return screen.x >= -padding &&
                   screen.x <= CANVAS_WIDTH + padding &&
                   screen.y >= -padding &&
                   screen.y <= CANVAS_HEIGHT + padding;
        }

        // Check if entity should be rendered based on distance from camera
        function shouldRenderEntity(entity, distanceThreshold) {
            const dx = entity.x - camera.x;
            const dy = entity.y - camera.y;
            const distSq = dx * dx + dy * dy;
            return distSq < distanceThreshold * distanceThreshold;
        }

        // ============================================================
        // SECTOR BOUNDARY SYSTEM
        // ============================================================

        function checkSectorBoundary() {
            if (!player) return;

            let transportX = 0;
            let transportY = 0;

            // Check X boundaries
            if (player.x > camera.x + SECTOR_BOUNDS.maxX) {
                // Player exited right side of center sector
                transportX = -3 * SECTOR_WIDTH;
                player.x += transportX;
            } else if (player.x < camera.x + SECTOR_BOUNDS.minX) {
                // Player exited left side of center sector
                transportX = 3 * SECTOR_WIDTH;
                player.x += transportX;
            }

            // Check Y boundaries
            if (player.y > camera.y + SECTOR_BOUNDS.maxY) {
                // Player exited bottom of center sector
                transportY = -3 * SECTOR_HEIGHT;
                player.y += transportY;
            } else if (player.y < camera.y + SECTOR_BOUNDS.minY) {
                // Player exited top of center sector
                transportY = 3 * SECTOR_HEIGHT;
                player.y += transportY;
            }

            // If transport occurred, transport all entities
            if (transportX !== 0 || transportY !== 0) {
                transportEntities(transportX, transportY);
            }
        }

        function transportEntities(offsetX, offsetY) {
            // Transport all entity types
            const entityPools = [
                enemies,
                bullets,
                enemyBullets,
                particles,
                pickups
            ];

            for (const pool of entityPools) {
                for (const entity of pool) {
                    entity.x += offsetX;
                    entity.y += offsetY;
                }
            }

            // Transport floating texts
            for (const text of floatingTexts) {
                text.x += offsetX;
                text.y += offsetY;
            }

            // Transport nebulas (for parallax consistency)
            for (const nebula of nebulas) {
                nebula.x += offsetX;
                nebula.y += offsetY;
            }


            // Update camera to follow player instantly (no lerp during transport)
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;
        }

        // ============================================================
        // CAMERA UPDATE
        // ============================================================

        function updateCamera() {
            if (!player) return;

            // Camera fixed to player (no smoothing)
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;
        }

        // ============================================================
        // GAME LOOP
        // ============================================================

        function gameLoop(timestamp) {
            // Calculate delta time
            if (lastTime === 0) lastTime = timestamp;
            const rawDt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            // Performance monitoring
            frameTimeAccum += rawDt * 1000;
            frameCount++;
            if (frameCount >= 30) {
                avgFrameTime = frameTimeAccum / frameCount;
                lowPerfMode = avgFrameTime > 40;
                frameTimeAccum = 0;
                frameCount = 0;
            }
            
            // Apply time scale (for slow-mo)
            deltaTime = Math.min(rawDt, 0.1) * timeScale;
            
            // Update time scale
            if (slowmoTimer > 0) {
                slowmoTimer -= rawDt * 1000;
                timeScale = SLOWMO_FACTOR;
            } else {
                timeScale = 1;
            }
            
            // Update based on game state
            if (gameState === 'playing') {
                update();
            }
            
            // Always render
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            updateInput();

            gameTime += deltaTime;
            idleTimer += deltaTime;


            // Auto-clear cheat code buffer after inactivity
            if (cheatCodeTimer > 0) {
                cheatCodeTimer -= deltaTime;
                if (cheatCodeTimer <= 0) {
                    cheatCodeBuffer = '';
                    cheatCodeTimer = 0;
                }
            }

            // Update wave alert timer
            if (waveAlertActive) {
                waveAlertTimer += deltaTime;
                if (waveAlertTimer >= WAVE_ALERT_DURATION) {
                    waveAlertActive = false;
                }
            }

            // Rebuild spatial grid for collision detection optimization
            spatialGrid.clear();
            for (const e of enemies) {
                const config = ENEMY_TYPES[e.type];
                spatialGrid.insert(e, config.radius + 100);
            }

            // Update performance monitor
            perfMonitor.update(deltaTime);

            // Update player FIRST (so camera can follow in same frame)
            updatePlayer();

            // Update camera immediately after player moves (prevents jitter)
            updateCamera();

            // Check sector boundaries AFTER both are updated
            checkSectorBoundary();


            // Update spawn system
            updateSpawnSystem();

            // Update other entities
            updateBullets();
            updateDrones();
            updateEnemies();
            updateEnemyBullets();
            updateParticles();
            updateFloatingTexts();
            updatePickups();
            updateWeapons();

            // Temp damage buff timer
            if (tempDamageTimer > 0) {
                tempDamageTimer -= deltaTime;
                if (tempDamageTimer <= 0) {
                    tempDamageMultiplier = 1;
                    tempDamageTimer = 0;
                }
            }

            // Check collisions
            checkCollisions();

            // Update effects
            updateEffects();

            // Survival time bonus (scaled by difficulty)
            score += deltaTime * getDiffMultipliers().score;

            // Check milestones
            checkMilestones();


            // Update high score
            if (score > highScore) {
                highScore = Math.floor(score);
                isNewHighScore = true;
            }
        }

        // ============================================================
        // SHIELD ARC STATE MACHINE
        // ============================================================

        function updateShieldArcState(deltaTime) {
            if (!player) return;

            const shieldPercent = player.shield / PLAYER_MAX_SHIELD;
            const isRegenerating = player.shieldRegenTimer >= SHIELD_REGEN_DELAY &&
                                   player.shield < PLAYER_MAX_SHIELD;
            const isLow = shieldPercent <= SHIELD_ARC_LOW_THRESHOLD && shieldPercent > 0;

            // Detect shield damage (shield decreased)
            if (player.shield < player.shieldArcLastValue) {
                // Instant visibility on damage
                player.shieldArcTargetOpacity = SHIELD_ARC_HIT_OPACITY;
                player.shieldArcOpacity = SHIELD_ARC_HIT_OPACITY;
                player.shieldArcFlashTimer = SHIELD_ARC_FLASH_DURATION;
                player.shieldArcFlashColor = '#FFFFFF';
                player.shieldArcIdleTimer = 0;
            }
            player.shieldArcLastValue = player.shield;

            // Update flash timer
            if (player.shieldArcFlashTimer > 0) {
                player.shieldArcFlashTimer -= deltaTime;
                if (player.shieldArcFlashTimer <= 0) {
                    player.shieldArcFlashColor = null;
                }
            }

            // Determine target opacity based on state (priority order)
            if (isLow) {
                // LOW: Always visible with warning
                player.shieldArcTargetOpacity = SHIELD_ARC_HIT_OPACITY;
                player.shieldArcIdleTimer = 0;
            } else if (player.shieldArcFlashTimer > 0) {
                // HIT: Keep visible during flash
                player.shieldArcTargetOpacity = SHIELD_ARC_HIT_OPACITY;
            } else if (isRegenerating) {
                // REGEN: Semi-visible
                player.shieldArcTargetOpacity = SHIELD_ARC_REGEN_OPACITY;
                player.shieldArcIdleTimer = 0;
            } else if (shieldPercent >= 1.0) {
                // FULL: Fade to idle after delay
                player.shieldArcIdleTimer += deltaTime;
                if (player.shieldArcIdleTimer >= SHIELD_ARC_FADE_DELAY) {
                    player.shieldArcTargetOpacity = SHIELD_ARC_IDLE_OPACITY;
                }
            } else {
                // IDLE: Fade after inactivity
                player.shieldArcIdleTimer += deltaTime;
                if (player.shieldArcIdleTimer >= SHIELD_ARC_FADE_DELAY) {
                    player.shieldArcTargetOpacity = SHIELD_ARC_IDLE_OPACITY;
                }
            }

            // Animate opacity with lerp (fast on hit, slow otherwise)
            const opacitySpeed = player.shieldArcFlashTimer > 0 ? 20 : 3;
            player.shieldArcOpacity += (player.shieldArcTargetOpacity - player.shieldArcOpacity) *
                                       opacitySpeed * deltaTime;

            // Update pulse phase for regen/low animation
            player.shieldArcPulsePhase += deltaTime * 5;
        }

        // ============================================================
        // PLAYER
        // ============================================================

        function updatePlayer() {
            if (!player) return;
            
            // Rotation
            let targetRotation = 0;
            if (input.rotateLeft) targetRotation -= ROTATION_SPEED;
            if (input.rotateRight) targetRotation += ROTATION_SPEED;
            
            // Touch joystick rotation - almost instant rotation towards joystick direction
            if (joystickActive && joystickMagnitude > JOYSTICK_DEADZONE) {
                const angleDiff = normalizeAngle(joystickAngle - player.angle);
                if (Math.abs(angleDiff) > JOYSTICK_ROTATION_THRESHOLD) {
                    // Near-instant rotation: lerp 90% of the way each frame
                    player.angle = player.angle + angleDiff * 0.1;
                    targetRotation = 0; // Bypass normal rotation system
                }
            }
            
            player.angle += targetRotation * deltaTime;
            
            // Thrust
            const rad = player.angle * Math.PI / 180;
            let accel = 0;
            
            if (input.thrust) {
                accel = THRUST_ACCEL * permSpeedMulti;
                player.thrusterScale = Math.min(1, player.thrusterScale + deltaTime / 0.08);
                idleTimer = 0;
            } else if (input.reverse) {
                accel = -REVERSE_ACCEL * permSpeedMulti;
                idleTimer = 0;
            }
            
            if (!input.thrust) {
                player.thrusterScale = Math.max(0, player.thrusterScale - deltaTime / 0.12);
            }
            
            player.vx += Math.cos(rad) * accel * deltaTime / PLAYER_MASS;
            player.vy += Math.sin(rad) * accel * deltaTime / PLAYER_MASS;
            
            // Apply drag
            const dragMult = Math.exp(-DRAG_FACTOR * deltaTime);
            player.vx *= dragMult;
            player.vy *= dragMult;
            
            // Clamp speed
            const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            const effectiveMaxSpeed = MAX_SPEED * permSpeedMulti;
            if (speed > effectiveMaxSpeed) {
                player.vx = (player.vx / speed) * effectiveMaxSpeed;
                player.vy = (player.vy / speed) * effectiveMaxSpeed;
            }
            
            // Position update
            player.x += player.vx * deltaTime;
            player.y += player.vy * deltaTime;

            // Invulnerability
            player.invulnerable = Math.max(0, player.invulnerable - deltaTime);

            // Shield regeneration
            player.shieldFlashTimer = Math.max(0, player.shieldFlashTimer - deltaTime);
            player.shieldRegenTimer += deltaTime;
            if (player.shieldRegenTimer >= SHIELD_REGEN_DELAY && player.shield < PLAYER_MAX_SHIELD) {
                player.shield = Math.min(PLAYER_MAX_SHIELD, player.shield + SHIELD_REGEN_RATE * deltaTime);
            }

            // Update shield arc visibility state
            updateShieldArcState(deltaTime);

            // Auto-fire laser (only when enemy is in aim cone)
            player.fireTimer -= deltaTime;
            if (player.fireTimer <= 0 && hasEnemyInAimCone()) {
                fireBullet();
                player.fireTimer = getWeaponStats().fireRate;
            }

            // Auto-fire rockets (independent system, 360Âº detection)
            if (!player.rocketTimer) player.rocketTimer = 0;
            player.rocketTimer -= deltaTime;
            const stats = getWeaponStats();
            if (stats.hasRockets && player.rocketTimer <= 0) {
                const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, 600);
                fireRocket(nearbyEnemies, stats);
                // Cooldown fijo de 1.0s (la habilidad ahora aumenta la rÃ¡faga, no la cadencia)
                player.rocketTimer = 1.0;
            }

            // Auto-fire lightning (independent system, 360Âº detection)
            if (!player.lightningTimer) player.lightningTimer = 0;
            player.lightningTimer -= deltaTime;
            if (stats.hasLightning && player.lightningTimer <= 0) {
                const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, stats.lightningRange);
                const rangeSq = stats.lightningRange * stats.lightningRange;
                if (nearbyEnemies.length > 0) {
                    fireLightning(nearbyEnemies, stats);
                    player.lightningTimer = stats.lightningCadence;
                }
            }

            // Idle bob
            if (idleTimer > 2) {
                player.bobTimer += deltaTime;
                player.bobOffset = Math.sin(player.bobTimer * 5.2) * 2;
            } else {
                player.bobOffset *= 0.9;
            }
            
            // Spawn thruster particles at fixed interval
            if (player.thrusterScale > 0.3) {
                player.thrusterParticleTimer -= deltaTime;
                if (player.thrusterParticleTimer <= 0) {
                    spawnThrusterParticle();
                    player.thrusterParticleTimer = THRUSTER_PARTICLE_INTERVAL;
                }
            } else {
                player.thrusterParticleTimer = 0;
            }
        }
        
        // Compute weapon stats from activeWeapons + upgradeLevels
        function getWeaponStats() {
            // === LASER CANNON ===
            let hasLaser = activeWeapons.includes('laser_cannon');
            let damage = hasLaser ? 10 : 8;
            let fireRate = 0.35;
            let pierce = 0;
            let pierceInfinite = false;
            let spreadCount = 0;
            let spreadAngle = 8;

            if (hasLaser) {
                const rfLvl = upgradeLevels['rapid_fire'] || 0;
                if (rfLvl >= 1) fireRate = 0.28;
                if (rfLvl >= 2) fireRate = 0.22;
                if (rfLvl >= 3) fireRate = 0.16;

                const bsLvl = upgradeLevels['beam_splitter'] || 0;
                if (bsLvl >= 1) spreadCount = 3;
                if (bsLvl >= 2) spreadCount = 5;
                if (bsLvl >= 3) spreadCount = 7;

                const plLvl = upgradeLevels['piercing_lens'] || 0;
                if (plLvl >= 1) pierce = 2;
                if (plLvl >= 2) { pierce = 2; damage = 14; }
                if (plLvl >= 3) { pierceInfinite = true; damage = 18; }
            }

            // === MISSILE LAUNCHER ===
            let hasRockets = activeWeapons.includes('missile_launcher');
            let rocketBurstCount = 3;
            let rocketDamage = 22;
            let rocketExplosionDamage = 30;
            let rocketExplosionRadius = 120;
            let rocketRicochetCount = 0;
            let rocketCritChance = 0;

            if (hasRockets) {
                const baLvl = upgradeLevels['barrage'] || 0;
                if (baLvl >= 1) rocketBurstCount = 4;
                if (baLvl >= 2) rocketBurstCount = 5;
                if (baLvl >= 3) rocketBurstCount = 7;

                const cpLvl = upgradeLevels['cluster_payload'] || 0;
                if (cpLvl >= 1) rocketExplosionRadius = 160;
                if (cpLvl >= 2) rocketRicochetCount = 2;
                if (cpLvl >= 3) { rocketExplosionDamage = 45; rocketRicochetCount = 3; }

                const hpLvl = upgradeLevels['heavy_payload'] || 0;
                if (hpLvl >= 1) rocketDamage = 30;
                if (hpLvl >= 2) rocketDamage = 40;
                if (hpLvl >= 3) { rocketDamage = 50; rocketCritChance = 0.20; }
            }

            // === ORBITAL SHIELD ===
            let hasOrbit = activeWeapons.includes('orbital_shield');
            let orbCount = 3;
            let orbDamage = 16;
            let orbSizeMulti = 1.0;
            let orbKnockback = 0;
            let orbSlow = 0;

            if (hasOrbit) {
                const oeLvl = upgradeLevels['orbital_expansion'] || 0;
                if (oeLvl >= 1) orbCount = 4;
                if (oeLvl >= 2) orbCount = 5;
                if (oeLvl >= 3) orbCount = 7;

                const swLvl = upgradeLevels['shockwave'] || 0;
                if (swLvl >= 1) orbSizeMulti = 1.3;
                if (swLvl >= 2) { orbSizeMulti = 1.6; orbKnockback = 1; }
                if (swLvl >= 3) { orbSizeMulti = 2.0; orbKnockback = 2; }

                const eaLvl = upgradeLevels['energy_absorption'] || 0;
                if (eaLvl >= 1) orbDamage = 24;
                if (eaLvl >= 2) orbDamage = 32;
                if (eaLvl >= 3) { orbDamage = 40; orbSlow = 0.25; }
            }

            // === LIGHTNING RAY ===
            let hasLightning = activeWeapons.includes('lightning_ray');
            let lightningBounces = 6;
            let lightningCadence = 1.2;
            let lightningRange = 225;
            let lightningChainRange = 200;
            let lightningDamage = 8;

            if (hasLightning) {
                const caLvl = upgradeLevels['chain_amplifier'] || 0;
                if (caLvl >= 1) lightningBounces = 8;
                if (caLvl >= 2) lightningBounces = 10;
                if (caLvl >= 3) lightningBounces = 14;

                const rdLvl = upgradeLevels['rapid_discharge'] || 0;
                if (rdLvl >= 1) lightningCadence = 1.0;
                if (rdLvl >= 2) lightningCadence = 0.8;
                if (rdLvl >= 3) lightningCadence = 0.6;

                const exLvl = upgradeLevels['extended_arc'] || 0;
                if (exLvl >= 1) { lightningRange = 300; lightningChainRange = 270; }
                if (exLvl >= 2) { lightningDamage = 12; }
                if (exLvl >= 3) { lightningRange = 400; lightningChainRange = 350; lightningDamage = 16; }
            }

            // === PLASMA FIELD ===
            let hasAura = activeWeapons.includes('plasma_field');
            let auraRadius = 100;
            let auraDamage = 4;
            let auraTickRate = 0.50;
            let auraSlow = 0;

            if (hasAura) {
                const feLvl = upgradeLevels['field_expansion'] || 0;
                if (feLvl >= 1) auraRadius = 130;
                if (feLvl >= 2) auraRadius = 170;
                if (feLvl >= 3) auraRadius = 220;

                const fiLvl = upgradeLevels['field_intensity'] || 0;
                if (fiLvl >= 1) auraDamage = 12;
                if (fiLvl >= 2) auraDamage = 17;
                if (fiLvl >= 3) { auraDamage = 24; auraSlow = 0.20; }

                const rpLvl = upgradeLevels['rapid_pulse'] || 0;
                if (rpLvl >= 1) auraTickRate = 0.40;
                if (rpLvl >= 2) auraTickRate = 0.30;
                if (rpLvl >= 3) auraTickRate = 0.22;
            }

            // === ALIEN DRONE ===
            let hasDrones = activeWeapons.includes('alien_drone');
            let droneBaseCount = 1;
            let droneExtraChance = 0;
            let droneExtraCount = 0;
            let droneDamage = 15;
            let droneRange = 400;
            let droneSpeedMulti = 1.0;
            let droneLifetime = 1.5;
            let droneExplosionChance = 0;
            let droneExplosionRadius = 0;
            let droneExplosionDamage = 0;

            if (hasDrones) {
                const dsLvl = upgradeLevels['drone_swarm'] || 0;
                if (dsLvl >= 1) { droneExtraChance = 0.30; droneExtraCount = 1; }
                if (dsLvl >= 2) { droneExtraChance = 0.60; droneExtraCount = 1; }
                if (dsLvl >= 3) { droneBaseCount = 2; droneExtraChance = 0.40; droneExtraCount = 1; }

                const dpLvl = upgradeLevels['drone_power'] || 0;
                if (dpLvl >= 1) droneDamage = 22;
                if (dpLvl >= 2) { droneDamage = 30; droneRange = 550; }
                if (dpLvl >= 3) { droneDamage = 40; droneRange = 550; droneSpeedMulti = 1.3; }

                const vcLvl = upgradeLevels['volatile_core'] || 0;
                if (vcLvl >= 1) { droneExplosionChance = 0.30; droneExplosionRadius = 60; droneExplosionDamage = 12; }
                if (vcLvl >= 2) { droneExplosionChance = 0.55; droneExplosionRadius = 80; droneExplosionDamage = 18; }
                if (vcLvl >= 3) { droneExplosionChance = 0.80; droneExplosionRadius = 100; droneExplosionDamage = 25; }
            }

            // Temp damage buff (from bonus_damage) + permanent Power Core
            const finalDamageMulti = (tempDamageMultiplier || 1) * permDamageMulti;

            return {
                // Laser
                hasLaser, damage: Math.round(damage * finalDamageMulti), fireRate, pierce, pierceInfinite, spreadCount, spreadAngle,
                // Missiles
                hasRockets, rocketBurstCount, rocketDamage: Math.round(rocketDamage * finalDamageMulti),
                rocketExplosionDamage: Math.round(rocketExplosionDamage * finalDamageMulti),
                rocketExplosionRadius, rocketRicochetCount, rocketCritChance,
                // Orbital
                hasOrbit, orbCount, orbDamage: Math.round(orbDamage * finalDamageMulti),
                orbSizeMulti, orbKnockback, orbSlow,
                // Lightning
                hasLightning, lightningBounces, lightningCadence,
                lightningRange, lightningChainRange,
                lightningDamage: Math.round(lightningDamage * finalDamageMulti),
                // Plasma
                hasAura, auraRadius, auraDamage: Math.round(auraDamage * finalDamageMulti),
                auraTickRate, auraSlow,
                // Drones
                hasDrones, droneBaseCount, droneExtraChance, droneExtraCount,
                droneDamage: Math.round(droneDamage * finalDamageMulti), droneRange,
                droneSpeedMulti, droneLifetime, droneExplosionChance,
                droneExplosionRadius, droneExplosionDamage: Math.round(droneExplosionDamage * finalDamageMulti),
                // Evolutions
                hasNovaBeam: activeEvolutions.includes('laser_cannon'),
                hasArmageddon: activeEvolutions.includes('missile_launcher'),
                hasSingularity: activeEvolutions.includes('orbital_shield'),
                hasStormNexus: activeEvolutions.includes('lightning_ray'),
                hasAnnihilation: activeEvolutions.includes('plasma_field'),
                hasHiveMind: activeEvolutions.includes('alien_drone'),
                // Final multiplier
                damageMultiplier: finalDamageMulti
            };
        }

        function hasEnemyInAimCone() {
            const playerRad = player.angle * Math.PI / 180;
            const aimCone = AUTO_AIM_CONE_DEGREES * Math.PI / 180;

            for (const enemy of enemies) {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > AUTO_AIM_MAX_DISTANCE) continue;

                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);

                if (angleDiff <= aimCone) {
                    return true;
                }
            }

            return false;
        }

        // TODO: EVOLUTION - Nova Beam: every 5th shot, fire a massive cone beam
        function fireBullet() {
            const playerRad = player.angle * Math.PI / 180;
            const noseOffset = PLAYER_SIZE / 2 - PLAYER_PIVOT_OFFSET;
            const noseX = player.x + Math.cos(playerRad) * noseOffset;
            const noseY = player.y + Math.sin(playerRad) * noseOffset;
            
            // Get computed stats from skill tree
            const stats = getWeaponStats();
            const bulletSpeed = BULLET_SPEED;
            
            // Auto-aim: find enemy within frontal cone and predict intercept point
            let targetRad = playerRad;
            let closestDist = Infinity;
            let closestEnemy = null;
            const aimCone = AUTO_AIM_CONE_DEGREES * Math.PI / 180;

            for (const enemy of enemies) {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);

                if (angleDiff <= aimCone && dist < closestDist && dist <= AUTO_AIM_MAX_DISTANCE) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            }


            // Calculate intercept point (lead the target)
            if (closestEnemy) {
                const evx = closestEnemy.vx || 0;
                const evy = closestEnemy.vy || 0;

                // Iterative approximation for intercept point (2 iterations for accuracy)
                let predictedX = closestEnemy.x;
                let predictedY = closestEnemy.y;

                for (let i = 0; i < 2; i++) {
                    const dx = predictedX - noseX;
                    const dy = predictedY - noseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const timeToTarget = dist / bulletSpeed;

                    predictedX = closestEnemy.x + evx * timeToTarget;
                    predictedY = closestEnemy.y + evy * timeToTarget;
                }

                targetRad = Math.atan2(predictedY - noseY, predictedX - noseX);
            }
            
            // Fire main weapon (LASER or BEAM if pierce unlocked)
            const hasPierce = stats.pierce > 0 || stats.pierceInfinite;
            const hasSpread = stats.spreadCount > 0;
            if (hasPierce) {
                // Pierce/Beam shot
                const pierceSpeedMult = hasSpread ? 1 : 1.2;
                const pierceLifeMult = hasSpread ? 1 : 1.5;
                const bullet = pools.bullet.acquire();
                bullet.x = noseX;
                bullet.y = noseY;
                bullet.vx = Math.cos(targetRad) * (bulletSpeed * pierceSpeedMult);
                bullet.vy = Math.sin(targetRad) * (bulletSpeed * pierceSpeedMult);
                bullet.life = BULLET_LIFETIME * pierceLifeMult;
                bullet.damage = stats.damage;
                bullet.type = 'beam';
                bullet.color = COLORS.BULLET;
                bullet.piercing = true;
                bullet.pierceCount = stats.pierceInfinite ? 9999 : stats.pierce;
                bullet.hitEnemies = new Set();
                bullets.push(bullet);
            } else {
                // Normal laser shot
                const bullet = pools.bullet.acquire();
                bullet.x = noseX;
                bullet.y = noseY;
                bullet.vx = Math.cos(targetRad) * bulletSpeed;
                bullet.vy = Math.sin(targetRad) * bulletSpeed;
                bullet.life = BULLET_LIFETIME;
                bullet.damage = stats.damage;
                bullet.type = 'laser';
                bullet.color = WEAPONS['laser_cannon'].color;
                bullet.piercing = false;
                bullets.push(bullet);
            }

            // Fire SPREAD if unlocked (additional bullets in cone, excluding center)
            if (stats.spreadCount > 0) {
                const sAngle = stats.spreadAngle;
                const mainColor = WEAPONS['laser_cannon'].color;

                for (let i = 0; i < stats.spreadCount; i++) {
                    const middleIndex = (stats.spreadCount - 1) / 2;
                    if (i === middleIndex) continue;

                    const offset = ((i / (stats.spreadCount - 1)) - 0.5) * 2 * (sAngle * Math.PI / 180);
                    const angle = targetRad + offset;
                    const spreadBullet = pools.bullet.acquire();
                    spreadBullet.x = noseX;
                    spreadBullet.y = noseY;
                    spreadBullet.vx = Math.cos(angle) * bulletSpeed;
                    spreadBullet.vy = Math.sin(angle) * bulletSpeed;
                    spreadBullet.life = BULLET_LIFETIME;
                    spreadBullet.damage = stats.damage;
                    spreadBullet.type = 'laser';
                    spreadBullet.color = mainColor;
                    spreadBullet.piercing = hasPierce;
                    if (hasPierce) {
                        spreadBullet.pierceCount = stats.pierceInfinite ? 9999 : stats.pierce;
                        spreadBullet.hitEnemies = new Set();
                    }

                    bullets.push(spreadBullet);
                }
            }
        }

        // Fire rockets in burst (360Âº enemy detection)
        // TODO: EVOLUTION - Armageddon Protocol: every 8s, fire a mega-missile with massive explosion
        function fireRocket(nearbyEnemies, stats) {
            // Find closest enemy to aim at
            let closestEnemy = null;
            let closestDist = Infinity;
            for (const e of nearbyEnemies) {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = e;
                }
            }
            if (!closestEnemy) return;

            // Disparar rÃ¡faga de misiles con delays
            const burstCount = stats.rocketBurstCount; // 3 normal, 6 con habilidad
            const delayBetweenRockets = 50; // ms entre cada misil de la rÃ¡faga
            const angleSpread = 0.4; // DispersiÃ³n angular total de la rÃ¡faga (radianes)

            for (let i = 0; i < burstCount; i++) {
                setTimeout(() => {
                    // Recalcular posiciÃ³n del enemigo para cada misil (puede haberse movido)
                    const currentDx = closestEnemy.x - player.x;
                    const currentDy = closestEnemy.y - player.y;
                    const currentDist = Math.sqrt(currentDx * currentDx + currentDy * currentDy);

                    // Predict enemy position based on velocity
                    const rocketSpeed = 600;
                    const timeToTarget = currentDist / rocketSpeed;
                    const predictedX = closestEnemy.x + (closestEnemy.vx || 0) * timeToTarget * 0.5;
                    const predictedY = closestEnemy.y + (closestEnemy.vy || 0) * timeToTarget * 0.5;

                    // Ãngulo base hacia el objetivo
                    const baseAngle = Math.atan2(predictedY - player.y, predictedX - player.x);

                    // Calcular offset angular para efecto de rÃ¡faga
                    // Distribuye los misiles en un abanico
                    const angleOffset = (i / (burstCount - 1) - 0.5) * angleSpread + (Math.random() - 0.5) * 0.1;
                    const angleToTarget = baseAngle + (burstCount > 1 ? angleOffset : 0);

                    const rocket = pools.bullet.acquire();
                    rocket.x = player.x;
                    rocket.y = player.y;

                    // === COMPORTAMIENTO DE MISIL REALISTA ===
                    // Fase 1: Impulso inicial
                    const initialSpeed = 1000;
                    const boostDuration = 0.3;

                    // Fase 2: NavegaciÃ³n (girando)
                    const cruiseSpeed = 150;

                    // Fase 3: AproximaciÃ³n final
                    const finalSpeed = 1200;
                    const angleThreshold = 10.2;

                    // ConfiguraciÃ³n del misil
                    rocket.currentSpeed = initialSpeed;
                    rocket.targetSpeed = initialSpeed;
                    rocket.initialSpeed = initialSpeed;
                    rocket.cruiseSpeed = cruiseSpeed;
                    rocket.finalSpeed = finalSpeed;
                    rocket.boostTimer = boostDuration;
                    rocket.angleThreshold = angleThreshold;
                    rocket.targetAngle = angleToTarget;
                    rocket.hasCompletedBoostPhase = false;

                    // Spawn perpendicular al objetivo con variaciÃ³n por misil
                    const spawnAngle = angleToTarget - Math.PI;
                    rocket.vx = Math.cos(spawnAngle) * initialSpeed;
                    rocket.vy = Math.sin(spawnAngle) * initialSpeed;

                    // Propiedades estÃ¡ndar
                    rocket.life = 2;
                    rocket.damage = stats.rocketDamage;
                    rocket.explosionDamage = stats.rocketExplosionDamage;
                    rocket.explosionRadius = stats.rocketExplosionRadius;
                    rocket.ricochetCount = stats.rocketRicochetCount;
                    rocket.critChance = stats.rocketCritChance;
                    rocket.type = 'rocket';
                    rocket.color = COLORS.PLAYER;
                    rocket.piercing = false;
                    rocket.turnRate = 300;
                    rocket.trail = [];
                    bullets.push(rocket);
                }, i * delayBetweenRockets);
            }
        }

        // TODO: EVOLUTION - Storm Nexus: residual electric field between hit enemies
        function fireLightning(nearbyEnemies, stats) {
            // Find closest enemy to start the chain
            let closestEnemy = null;
            let closestDist = Infinity;

            for (const e of nearbyEnemies) {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = e;
                }
            }
            if (!closestEnemy) return;

            // Build the lightning chain - collect all targets first, then apply damage
            const chainPoints = [{ x: player.x, y: player.y }];
            const chainTargets = [];
            const hitEnemies = new Set();
            let currentTarget = closestEnemy;
            let bounceCount = 0;

            // Phase 1: Build the chain (find all targets)
            while (currentTarget && bounceCount < stats.lightningBounces) {
                chainPoints.push({ x: currentTarget.x, y: currentTarget.y });
                chainTargets.push(currentTarget);
                hitEnemies.add(currentTarget);
                bounceCount++;

                // Find next closest enemy within chain range from current target
                const lastHitX = currentTarget.x;
                const lastHitY = currentTarget.y;

                let nextTarget = null;
                let nextDist = Infinity;

                for (const candidate of enemies) {
                    if (hitEnemies.has(candidate)) continue;
                    if (candidate.hp <= 0) continue;

                    const dx = candidate.x - lastHitX;
                    const dy = candidate.y - lastHitY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= stats.lightningChainRange && dist < nextDist) {
                        nextDist = dist;
                        nextTarget = candidate;
                    }
                }

                currentTarget = nextTarget;
            }

            // Phase 2: Apply damage to all targets and kill dead enemies
            const enemiesToKill = [];
            for (const target of chainTargets) {
                {
                    const config = ENEMY_TYPES[target.type];
                    target.hp -= stats.lightningDamage;

                    // Visual feedback
                    spawnFloatingText(target.x, target.y - config.radius,
                        stats.lightningDamage.toString(), WEAPONS['lightning_ray'].color);
                    spawnRing(target.x, target.y, WEAPONS['lightning_ray'].color);

                    if (target.hp <= 0) {
                        enemiesToKill.push(target);
                    }
                }
            }

            // Phase 3: Kill dead enemies (after chain is complete)
            for (const target of enemiesToKill) {
                const enemyIndex = enemies.indexOf(target);
                if (enemyIndex !== -1) {
                    killEnemy(target, enemyIndex);
                }
            }


            // Create lightning visual effect with pre-computed zigzag
            if (chainPoints.length > 1) {
                // Generate zigzag path between each pair of points
                const zigzagPoints = [];
                for (let i = 0; i < chainPoints.length - 1; i++) {
                    const start = chainPoints[i];
                    const end = chainPoints[i + 1];

                    // Add start point
                    if (i === 0) zigzagPoints.push({ x: start.x, y: start.y });

                    // Calculate distance and direction
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Number of zigzag segments based on distance
                    const segments = Math.max(3, Math.floor(dist / 30));
                    const perpX = -dy / dist;
                    const perpY = dx / dist;

                    // Generate zigzag points
                    for (let s = 1; s < segments; s++) {
                        const t = s / segments;
                        const baseX = start.x + dx * t;
                        const baseY = start.y + dy * t;

                        // Alternating zigzag with random offset (narrower)
                        const zigzagAmount = (Math.random() * 12 + 6) * (s % 2 === 0 ? 1 : -1);
                        zigzagPoints.push({
                            x: baseX + perpX * zigzagAmount,
                            y: baseY + perpY * zigzagAmount
                        });
                    }

                    // Add end point
                    zigzagPoints.push({ x: end.x, y: end.y });
                }

                lightningEffects.push({
                    points: zigzagPoints,
                    life: 0.2,
                    maxLife: 0.2,
                    color: WEAPONS['lightning_ray'].color
                });
            }
        }

        function spawnAlienDrone(x, y) {
            const stats = getWeaponStats();
            if (!stats.hasDrones) return;

            // Calculate actual drone count (base + extra chance)
            let count = stats.droneBaseCount;
            if (Math.random() < stats.droneExtraChance) count += stats.droneExtraCount;

            for (let i = 0; i < count; i++) {
                const drone = pools.drone.acquire();

                const angleOffset = count > 1 ? (i / count) * Math.PI * 2 : 0;
                drone.x = x + Math.cos(angleOffset) * 10;
                drone.y = y + Math.sin(angleOffset) * 10;

                drone.vx = Math.cos(angleOffset) * 100;
                drone.vy = Math.sin(angleOffset) * 100;
                drone.angle = angleOffset * 180 / Math.PI;

                drone.life = stats.droneLifetime;
                drone.damage = stats.droneDamage;
                drone.explosionChance = stats.droneExplosionChance;
                drone.explosionRadius = stats.droneExplosionRadius;
                drone.explosionDamage = stats.droneExplosionDamage;
                drone.speedMulti = stats.droneSpeedMulti;
                drone.trail = [];
                drone.color = COLORS.PLAYER;

                drones.push(drone);
            }
        }

        function spawnThrusterParticle() {
            const rad = (player.angle + 180) * Math.PI / 180;
            const spread = (Math.random() - 0.5) * 0.1;
            const tailOffset = 20 + PLAYER_PIVOT_OFFSET;

            const p = pools.particle.acquire();
            p.x = player.x + Math.cos(rad) * tailOffset;
            p.y = player.y + Math.sin(rad) * tailOffset;
            p.vx = Math.cos(rad + spread) * (400 + Math.random() * 5);
            p.vy = Math.sin(rad + spread) * (400 + Math.random() * 5);
            p.life = 0.2 + Math.random() * 0.2;
            p.maxLife = 0.6;
            p.size = 12 + Math.random() * 15;
            p.color = COLORS.PLAYER;
            p.type = 'thruster';
            p.rotation = Math.random() * Math.PI * 2;
            p.rotationSpeed = (Math.random() - 0.5) * 2;

            particles.push(p);
        }
        
        // ============================================================
        // BULLETS
        // ============================================================
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                
                // Rocket and mini-rocket homing behavior
                if (b.type === 'rocket' || b.type === 'mini_rocket') {
                    // Find nearest enemy using spatial grid
                    let nearestDist = Infinity;
                    let nearestEnemy = null;
                    const nearbyEnemies = spatialGrid.queryRadius(b.x, b.y, 600);
                    for (const e of nearbyEnemies) {
                        const dx = e.x - b.x;
                        const dy = e.y - b.y;
                        const distSq = dx * dx + dy * dy;
                        if (distSq < nearestDist * nearestDist) {
                            nearestDist = Math.sqrt(distSq);
                            nearestEnemy = e;
                        }
                    }
                    if (nearestEnemy) {
                        // Predict enemy position based on velocity
                        const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                        const timeToTarget = nearestDist / Math.max(speed, 100);
                        const predictedX = nearestEnemy.x + (nearestEnemy.vx || 0) * timeToTarget * 0.7;
                        const predictedY = nearestEnemy.y + (nearestEnemy.vy || 0) * timeToTarget * 0.7;

                        const dx = predictedX - b.x;
                        const dy = predictedY - b.y;
                        const targetAngle = Math.atan2(dy, dx);
                        const currentAngle = Math.atan2(b.vy, b.vx);
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                        // === LÃ“GICA DE MISIL CON 3 FASES (SIN REINICIAR EN NUEVOS OBJETIVOS) ===
                        
                        // Actualizar timer del impulso inicial (SOLO la primera vez)
                        if (b.boostTimer > 0) {
                            b.boostTimer -= deltaTime;
                            if (b.boostTimer <= 0) {
                                // ðŸ‘ˆ Cambiar a velocidad de navegaciÃ³n (fase 2) - SOLO UNA VEZ
                                b.currentSpeed = b.cruiseSpeed;
                                b.hasCompletedBoostPhase = true; // ðŸ‘ˆ MARCAR QUE COMPLETÃ“ FASE DE FRENADO
                            }
                        }
                        
                        // SOLO aplicar lÃ³gica de aceleraciÃ³n si estÃ¡ fuera del boost inicial
                        // Esto evita que se reinicie el frenado con nuevos objetivos
                        if (b.hasCompletedBoostPhase) {
                            const angleToTargetRad = Math.abs(angleDiff);
                            
                            // Fase 3: AceleraciÃ³n final si apunta al objetivo
                            if (angleToTargetRad < b.angleThreshold) {
                                b.targetSpeed = b.finalSpeed; // ðŸ‘ˆ VELOCIDAD FINAL
                            } else {
                                b.targetSpeed = b.cruiseSpeed; // ðŸ‘ˆ VELOCIDAD DE NAVEGACIÃ“N
                            }
                            
                            // TransiciÃ³n suave de velocidad
                            const speedTransitionRate = 5.0; // ðŸ‘ˆ VELOCIDAD DE TRANSICIÃ“N (mÃ¡s rÃ¡pido = mÃ¡s abrupto)
                            if (Math.abs(b.currentSpeed - b.targetSpeed) > 1) {
                                const speedChange = (b.targetSpeed - b.currentSpeed) * speedTransitionRate * deltaTime;
                                b.currentSpeed += speedChange;
                            }
                        }
                        
                        // Aplicar giro
                        const maxTurn = (b.turnRate * Math.PI / 180) * deltaTime;
                        const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                        const newAngle = currentAngle + turn;
                        
                        // Aplicar velocidad actual
                        b.vx = Math.cos(newAngle) * b.currentSpeed;
                        b.vy = Math.sin(newAngle) * b.currentSpeed;
                    }

                    // Store trail positions for line rendering
                    if (!b.trail) b.trail = [];
                    const isMini = b.type === 'mini_rocket';
                    const maxTrailLength = isMini ? 25 : 50;
                    b.trail.unshift({ x: b.x, y: b.y });
                    if (b.trail.length > maxTrailLength) {
                        b.trail.pop();
                    }
                }

                // Piercing laser particles (beam or laser with piercing)
                if ((b.type === 'beam' || (b.type === 'laser' && b.piercing))) {
                    const totalEntities = bullets.length + enemies.length;
                    const beamTrailChance = totalEntities > 100 ? 0.3 : 0.6;
                    if (Math.random() < beamTrailChance) {
                        const angle = Math.atan2(b.vy, b.vx);
                        const perpAngle = angle + Math.PI / 2;
                        const offset = (Math.random() - 0.5) * 8;
                        const p = pools.particle.acquire();
                        p.x = b.x + Math.cos(perpAngle) * offset;
                        p.y = b.y + Math.sin(perpAngle) * offset;
                        p.vx = (Math.random() - 0.5) * 20 - Math.cos(angle) * 30;
                        p.vy = (Math.random() - 0.5) * 20 - Math.sin(angle) * 30;
                        p.life = 0.15;
                        p.maxLife = 0.15;
                        p.size = 2 + Math.random() * 2;
                        p.color = b.color || COLORS.BULLET;
                        p.type = 'piercing_trail';
                        particles.push(p);
                    }
                }

                // Store previous position for swept collision detection
                b.prevX = b.x;
                b.prevY = b.y;

                b.x += b.vx * deltaTime;
                b.y += b.vy * deltaTime;
                b.life -= deltaTime;

                // Remove bullets that are too far from camera or expired
                // Allow bullets to travel across adjacent sectors
                const distFromCamera = Math.sqrt(
                    Math.pow(b.x - camera.x, 2) +
                    Math.pow(b.y - camera.y, 2)
                );
                const maxDistance = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 3; // 5760px

                if (b.life <= 0 || distFromCamera > maxDistance) {
                    if (b.life <= 0) explodePlayerRocket(b);
                    pools.bullet.release(b);
                    fastRemove(bullets, i);
                }
            }
        }

        // ============================================================
        // ALIEN DRONES
        // ============================================================

        // TODO: EVOLUTION - Hive Mind: orbital drones with mini-lasers
        function updateDrones() {
            const droneColor = COLORS.PLAYER;

            for (let i = drones.length - 1; i >= 0; i--) {
                const d = drones[i];

                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;

                for (const e of enemies) {
                    const dx = e.x - d.x;
                    const dy = e.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = e;
                    }
                }
                // Homing behavior towards nearest enemy
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - d.x;
                    const dy = nearestEnemy.y - d.y;
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(d.vy, d.vx);

                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    const maxTurn = (DRONE_TURN_RATE * Math.PI / 180) * deltaTime;
                    const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                    const newAngle = currentAngle + turn;

                    const droneSpeed = DRONE_SPEED * (d.speedMulti || 1);
                    d.vx = Math.cos(newAngle) * droneSpeed;
                    d.vy = Math.sin(newAngle) * droneSpeed;
                    d.angle = newAngle * 180 / Math.PI;
                }

                // Store trail for visual effect
                d.trail.unshift({ x: d.x, y: d.y });
                if (d.trail.length > 8) d.trail.pop();

                // Update position
                d.x += d.vx * deltaTime;
                d.y += d.vy * deltaTime;
                d.life -= deltaTime;

                // Check collision with enemies
                let hitEnemy = null;
                for (const e of enemies) {
                    const config = ENEMY_TYPES[e.type];
                    const dx = e.x - d.x;
                    const dy = e.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < config.radius + DRONE_SIZE) {
                        hitEnemy = e;
                        break;
                    }
                }
                if (hitEnemy) {
                    // Explosion AoE damage (probability-based)
                    if (d.explosionChance > 0 && Math.random() < d.explosionChance) {
                        spawnRing(d.x, d.y, droneColor, 30);

                        for (const e of enemies) {
                            if (e === hitEnemy) continue;
                            const edx = e.x - d.x;
                            const edy = e.y - d.y;
                            const eDist = Math.sqrt(edx * edx + edy * edy);

                            if (eDist < d.explosionRadius) {
                                const eConfig = ENEMY_TYPES[e.type];
                                e.hp -= d.explosionDamage;
                                spawnFloatingText(e.x, e.y - eConfig.radius, d.explosionDamage.toString(), droneColor);

                                if (e.hp <= 0) {
                                    const idx = enemies.indexOf(e);
                                    if (idx !== -1) killEnemy(e, idx);
                                }
                            }
                        }
                    } else {
                        spawnRing(d.x, d.y, droneColor);
                    }

                    // Remove drone after impact
                    pools.drone.release(d);
                    fastRemove(drones, i);
                    continue;
                }

                // Remove expired drones or too far from camera
                const distFromCamera = Math.sqrt(
                    Math.pow(d.x - camera.x, 2) +
                    Math.pow(d.y - camera.y, 2)
                );

                if (d.life <= 0 || distFromCamera > CULLING_DISTANCES.drones) {
                    pools.drone.release(d);
                    fastRemove(drones, i);
                }
            }
        }

        // ============================================================
        // ENEMIES
        // ============================================================
        // ============================================================

        function updateSpawnSystem() {
            // Decay spawn interval over time
            if (gameTime - lastSpawnDecayTime > SPAWN_DECAY_INTERVAL) {
                spawnInterval *= (1 - SPAWN_DECAY_RATE);
                spawnInterval = Math.max(MIN_SPAWN_INTERVAL, spawnInterval);
                lastSpawnDecayTime = gameTime;
                waveNumber++;
            }

            // Spawn enemies
            spawnTimer -= deltaTime;
            // Scale max enemies with wave number (+5 enemies per wave)
            const baseMaxEnemies = lowPerfMode ? MAX_ENEMIES_LOW_PERF : MAX_ENEMIES;
            const maxEnemies = baseMaxEnemies + (waveNumber * 5);

            if (spawnTimer <= 0 && enemies.length < maxEnemies) {
                spawnEnemy();
                const spawnRateMult = getDiffMultipliers().spawnRate;
                spawnTimer = (spawnInterval + Math.random() * (spawnInterval * 0.5)) / spawnRateMult;
            }

            // Wave system - starts aggressively from level 2
            if (playerLevel >= 2) {
                waveTimer -= deltaTime;
                if (waveTimer <= 0) {
                    // Spawn 1-3 waves simultaneously at higher levels
                    const simultaneousWaves = playerLevel >= 5 ? (Math.random() < 0.4 ? 2 : 1) : 1;
                    for (let w = 0; w < simultaneousWaves; w++) {
                        spawnWave();
                    }
                    // Faster waves as level increases (minimum 1.2 seconds between waves)
                    const levelSpeedBonus = Math.min((playerLevel - 2) * 0.25, 1.8);
                    waveTimer = Math.max(1.2, WAVE_INTERVAL_BASE - levelSpeedBonus) + Math.random() * WAVE_INTERVAL_VARIANCE;
                }
            }
        }

        function getWaveSubtitle(pattern) {
            const subtitles = {
                'arc': 'ARC FORMATION',
                'side': 'FLANK ATTACK',
                'pincer': 'PINCER INCOMING',
                'circle': 'SURROUNDED',
                'line': 'LINE ASSAULT',
                'cluster': 'CLUSTER SWARM',
                'spiral': 'SPIRAL CONVERGENCE',
                'corners': 'CORNER AMBUSH',
                'rush': 'ENEMY RUSH',
                'scatter': 'SCATTER ASSAULT',
                'v_formation': 'V-FORMATION'
            };
            return subtitles[pattern] || 'HOSTILES INCOMING';
        }

        function spawnWave() {
            if (!player) return;

            // Pick a random pattern different from the last one
            let pattern;
            do {
                pattern = WAVE_PATTERNS[Math.floor(Math.random() * WAVE_PATTERNS.length)];
            } while (pattern === lastWavePattern && WAVE_PATTERNS.length > 1);
            lastWavePattern = pattern;

            // Trigger wave alert
            waveAlertActive = true;
            waveAlertTimer = 0;
            waveAlertNumber = waveNumber;
            waveAlertSubtitle = getWaveSubtitle(pattern);

            // Scale wave size with level (more enemies at higher levels)
            const baseCount = 15 + Math.floor(playerLevel * 4);
            const count = Math.min(baseCount, 60); // Cap at 60 per wave

            // Scale enemy HP based on player level (+25% per level) and difficulty
            const config = ENEMY_TYPES['SCOUT'];
            const waveDiffMult = getDiffMultipliers();
            const hpMultiplier = (1 + (playerLevel - 1) * 0.25) * waveDiffMult.enemyHP;
            const scaledHp = Math.ceil(config.hp * hpMultiplier);

            const spawnPositions = [];

            switch (pattern) {
                case 'arc': {
                    // Arc around player (original pattern but smaller)
                    const centerAngle = Math.random() * 360;
                    const arcDegrees = 90 + Math.random() * 60; // 90-150 degree arc
                    for (let i = 0; i < count; i++) {
                        const angle = (centerAngle - arcDegrees/2 + (arcDegrees / (count - 1)) * i) * Math.PI / 180;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 100;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'side': {
                    // All from one side in a wall
                    const side = Math.floor(Math.random() * 4); // 0=left, 1=right, 2=top, 3=bottom
                    for (let i = 0; i < count; i++) {
                        let x, y;
                        const spread = (i - count/2) * 25;
                        if (side === 0) { // Left
                            x = player.x - WAVE_SPAWN_DISTANCE;
                            y = player.y + spread;
                        } else if (side === 1) { // Right
                            x = player.x + WAVE_SPAWN_DISTANCE;
                            y = player.y + spread;
                        } else if (side === 2) { // Top
                            x = player.x + spread;
                            y = player.y - WAVE_SPAWN_DISTANCE;
                        } else { // Bottom
                            x = player.x + spread;
                            y = player.y + WAVE_SPAWN_DISTANCE;
                        }
                        spawnPositions.push({ x, y });
                    }
                    break;
                }
                case 'pincer': {
                    // From two opposite sides
                    const horizontal = Math.random() > 0.5;
                    const halfCount = Math.floor(count / 2);
                    for (let i = 0; i < halfCount; i++) {
                        const spread = (i - halfCount/2) * 30;
                        if (horizontal) {
                            spawnPositions.push({ x: player.x - WAVE_SPAWN_DISTANCE, y: player.y + spread });
                            spawnPositions.push({ x: player.x + WAVE_SPAWN_DISTANCE, y: player.y + spread });
                        } else {
                            spawnPositions.push({ x: player.x + spread, y: player.y - WAVE_SPAWN_DISTANCE });
                            spawnPositions.push({ x: player.x + spread, y: player.y + WAVE_SPAWN_DISTANCE });
                        }
                    }
                    break;
                }
                case 'circle': {
                    // Hexagonal staggered pattern (3 inner, 3 outer)
                    // Replaces the unfair "full circle" trap with escape routes
                    const baseAngle = Math.random() * Math.PI * 2;
                    // Screen half-width is 960, so 1100 ensures they are off-screen
                    const innerDist = 1100; 
                    const outerDist = 1500;

                    for (let i = 0; i < count; i++) {
                        // Distribute among 6 clusters
                        const clusterIdx = i % 6;
                        
                        // Even indices (0, 2, 4) are inner (closest)
                        // Odd indices (1, 3, 5) are outer (furthest, filling gaps)
                        const isInner = clusterIdx % 2 === 0;
                        
                        // 6 points of hexagon: 0, 60, 120, 180, 240, 300 degrees
                        const angleStep = Math.PI / 3; 
                        const clusterAngle = baseAngle + (clusterIdx * angleStep);

                        // Random spread within the cluster
                        const spreadAngle = (Math.random() - 0.5) * 0.4; // ~20 degree spread
                        const finalAngle = clusterAngle + spreadAngle;

                        const baseDist = isInner ? innerDist : outerDist;
                        const distVariation = Math.random() * 150; // Depth variation
                        const dist = baseDist + distVariation;

                        spawnPositions.push({
                            x: player.x + Math.cos(finalAngle) * dist,
                            y: player.y + Math.sin(finalAngle) * dist
                        });
                    }
                    break;
                }
                case 'line': {
                    // Diagonal line sweeping towards player
                    const angle = Math.random() * 360 * Math.PI / 180;
                    const perpAngle = angle + Math.PI / 2;
                    for (let i = 0; i < count; i++) {
                        const offset = (i - count/2) * 35;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * WAVE_SPAWN_DISTANCE + Math.cos(perpAngle) * offset,
                            y: player.y + Math.sin(angle) * WAVE_SPAWN_DISTANCE + Math.sin(perpAngle) * offset
                        });
                    }
                    break;
                }
                case 'cluster': {
                    // Tight cluster from one direction
                    const angle = Math.random() * 360 * Math.PI / 180;
                    for (let i = 0; i < count; i++) {
                        const offsetAngle = angle + (Math.random() - 0.5) * 0.5;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 150;
                        spawnPositions.push({
                            x: player.x + Math.cos(offsetAngle) * dist,
                            y: player.y + Math.sin(offsetAngle) * dist
                        });
                    }
                    break;
                }
                case 'spiral': {
                    // Spiral pattern
                    const startAngle = Math.random() * 360;
                    for (let i = 0; i < count; i++) {
                        const angle = (startAngle + i * 25) * Math.PI / 180;
                        const dist = WAVE_SPAWN_DISTANCE + i * 15;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'corners': {
                    // From all 4 corners
                    const perCorner = Math.floor(count / 4);
                    const corners = [
                        { dx: -1, dy: -1 },
                        { dx: 1, dy: -1 },
                        { dx: -1, dy: 1 },
                        { dx: 1, dy: 1 }
                    ];
                    for (const corner of corners) {
                        for (let i = 0; i < perCorner; i++) {
                            const spreadX = (Math.random() - 0.5) * 200;
                            const spreadY = (Math.random() - 0.5) * 200;
                            spawnPositions.push({
                                x: player.x + corner.dx * WAVE_SPAWN_DISTANCE * 0.7 + spreadX,
                                y: player.y + corner.dy * WAVE_SPAWN_DISTANCE * 0.7 + spreadY
                            });
                        }
                    }
                    break;
                }
                case 'rush': {
                    // Dense column rushing from one direction
                    const rushAngle = Math.random() * 360 * Math.PI / 180;
                    const perpAngle = rushAngle + Math.PI / 2;
                    const rows = 4;
                    const perRow = Math.ceil(count / rows);
                    for (let row = 0; row < rows; row++) {
                        for (let i = 0; i < perRow; i++) {
                            const offset = (i - perRow/2) * 20;
                            const rowDist = row * 40;
                            spawnPositions.push({
                                x: player.x + Math.cos(rushAngle) * (WAVE_SPAWN_DISTANCE + rowDist) + Math.cos(perpAngle) * offset,
                                y: player.y + Math.sin(rushAngle) * (WAVE_SPAWN_DISTANCE + rowDist) + Math.sin(perpAngle) * offset
                            });
                        }
                    }
                    break;
                }
                case 'scatter': {
                    // Random positions all around (chaotic)
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 300 - 150;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'v_formation': {
                    // V-shape formation flying towards player
                    const vAngle = Math.random() * 360 * Math.PI / 180;
                    const halfCount = Math.floor(count / 2);
                    for (let i = 0; i < halfCount; i++) {
                        const offset = i * 30;
                        const depth = i * 25;
                        // Left wing of V
                        spawnPositions.push({
                            x: player.x + Math.cos(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.cos(vAngle + Math.PI/2) * offset,
                            y: player.y + Math.sin(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.sin(vAngle + Math.PI/2) * offset
                        });
                        // Right wing of V
                        spawnPositions.push({
                            x: player.x + Math.cos(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.cos(vAngle - Math.PI/2) * offset,
                            y: player.y + Math.sin(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.sin(vAngle - Math.PI/2) * offset
                        });
                    }
                    break;
                }
            }

            // Spawn all enemies in the wave
            for (const pos of spawnPositions) {
                const angleToPlayer = Math.atan2(player.y - pos.y, player.x - pos.x);

                const enemy = pools.enemy.acquire();
                enemy.x = pos.x;
                enemy.y = pos.y;
                enemy.vx = Math.cos(angleToPlayer) * config.speed * 0.5 * waveDiffMult.enemySpeed;
                enemy.vy = Math.sin(angleToPlayer) * config.speed * 0.5 * waveDiffMult.enemySpeed;
                enemy.angle = angleToPlayer * 180 / Math.PI;
                enemy.type = 'SCOUT';
                enemy.hp = scaledHp;
                enemy.maxHp = scaledHp;
                enemy.fireTimer = 0;
                enemy.burstCooldown = 0;
                enemy.spawnTime = gameTime;
                enemy.offScreenTime = 0;
                enemies.push(enemy);
            }
        }
        
        function spawnEnemy() {
            if (!player) return; // Safety check

            // Determine enemy type based on wave/score
            let type = 'SCOUT';
            const r = Math.random();

            if (score > 5000 && r < 0.08) {
                type = 'TANK';
            } else if (waveNumber >= 10 && r < 0.20) {
                type = 'KAMIKAZE';
            }

            // Spawn position relative to PLAYER (not canvas bounds)
            const side = Math.floor(Math.random() * 4);
            let x, y;
            const offset = ENEMY_SPAWN_OFFSET_MIN + Math.random() * ENEMY_SPAWN_OFFSET_RANGE;
            const spawnDistance = CANVAS_WIDTH / 2 + offset;

            switch (side) {
                case 0: // Left
                    x = player.x - spawnDistance;
                    y = player.y + (Math.random() - 0.5) * CANVAS_HEIGHT;
                    break;
                case 1: // Right
                    x = player.x + spawnDistance;
                    y = player.y + (Math.random() - 0.5) * CANVAS_HEIGHT;
                    break;
                case 2: // Top
                    x = player.x + (Math.random() - 0.5) * CANVAS_WIDTH;
                    y = player.y - spawnDistance;
                    break;
                case 3: // Bottom
                    x = player.x + (Math.random() - 0.5) * CANVAS_WIDTH;
                    y = player.y + spawnDistance;
                    break;
            }

            const config = ENEMY_TYPES[type];
            const angleToPlayer = Math.atan2(player.y - y, player.x - x);
            
            // Scale enemy HP based on player level (+40% per level) and difficulty
            const diffMult = getDiffMultipliers();
            const hpMultiplier = (1 + (playerLevel - 1) * 0.40) * diffMult.enemyHP;
            const scaledHp = Math.ceil(config.hp * hpMultiplier);
            const speedMult = diffMult.enemySpeed;

            const enemy = pools.enemy.acquire();
            enemy.x = x;
            enemy.y = y;
            enemy.vx = Math.cos(angleToPlayer) * config.speed * 0.5 * speedMult;
            enemy.vy = Math.sin(angleToPlayer) * config.speed * 0.5 * speedMult;
            enemy.angle = angleToPlayer * 180 / Math.PI;
            enemy.type = type;
            enemy.hp = scaledHp;
            enemy.maxHp = scaledHp;
            enemy.fireTimer = config.fireRate || 0;
            enemy.burstCooldown = 0;
            enemy.spawnTime = gameTime;
            enemy.offScreenTime = 0;
            enemies.push(enemy);
        }
        
        function updateEnemies() {
            if (!player) return; // Safety check

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const config = ENEMY_TYPES[e.type];
                const speed = config.speed * getDiffMultipliers().enemySpeed;

                // Seek player with limited turn rate
                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                const angleDiff = normalizeAngle(targetAngle - e.angle);
                
                const maxTurn = config.turnRate * deltaTime;
                if (Math.abs(angleDiff) > maxTurn) {
                    e.angle += Math.sign(angleDiff) * maxTurn;
                } else {
                    e.angle = targetAngle;
                }
                
                // Apply velocity toward facing direction
                const rad = e.angle * Math.PI / 180;
                const targetVx = Math.cos(rad) * speed;
                const targetVy = Math.sin(rad) * speed;
                
                // Smooth acceleration
                e.vx += (targetVx - e.vx) * deltaTime * 2;
                e.vy += (targetVy - e.vy) * deltaTime * 2;
                
                // Tank burst
                if (e.type === 'TANK') {
                    e.burstCooldown -= deltaTime;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    if (e.burstCooldown <= 0 && distToPlayer < 200) {
                        e.vx = Math.cos(rad) * 280;
                        e.vy = Math.sin(rad) * 280;
                        e.burstCooldown = 6;
                    }
                }
                
                // Spinner fires
                if (e.type === 'SPINNER') {
                    e.fireTimer -= deltaTime;
                    if (e.fireTimer <= 0) {
                        fireSpinnerBullets(e);
                        e.fireTimer = config.fireRate;
                    }
                }
                
                // Separation from other enemies (using spatial grid)
                const nearbyEnemies = spatialGrid.queryRadius(e.x, e.y, config.radius * 4);
                for (const other of nearbyEnemies) {
                    if (other === e) continue; // Skip self

                    const sepDx = e.x - other.x;
                    const sepDy = e.y - other.y;
                    const sepDistSq = sepDx * sepDx + sepDy * sepDy;
                    const minDist = config.radius + ENEMY_TYPES[other.type].radius + ENEMY_SEPARATION_PADDING;
                    const minDistSq = minDist * minDist;

                    if (sepDistSq < minDistSq && sepDistSq > 0) {
                        const sepDist = Math.sqrt(sepDistSq);
                        const push = (minDist - sepDist) * 0.5;
                        const pushX = (sepDx / sepDist) * push;
                        const pushY = (sepDy / sepDist) * push;
                        e.vx += pushX;
                        e.vy += pushY;
                        other.vx -= pushX;
                        other.vy -= pushY;
                    }
                }
                
                // Update position
                e.x += e.vx * deltaTime;
                e.y += e.vy * deltaTime;

                // Transport enemy if too far from player (wrap around world)
                const relX = e.x - player.x;
                const relY = e.y - player.y;

                // If enemy is beyond 1.5 sectors away, transport to opposite side
                if (relX > SECTOR_WIDTH * 1.5) {
                    e.x -= 3 * SECTOR_WIDTH;
                } else if (relX < -SECTOR_WIDTH * 1.5) {
                    e.x += 3 * SECTOR_WIDTH;
                }

                if (relY > SECTOR_HEIGHT * 1.5) {
                    e.y -= 3 * SECTOR_HEIGHT;
                } else if (relY < -SECTOR_HEIGHT * 1.5) {
                    e.y += 3 * SECTOR_HEIGHT;
                }

                // Spinner self-destruct
                if (e.type === 'SPINNER' && gameTime - e.spawnTime > 20) {
                    pools.enemy.release(e);
                    fastRemove(enemies, i);
                    spawnRing(e.x, e.y, config.color, 40);
                }
            }
        }
        
        function fireSpinnerBullets(enemy) {
            const bulletCount = 6;
            for (let i = 0; i < bulletCount; i++) {
                const angle = (360 / bulletCount) * i + enemy.angle;
                const rad = angle * Math.PI / 180;
                const bullet = pools.enemyBullet.acquire();
                bullet.x = enemy.x;
                bullet.y = enemy.y;
                bullet.vx = Math.cos(rad) * 260;
                bullet.vy = Math.sin(rad) * 260;
                bullet.life = 2;
                enemyBullets.push(bullet);
            }
        }
        
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.x += b.vx * deltaTime;
                b.y += b.vy * deltaTime;
                b.life -= deltaTime;

                // Remove enemy bullets that are too far from camera or expired
                // Allow bullets to travel across adjacent sectors
                const distFromCamera = Math.sqrt(
                    Math.pow(b.x - camera.x, 2) +
                    Math.pow(b.y - camera.y, 2)
                );
                const maxDistance = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 3; // 5760px

                if (b.life <= 0 || distFromCamera > maxDistance) {
                    pools.enemyBullet.release(b);
                    fastRemove(enemyBullets, i);
                }
            }
        }
        
        function killEnemy(enemy, index) {
            const config = ENEMY_TYPES[enemy.type];

            // Increment kill counter
            totalKills++;

            // Add score (scaled by difficulty)
            score += config.points * getDiffMultipliers().score;

            // Spawn explosion ring
            spawnRing(enemy.x, enemy.y, config.color, 40);

            // Direct XP gain
            if (!enemy.noXP) {
                const xpValue = enemy.type === 'TANK' ? 3 : (enemy.type === 'SPINNER' ? 2 : 1);
                collectXP(xpValue);
            }

            // Alien splits into 5 tanks on death
            if (enemy.type === 'ALIEN') {
                const hpMultiplier = 1 + (playerLevel - 1) * 0.40;
                const tankConfig = ENEMY_TYPES['TANK'];
                const scaledTankHp = Math.ceil(tankConfig.hp * hpMultiplier);
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 / 5) * i + Math.random() * 0.3;
                    const tank = pools.enemy.acquire();
                    tank.x = enemy.x + Math.cos(angle) * 40;
                    tank.y = enemy.y + Math.sin(angle) * 40;
                    tank.vx = Math.cos(angle) * 80;
                    tank.vy = Math.sin(angle) * 80;
                    tank.angle = angle * 180 / Math.PI;
                    tank.type = 'TANK';
                    tank.hp = scaledTankHp;
                    tank.maxHp = scaledTankHp;
                    tank.fireTimer = 0;
                    tank.burstCooldown = 0;
                    tank.spawnTime = gameTime;
                    tank.offScreenTime = 0;
                    tank.noXP = enemy.noXP || false;
                    enemies.push(tank);
                }
            }

            // Tank splits into scouts
            if (enemy.type === 'TANK') {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const scout = pools.enemy.acquire();
                    scout.x = enemy.x + Math.cos(angle) * 30;
                    scout.y = enemy.y + Math.sin(angle) * 30;
                    scout.vx = Math.cos(angle) * 60;
                    scout.vy = Math.sin(angle) * 60;
                    scout.angle = angle * 180 / Math.PI;
                    scout.type = 'SCOUT';
                    scout.hp = 1;
                    scout.maxHp = 1;
                    scout.fireTimer = 0;
                    scout.burstCooldown = 0;
                    scout.spawnTime = gameTime;
                    scout.offScreenTime = 0;
                    scout.noXP = enemy.noXP || false;
                    enemies.push(scout);
                }
            }
            
            // Maybe spawn pickup
            if (Math.random() < 0.01) {
                spawnPickup(enemy.x, enemy.y);
            }

            // Spawn alien drones if skill unlocked
            spawnAlienDrone(enemy.x, enemy.y);


            pools.enemy.release(enemy);
            fastRemove(enemies, index);
        }

        // ============================================================
        // PICKUPS
        // ============================================================
        
        function spawnPickup(x, y) {
            // Always try to spawn a pickup, but the type determines if we actually do it
            const rand = Math.random();
            let type = null;

            // 20% Health
            // 80% Nothing

            if (rand < 0.20) {
                type = 'health';
            } else {
                return; // 80% chance of no pickup
            }
            
            const pickup = pools.pickup.acquire();
            pickup.x = x;
            pickup.y = y;
            pickup.type = type;
            pickup.life = 10;
            pickup.bobTimer = Math.random() * Math.PI * 2;
            pickups.push(pickup);
        }
        
        function updatePickups() {
            if (!player) return; // Safety check

            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                p.life -= deltaTime;
                p.bobTimer += deltaTime;

                if (p.life <= 0) {
                    pools.pickup.release(p);
                    fastRemove(pickups, i);
                    continue;
                }

                // Transport pickup if too far from player (wrap around world)
                const relX = p.x - player.x;
                const relY = p.y - player.y;

                if (relX > SECTOR_WIDTH * 1.5) {
                    p.x -= 3 * SECTOR_WIDTH;
                } else if (relX < -SECTOR_WIDTH * 1.5) {
                    p.x += 3 * SECTOR_WIDTH;
                }

                if (relY > SECTOR_HEIGHT * 1.5) {
                    p.y -= 3 * SECTOR_HEIGHT;
                } else if (relY < -SECTOR_HEIGHT * 1.5) {
                    p.y += 3 * SECTOR_HEIGHT;
                }

                // Check collision with player
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Magnet effect - attract pickups within range with acceleration
                if (dist < PICKUP_MAGNET_RADIUS && dist > 0) {
                    // Lerp factor increases as pickup gets closer (faster pull when near)
                    const pullStrength = 1 - (dist / PICKUP_MAGNET_RADIUS);
                    const lerpFactor = 8 * pullStrength * pullStrength * deltaTime;
                    p.x += dx * lerpFactor;
                    p.y += dy * lerpFactor;
                }
                
                if (dist < PLAYER_COLLISION_RADIUS + 15) {
                    if (p.type === 'health') {
                        if (player.hp < playerMaxHP) {
                            player.hp++;
                            spawnFloatingText(p.x, p.y, '+1 Hull', COLORS.POWERUP);
                        } else {
                            score += 50 * getDiffMultipliers().score;
                            spawnFloatingText(p.x, p.y, '+50', COLORS.GOLD);
                        }
                    } else {
                        score += 20 * getDiffMultipliers().score;
                        spawnFloatingText(p.x, p.y, '+20', COLORS.GOLD);
                    }

                    // Pickup effect
                    for (let j = 0; j < 8; j++) {
                        const angle = (Math.PI * 2 / 8) * j;
                        particles.push({
                            x: p.x,
                            y: p.y,
                            vx: Math.cos(angle) * 80,
                            vy: Math.sin(angle) * 80,
                            life: 0.4,
                            maxLife: 0.4,
                            size: 4,
                            color: p.type === 'health' ? COLORS.POWERUP : COLORS.GOLD,
                            type: 'pickup'
                        });
                    }

                    pools.pickup.release(p);
                    fastRemove(pickups, i);
                }
            }
        }


        // ============================================================
        // XP & LEVEL SYSTEM
        // ============================================================

        function collectXP(amount) {
            playerXP += Math.round(amount * permXPMulti * getDiffMultipliers().xp);

            let levelsGained = 0;
            while (playerXP >= xpToNextLevel) {
                playerXP -= xpToNextLevel;
                playerLevel++;
                xpToNextLevel = Math.floor(XP_PER_LEVEL_BASE * Math.pow(XP_PER_LEVEL_GROWTH, playerLevel - 1));
                skillPoints++;
                levelsGained++;
            }

            // Only trigger effects and open skill tree once if leveled up
            if (levelsGained > 0) {
                levelUp(levelsGained);
            }
        }

        function levelUp(levelsGained = 1) {
            // Only show upgrade panel if there are still skills to unlock
            if (!allSkillsUnlocked()) {
                showUpgradePanel();
            }

            // Effects (more intense if multiple levels)
            const intensity = Math.min(levelsGained, 3);
            triggerFlash(COLORS.XP, 0.2 + intensity * 0.1, 200);
            triggerSlowmo(100 * intensity);

            // Show floating text for multiple levels
            if (levelsGained > 1 && player) {
                spawnFloatingText(player.x, player.y - 40, 'LEVEL UP x' + levelsGained + '!', COLORS.XP);
            }
        }
        
        // Get all available upgrade options for the level-up panel
        function getAvailableUpgrades() {
            const available = [];
            const prog = cachedProgression || loadProgression();

            for (const [weaponId, weapon] of Object.entries(WEAPONS)) {
                // Weapon must be unlocked in shop
                if (!prog.unlockedWeapons[weaponId]) continue;

                // Option: Activate the weapon (if not yet active this run)
                if (!activeWeapons.includes(weaponId)) {
                    available.push({
                        type: 'weapon_activation',
                        id: weaponId,
                        name: weapon.name,
                        description: weapon.description,
                        color: weapon.color,
                        icon: weapon.icon
                    });
                    continue; // Don't offer upgrades for inactive weapons
                }

                // Option: Level up a branch
                for (const [branchId, branch] of Object.entries(weapon.branches)) {
                    const currentLevel = upgradeLevels[branchId] || 0;
                    if (currentLevel < 3) {
                        const nextLevel = branch.levels[currentLevel];
                        available.push({
                            type: 'upgrade',
                            id: branchId,
                            weaponId: weaponId,
                            name: branch.name + ' ' + ['I', 'II', 'III'][currentLevel],
                            description: nextLevel.description,
                            color: weapon.color,
                            icon: branch.icon,
                            level: currentLevel + 1
                        });
                    }
                }

                // Option: Evolution (all 3 branches at level III)
                if (!activeEvolutions.includes(weaponId)) {
                    const branchIds = Object.keys(weapon.branches);
                    const allMaxed = branchIds.every(bid => (upgradeLevels[bid] || 0) >= 3);
                    if (allMaxed) {
                        available.push({
                            type: 'evolution',
                            id: weaponId + '_evolution',
                            weaponId: weaponId,
                            name: weapon.evolution.name,
                            description: weapon.evolution.description,
                            color: weapon.color,
                            icon: weapon.evolution.icon,
                            isEvolution: true
                        });
                    }
                }
            }

            // If no upgrades left, offer bonuses
            if (available.length === 0) {
                available.push(
                    { type: 'bonus', id: 'bonus_crystals', name: '+50 Crystals', description: 'Bonus persistent currency', color: '#E0F0FF', icon: 'crystal' },
                    { type: 'bonus', id: 'bonus_heal', name: 'Full Heal', description: 'Restore all HP', color: '#39FF14', icon: 'heal' },
                    { type: 'bonus', id: 'bonus_damage', name: 'Damage x1.5', description: 'Increased damage for 30 seconds', color: '#FF6B5B', icon: 'damage' }
                );
            }

            return available;
        }

        // Check if all upgrades have been obtained
        function allSkillsUnlocked() {
            const prog = cachedProgression || loadProgression();
            for (const [weaponId, weapon] of Object.entries(WEAPONS)) {
                if (!prog.unlockedWeapons[weaponId]) continue;
                if (!activeWeapons.includes(weaponId)) return false;
                for (const branchId of Object.keys(weapon.branches)) {
                    if ((upgradeLevels[branchId] || 0) < 3) return false;
                }
                if (!activeEvolutions.includes(weaponId)) return false;
            }
            return true;
        }

        // Generate 3 random upgrade options
        function generateUpgradeOptions() {
            const available = getAvailableUpgrades();
            if (available.length <= 3) return [...available];
            const shuffled = [...available].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 3);
        }

        // Draw a skill icon on a canvas context
        function drawSkillIcon(ctx, icon, cx, cy, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            if (icon === 'arsenal') {
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'laser') {
                ctx.beginPath();
                ctx.moveTo(cx + 10, cy);
                ctx.lineTo(cx - 6, cy - 7);
                ctx.lineTo(cx - 3, cy);
                ctx.lineTo(cx - 6, cy + 7);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'rocket') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - 10);
                ctx.lineTo(cx + 5, cy + 8);
                ctx.lineTo(cx, cy + 5);
                ctx.lineTo(cx - 5, cy + 8);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'orbital') {
                ctx.beginPath();
                ctx.arc(cx, cy, 9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'lightning') {
                ctx.beginPath();
                ctx.moveTo(cx + 2, cy - 9);
                ctx.lineTo(cx - 3, cy);
                ctx.lineTo(cx + 1, cy);
                ctx.lineTo(cx - 2, cy + 9);
                ctx.lineTo(cx + 4, cy - 2);
                ctx.lineTo(cx, cy - 2);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'rate') {
                ctx.beginPath();
                ctx.moveTo(cx - 5, cy - 5);
                ctx.lineTo(cx + 2, cy);
                ctx.lineTo(cx - 5, cy + 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + 1, cy - 5);
                ctx.lineTo(cx + 8, cy);
                ctx.lineTo(cx + 1, cy + 5);
                ctx.stroke();
            } else if (icon === 'beam') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillRect(cx - 10, cy - 1, 20, 2);
            } else if (icon === 'spread') {
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy - 7);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy + 7);
                ctx.stroke();
            } else if (icon === 'target') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'cluster') {
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    ctx.beginPath();
                    ctx.arc(cx + Math.cos(angle) * 6, cy + Math.sin(angle) * 6, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (icon === 'damage') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx + 6, cy + 2);
                ctx.lineTo(cx + 2, cy + 2);
                ctx.lineTo(cx + 2, cy + 8);
                ctx.lineTo(cx - 2, cy + 8);
                ctx.lineTo(cx - 2, cy + 2);
                ctx.lineTo(cx - 6, cy + 2);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'regen') {
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 1.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + 5, cy);
                ctx.lineTo(cx + 9, cy - 3);
                ctx.lineTo(cx + 9, cy + 3);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'shockwave') {
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 8, Math.PI * 0.2, Math.PI * 0.8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 8, Math.PI * 1.2, Math.PI * 1.8);
                ctx.stroke();
            } else if (icon === 'absorb') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillRect(cx - 4, cy - 1, 8, 2);
                ctx.fillRect(cx - 1, cy - 4, 2, 8);
            } else if (icon === 'chain') {
                ctx.beginPath();
                ctx.arc(cx - 3, cy - 1, 4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx + 3, cy + 1, 4, 0, Math.PI * 2);
                ctx.stroke();
            } else if (icon === 'discharge') {
                for (let i = 0; i < 3; i++) {
                    const ox = (i - 1) * 5;
                    ctx.beginPath();
                    ctx.moveTo(cx + ox + 1, cy - 5);
                    ctx.lineTo(cx + ox - 1, cy);
                    ctx.lineTo(cx + ox, cy);
                    ctx.lineTo(cx + ox - 1, cy + 5);
                    ctx.stroke();
                }
            } else if (icon === 'arc') {
                ctx.beginPath();
                ctx.arc(cx, cy, 8, -Math.PI * 0.6, Math.PI * 0.6);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 5, -Math.PI * 0.6, Math.PI * 0.6);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'aura') {
                // Aura rings
                ctx.beginPath();
                ctx.arc(cx, cy, 9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'expand') {
                // Expanding arrows
                ctx.beginPath();
                ctx.moveTo(cx - 8, cy);
                ctx.lineTo(cx - 4, cy);
                ctx.moveTo(cx + 4, cy);
                ctx.lineTo(cx + 8, cy);
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx, cy - 4);
                ctx.moveTo(cx, cy + 4);
                ctx.lineTo(cx, cy + 8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.stroke();
            } else if (icon === 'pulse') {
                // Pulsing rings
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'drone') {
                // Hexagon drone shape
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * 8;
                    const y = cy + Math.sin(angle) * 8;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'swarm') {
                // Two small drones
                [-5, 5].forEach(ox => {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                        const x = cx + ox + Math.cos(angle) * 5;
                        const y = cy + Math.sin(angle) * 5;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                });
            } else if (icon === 'explosion') {
                // Explosion burst
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerR = 3;
                    const outerR = 9;
                    const r = i % 2 === 0 ? outerR : innerR;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            } else if (icon === 'crystal') {
                // Diamond shape for crystal bonus
                ctx.beginPath();
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx + 6, cy);
                ctx.lineTo(cx, cy + 8);
                ctx.lineTo(cx - 6, cy);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'heal') {
                // Plus/cross for heal
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx, cy - 7);
                ctx.lineTo(cx, cy + 7);
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy);
                ctx.stroke();
            } else {
                // Fallback: simple circle
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Show the upgrade selection panel
        function showUpgradePanel() {
            upgradeOptions = generateUpgradeOptions();

            if (upgradeOptions.length === 0) return;

            upgradeSelectionActive = true;
            gameState = 'skilltree';

            // Hide joystick
            joystickActive = false;
            joystickMagnitude = 0;
            const joystickBase = document.getElementById('joystickBase');
            const joystickZone = document.getElementById('joystickZone');
            if (joystickBase) joystickBase.style.display = 'none';
            if (joystickZone) joystickZone.style.display = 'none';

            // Build cards
            const cardsContainer = document.getElementById('upgradeCards');
            cardsContainer.innerHTML = '';

            upgradeOptions.forEach((option, index) => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                const color = option.color;
                card.style.setProperty('--skill-color', color);
                card.style.setProperty('--skill-color-glow', color + '40');

                // Evolution cards get special gold border
                if (option.isEvolution) {
                    card.style.borderColor = '#FFD700';
                    card.style.setProperty('--skill-color', '#FFD700');
                    card.style.setProperty('--skill-color-glow', '#FFD70060');
                }

                const isMobile = window.matchMedia('(pointer: coarse)').matches;
                const keyHint = isMobile ? '' : `<div class="upgrade-key">${index + 1}</div>`;

                // Level badge for upgrades
                let levelBadge = '';
                if (option.type === 'upgrade' && option.level) {
                    levelBadge = `<span style="color:${color};font-size:11px;opacity:0.7;margin-left:6px;">LVL ${option.level}/3</span>`;
                } else if (option.type === 'weapon_activation') {
                    levelBadge = `<span style="color:#FFD700;font-size:11px;margin-left:6px;">NEW</span>`;
                } else if (option.isEvolution) {
                    levelBadge = `<span style="color:#FFD700;font-size:11px;margin-left:6px;">EVOLUTION</span>`;
                }

                card.innerHTML = `
                    <div class="upgrade-icon" style="background: ${color}15; border: 2px solid ${option.isEvolution ? '#FFD700' : color};">
                        <canvas class="skill-icon-canvas" width="40" height="40" data-icon="${option.icon}" data-color="${color}"></canvas>
                    </div>
                    <div class="upgrade-info">
                        <div class="upgrade-name" style="color: ${option.isEvolution ? '#FFD700' : color};">${option.name}${levelBadge}</div>
                        <div class="upgrade-desc">${option.description}</div>
                    </div>
                    ${keyHint}
                `;

                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectUpgrade(option);
                });

                cardsContainer.appendChild(card);
            });

            // Render icons on mini canvases
            const canvases = document.querySelectorAll('.skill-icon-canvas');
            canvases.forEach(c => {
                const iconCtx = c.getContext('2d');
                drawSkillIcon(iconCtx, c.dataset.icon, 20, 20, c.dataset.color);
            });

            document.getElementById('upgradePanel').classList.add('active');
        }

        // Select an upgrade option
        function selectUpgrade(option) {
            if (!upgradeSelectionActive) return;

            if (option.type === 'weapon_activation') {
                activeWeapons.push(option.id);
            } else if (option.type === 'upgrade') {
                upgradeLevels[option.id] = (upgradeLevels[option.id] || 0) + 1;
            } else if (option.type === 'evolution') {
                activeEvolutions.push(option.weaponId);
            } else if (option.type === 'bonus') {
                if (option.id === 'bonus_crystals') {
                    crystalsThisRun += 50;
                } else if (option.id === 'bonus_heal') {
                    player.hp = playerMaxHP;
                } else if (option.id === 'bonus_damage') {
                    tempDamageMultiplier = 1.5;
                    tempDamageTimer = 30;
                }
            }

            skillPoints--;
            spawnFloatingText(player.x, player.y - 40, option.name + '!', option.color || '#FFFFFF');

            // Celebration particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(angle) * (80 + Math.random() * 60),
                    vy: Math.sin(angle) * (80 + Math.random() * 60),
                    life: 0.5, maxLife: 0.5,
                    size: 4 + Math.random() * 4,
                    color: option.color || '#FFFFFF',
                    type: 'levelup'
                });
            }

            hideUpgradePanel();

            // Show again if more skill points remain
            if (skillPoints > 0 && !allSkillsUnlocked()) {
                setTimeout(() => showUpgradePanel(), 300);
            }
        }

        // Hide upgrade panel and resume game
        function hideUpgradePanel() {
            upgradeSelectionActive = false;
            document.getElementById('upgradePanel').classList.remove('active');
            gameState = 'playing';

            // Re-enable joystick zone and base
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            if (joystickZone) joystickZone.style.display = 'block';
            if (joystickBase) joystickBase.style.display = 'block';
        }
        
        // ============================================================
        // WEAPON SYSTEMS
        // ============================================================
        
        function updateWeapons() {
            // Orbital shields
            if (activeWeapons.includes('orbital_shield')) {
                updateOrbitals();
            }
            // Plasma Field
            if (activeWeapons.includes('plasma_field')) {
                updateAura();
            }
            // Lightning effects
            updateLightningEffects();
        }

        function updateLightningEffects() {
            for (let i = lightningEffects.length - 1; i >= 0; i--) {
                const effect = lightningEffects[i];
                effect.life -= deltaTime;

                if (effect.life <= 0) {
                    lightningEffects.splice(i, 1);
                }
            }
        }

        // TODO: EVOLUTION - Singularity Core: continuous gravitational field pulling enemies
        function updateOrbitals() {
            const stats = getWeaponStats();
            let orbitalCount = stats.orbCount;
            const orbitalRadius = ORBITAL_RADIUS;
            let orbitalSpeed = ORBITAL_SPEED;

            // Handle orbital count changes with equidistant positioning
            if (orbitals.length !== orbitalCount) {
                const baseAngle = orbitals.length > 0 ? orbitals[0].angle : 0;
                const angleIncrement = Math.PI * 2 / orbitalCount;
                orbitals = [];
                for (let i = 0; i < orbitalCount; i++) {
                    orbitals.push({
                        angle: baseAngle + angleIncrement * i,
                        hitCooldown: 0
                    });
                }
            }

            const orbitalSizeForCollision = ORBITAL_SIZE * stats.orbSizeMulti;

            // Update orbital positions and check collisions
            for (let i = 0; i < orbitals.length; i++) {
                const orb = orbitals[i];
                orb.angle += orbitalSpeed * deltaTime;
                if (!orb.hitEnemies) orb.hitEnemies = {};

                const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;

                const nearbyEnemies = spatialGrid.queryRadius(orbX, orbY, orbitalSizeForCollision + 30);
                for (const e of nearbyEnemies) {
                    if (orb.hitEnemies[e.id] && orb.hitEnemies[e.id] > 0) {
                        orb.hitEnemies[e.id] -= deltaTime;
                        continue;
                    }

                    const config = ENEMY_TYPES[e.type];
                    const dx = orbX - e.x;
                    const dy = orbY - e.y;
                    const distSq = dx * dx + dy * dy;
                    const collisionDist = config.radius + orbitalSizeForCollision;

                    if (distSq < collisionDist * collisionDist) {
                        e.hp -= stats.orbDamage;
                        orb.hitEnemies[e.id] = 0.15;

                        spawnFloatingText(e.x, e.y - config.radius, stats.orbDamage.toString(), WEAPONS['orbital_shield'].color);
                        spawnRing(e.x, e.y, config.color);

                        // Knockback
                        if (stats.orbKnockback > 0) {
                            const dist = Math.sqrt(distSq) || 1;
                            const kbForce = stats.orbKnockback * 80;
                            e.vx += (dx / dist) * kbForce;
                            e.vy += (dy / dist) * kbForce;
                        }

                        if (e.hp <= 0) {
                            const enemyIndex = enemies.indexOf(e);
                            if (enemyIndex !== -1) killEnemy(e, enemyIndex);
                        }
                    }
                }
            }
        }

        // TODO: EVOLUTION - Annihilation Sphere: chain mini-explosions on kills within aura
        function updateAura() {
            const stats = getWeaponStats();
            if (!stats.hasAura || !player) return;

            // Update pulse animation
            auraState.pulseAnimation += deltaTime * 3;

            // Update tick timer
            auraState.tickTimer += deltaTime;

            // Only deal damage on tick intervals
            if (auraState.tickTimer < stats.auraTickRate) return;
            auraState.tickTimer = 0;

            // Find all enemies within aura radius
            const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, stats.auraRadius);

            for (const e of nearbyEnemies) {
                const config = ENEMY_TYPES[e.type];
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const distSq = dx * dx + dy * dy;
                const effectiveRadius = stats.auraRadius + config.radius;

                if (distSq < effectiveRadius * effectiveRadius) {
                    // Apply damage
                    e.hp -= stats.auraDamage;

                    // Visual feedback
                    spawnFloatingText(e.x, e.y - config.radius, stats.auraDamage.toString(), WEAPONS['plasma_field'].color);
                    spawnRing(e.x, e.y, WEAPONS['plasma_field'].color);

                    // Check for death
                    if (e.hp <= 0) {
                        const enemyIndex = enemies.indexOf(e);
                        if (enemyIndex !== -1) killEnemy(e, enemyIndex);
                    }
                }
            }

        }

        // ============================================================
        // ROCKET EXPLOSION (unified for all rocket death scenarios)
        // ============================================================

        function explodePlayerRocket(b) {
            if (b.type !== 'rocket' && b.type !== 'mini_rocket') return;
            const explosionX = b.x;
            const explosionY = b.y;
            const explosionRadius = b.explosionRadius || 0;
            const explosionDamage = b.explosionDamage || 0;

            // Visual explosion effect
            spawnRing(explosionX, explosionY, COLORS.PLAYER, Math.max(explosionRadius * 2.5, 40));

            if (explosionRadius > 0 && explosionDamage > 0) {
                // Damage enemies in blast radius
                const enemiesInBlast = spatialGrid.queryRadius(explosionX, explosionY, explosionRadius);
                for (const blastEnemy of enemiesInBlast) {
                    const dx = blastEnemy.x - explosionX;
                    const dy = blastEnemy.y - explosionY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= explosionRadius) {
                        const falloff = 1 - (dist / explosionRadius) * 0.5;
                        const dmg = Math.ceil(explosionDamage * falloff);
                        blastEnemy.hp -= dmg;
                        const config = ENEMY_TYPES[blastEnemy.type];
                        spawnFloatingText(blastEnemy.x, blastEnemy.y - config.radius, dmg.toString(), COLORS.PLAYER);
                        spawnRing(blastEnemy.x, blastEnemy.y, COLORS.PLAYER);
                        if (blastEnemy.hp <= 0) {
                            const idx = enemies.indexOf(blastEnemy);
                            if (idx !== -1) killEnemy(blastEnemy, idx);
                        }
                    }
                }



            }

            // Ricochet: spawn mini rockets
            if (b.ricochetCount > 0 && b.type === 'rocket') {
                const ricochetTargets = spatialGrid.queryRadius(explosionX, explosionY, 400);
                let targetsFound = 0;
                for (const target of ricochetTargets) {
                    if (targetsFound >= b.ricochetCount) break;
                    if (target.hp <= 0) continue;

                    const angle = Math.atan2(target.y - explosionY, target.x - explosionX);
                    const spread = (Math.random() - 0.5) * 0.3;

                    const miniRocket = pools.bullet.acquire();
                    miniRocket.x = explosionX;
                    miniRocket.y = explosionY;
                    miniRocket.vx = Math.cos(angle + spread) * 550;
                    miniRocket.vy = Math.sin(angle + spread) * 550;
                    miniRocket.life = 1.5;
                    miniRocket.damage = Math.ceil(b.damage * 0.5);
                    miniRocket.explosionDamage = 0;
                    miniRocket.explosionRadius = 0;
                    miniRocket.ricochetCount = 0;
                    miniRocket.type = 'mini_rocket';
                    miniRocket.color = COLORS.PLAYER;
                    miniRocket.piercing = false;
                    miniRocket.turnRate = 250;
                    miniRocket.size = 0.6;
                    miniRocket.trail = [];
                    bullets.push(miniRocket);
                    targetsFound++;
                }
            }
        }

        // ============================================================
        // COLLISIONS
        // ============================================================

        // Swept collision: checks if line segment intersects circle
        // Returns true if the line from (x1,y1) to (x2,y2) passes through circle at (cx,cy) with radius r
        function lineCircleCollision(x1, y1, x2, y2, cx, cy, r) {
            // Vector from start to end of line
            const dx = x2 - x1;
            const dy = y2 - y1;

            // Vector from start to circle center
            const fx = x1 - cx;
            const fy = y1 - cy;

            // Quadratic equation coefficients: at^2 + bt + c = 0
            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;

            // If bullet didn't move (a â‰ˆ 0), just check current position
            if (a < 0.0001) {
                return c <= 0;
            }

            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) {
                return false; // No intersection
            }

            const sqrtDisc = Math.sqrt(discriminant);
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);

            // Check if intersection happens within the line segment (t between 0 and 1)
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }

        function checkCollisions() {
            if (!player) return;
            
            // Bullet vs Enemy (using spatial grid for optimization)
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                let bulletDestroyed = false;

                // Use previous position for swept collision (fallback to current if first frame)
                const prevX = b.prevX !== undefined ? b.prevX : b.x;
                const prevY = b.prevY !== undefined ? b.prevY : b.y;

                // Query enemies along the bullet's path (expand search radius to cover movement)
                const moveDistSq = (b.x - prevX) * (b.x - prevX) + (b.y - prevY) * (b.y - prevY);
                const moveDist = Math.sqrt(moveDistSq);
                const searchRadius = 100 + moveDist;
                const midX = (b.x + prevX) / 2;
                const midY = (b.y + prevY) / 2;
                const nearbyEnemies = spatialGrid.queryRadius(midX, midY, searchRadius);

                for (const e of nearbyEnemies) {
                    const config = ENEMY_TYPES[e.type];
                    const hitRadius = config.radius * 0.9; // Shrink hitbox 10%
                    const collisionDist = hitRadius + 4;

                    // Use swept collision detection (line-circle intersection)
                    if (lineCircleCollision(prevX, prevY, b.x, b.y, e.x, e.y, collisionDist)) {
                        // Check if piercing bullet already hit this enemy
                        if (b.piercing && b.hitEnemies && b.hitEnemies.has(e)) {
                            continue;
                        }

                        let damage = b.damage || 1;
                        // Crit chance (rockets)
                        let isCrit = false;
                        if (b.critChance && Math.random() < b.critChance) {
                            damage = Math.round(damage * 2);
                            isCrit = true;
                        }
                        e.hp -= damage;

                        // Show damage floating text
                        const dmgText = isCrit ? damage + '!' : damage.toString();
                        spawnFloatingText(e.x, e.y - config.radius, dmgText, isCrit ? '#FFD700' : (b.color || COLORS.BULLET));

                        // Hit effect
                        spawnRing(b.x, b.y, config.color);

                        if (e.hp <= 0) {
                            const enemyIndex = enemies.indexOf(e);
                            if (enemyIndex !== -1) {
                                killEnemy(e, enemyIndex);
                            }
                        }

                        // Handle bullet destruction/piercing
                        if (b.piercing) {
                            if (!b.hitEnemies) b.hitEnemies = new Set();
                            b.hitEnemies.add(e);
                            // Check pierce count limit
                            if (b.pierceCount && b.hitEnemies.size >= b.pierceCount) {
                                bulletDestroyed = true;
                                break;
                            }
                        } else {
                            bulletDestroyed = true;
                            break;
                        }
                    }
                }

                if (bulletDestroyed) {
                    explodePlayerRocket(b);
                    pools.bullet.release(b);
                    fastRemove(bullets, i);
                }
            }


            // Enemy vs Player (using spatial grid for nearby enemies only)
            const nearbyEnemiesForPlayer = spatialGrid.queryRadius(player.x, player.y, 100);
            for (const e of nearbyEnemiesForPlayer) {
                const config = ENEMY_TYPES[e.type];

                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const distSq = dx * dx + dy * dy;
                const collisionDist = PLAYER_COLLISION_RADIUS + config.radius * 0.9;
                const collisionDistSq = collisionDist * collisionDist;
                const nearMissDistSq = (collisionDist + NEAR_MISS_RADIUS) * (collisionDist + NEAR_MISS_RADIUS);

                // Near-miss check
                if (distSq < nearMissDistSq && distSq > collisionDistSq) {
                    if (!e.nearMissTriggered) {
                        e.nearMissTriggered = true;
                        triggerNearMiss();
                    }
                }

                // Collision
                if (distSq < collisionDistSq && player.invulnerable <= 0) {
                    damagePlayer();

                    // Kamikaze dies on contact
                    if (e.type === 'KAMIKAZE') {
                        spawnRing(e.x, e.y, config.color, 50);
                        const idx = enemies.indexOf(e);
                        if (idx !== -1) {
                            pools.enemy.release(e);
                            fastRemove(enemies, idx);
                        }
                    }
                }
            }
            
            // Enemy bullet vs Player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];

                const dx = player.x - b.x;
                const dy = player.y - b.y;
                const distSq = dx * dx + dy * dy;
                const collisionDistSq = PLAYER_COLLISION_RADIUS * PLAYER_COLLISION_RADIUS;
                const nearMissDistSq = (PLAYER_COLLISION_RADIUS + NEAR_MISS_RADIUS) * (PLAYER_COLLISION_RADIUS + NEAR_MISS_RADIUS);

                // Near-miss
                if (distSq < nearMissDistSq && distSq > collisionDistSq) {
                    if (!b.nearMissTriggered) {
                        b.nearMissTriggered = true;
                        triggerNearMiss();
                    }
                }

                if (distSq < collisionDistSq && player.invulnerable <= 0) {
                    damagePlayer();
                    pools.enemyBullet.release(b);
                    fastRemove(enemyBullets, i);
                }
            }


        }

        function damagePlayer() {
            // Reset shield regen timer
            player.shieldRegenTimer = 0;

            // Small hit cooldown (no visual effect, just prevents frame-stacking)
            player.invulnerable = 0.05;

            // Shield absorbs damage
            player.shield = Math.max(0, player.shield - SHIELD_DAMAGE_ABSORPTION);
            player.shieldFlashTimer = 0.15;

            // Visual effects for shield hit
            triggerShake(SHAKE_INTENSITY_HIT * 0.5, SHAKE_DURATION_HIT * 0.6);
            triggerFlash(COLORS.SHIELD, 0.2, 100);

            // Shield depleted - consume hull and restore shield
            if (player.shield <= 0) {
                player.hp--;
                player.shield = PLAYER_MAX_SHIELD;

                triggerShake(SHAKE_INTENSITY_HIT, SHAKE_DURATION_HIT);
                triggerFlash('#FF6B6B', 0.4, 200);

                if (player.hp <= 0) {
                    player.shield = 0; // Stay at 0 for death
                    gameOver();
                }
            }
        }
        
        function triggerNearMiss() {
            score += NEAR_MISS_POINTS * getDiffMultipliers().score;

            spawnFloatingText(player.x + (Math.random() - 0.5) * 30, player.y - 30, '+' + NEAR_MISS_POINTS, COLORS.PLAYER);
            triggerSlowmo(SLOWMO_DURATION);
            triggerFlash(COLORS.PLAYER, 0.22, 180);
            
            // Burst particles
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                particles.push({
                    x: player.x + Math.cos(angle) * PLAYER_COLLISION_RADIUS,
                    y: player.y + Math.sin(angle) * PLAYER_COLLISION_RADIUS,
                    vx: Math.cos(angle) * 100,
                    vy: Math.sin(angle) * 100,
                    life: 0.3,
                    maxLife: 0.3,
                    size: 3,
                    color: COLORS.PLAYER,
                    type: 'nearmiss'
                });
            }
        }
        
        function gameOver() {
            // Save high score
            try {
                const savedHighScore = parseInt(localStorage.getItem('StellarSwarm_highscore_v1') || '0');
                if (score > savedHighScore) {
                    localStorage.setItem('StellarSwarm_highscore_v1', Math.floor(score).toString());
                }
            } catch (e) {
                console.warn('Could not save high score to localStorage:', e);
            }

            // Crystal breakdown
            const killBonus = Math.floor(totalKills / 50);
            const scoreBonus = Math.floor(score / 1000);
            const baseCrystals = crystalsThisRun + killBonus + scoreBonus;
            const totalCrystals = Math.round(baseCrystals * permCrystalMulti * getDiffMultipliers().crystals);
            lastRunCrystals = {
                picked: crystalsThisRun,
                killBonus: killBonus,
                scoreBonus: scoreBonus,
                crystalMulti: permCrystalMulti,
                total: totalCrystals
            };

            // Save crystals, stats, and difficulty high scores to progression
            let newDifficultyUnlocked = false;
            try {
                const prog = loadProgression();
                prog.crystals = (prog.crystals || 0) + totalCrystals;
                prog.stats.totalKills = (prog.stats.totalKills || 0) + totalKills;
                prog.stats.totalCrystalsEarned = (prog.stats.totalCrystalsEarned || 0) + totalCrystals;

                // Update per-difficulty high score
                const diffKey = ['normal', 'hard', 'extreme', 'nightmare'][currentDifficulty] || 'normal';
                if (!prog.highScores) prog.highScores = { normal: 0, hard: 0, extreme: 0, nightmare: 0 };
                if (Math.floor(score) > (prog.highScores[diffKey] || 0)) {
                    prog.highScores[diffKey] = Math.floor(score);
                }

                // Check if new difficulty unlocked
                const maxScore = Math.max(prog.highScores.normal || 0, prog.highScores.hard || 0, prog.highScores.extreme || 0, prog.highScores.nightmare || 0);
                for (let d = 1; d < DIFFICULTY_THRESHOLDS.length; d++) {
                    if (maxScore >= DIFFICULTY_THRESHOLDS[d]) {
                        const wasUnlocked = getUnlockedDifficulties(cachedProgression || createDefaultProgression()).includes(d);
                        if (!wasUnlocked) newDifficultyUnlocked = true;
                    }
                }

                saveProgression(prog);
            } catch (e) {
                console.warn('Could not save crystals:', e);
            }

            // Store for game over display
            lastRunCrystals.newDifficultyUnlocked = newDifficultyUnlocked;

            // Death explosion
            spawnDeathExplosion();
            
            triggerShake(10, SHAKE_DURATION_DEATH);
            triggerFlash('#FFFFFF', 0.6, 120);
            triggerSlowmo(240);
            
            setTimeout(() => {
                gameState = 'gameOver';
            }, 800);
        }
        
        function spawnDeathExplosion() {
            // Shards
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i + Math.random() * 0.5;
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (100 + Math.random() * 80) + player.vx * 0.3,
                    vy: Math.sin(angle) * (100 + Math.random() * 80) + player.vy * 0.3,
                    life: 0.9,
                    maxLife: 0.9,
                    size: 12,
                    color: COLORS.PLAYER,
                    type: 'shard',
                    angle: angle * 180 / Math.PI,
                    rotSpeed: (Math.random() - 0.5) * 400
                });
            }
            
            // Small particles
            for (let i = 0; i < 18; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (50 + Math.random() * 150),
                    vy: Math.sin(angle) * (50 + Math.random() * 150),
                    life: 0.6 + Math.random() * 0.3,
                    maxLife: 0.8,
                    size: 3 + Math.random() * 4,
                    color: Math.random() > 0.5 ? COLORS.PLAYER : COLORS.THRUSTER,
                    type: 'debris'
                });
            }
        }

        // ============================================================
        // PARTICLES & EFFECTS
        // ============================================================
        
        // Single ring effect - replaces all particle explosions for performance
        function spawnRing(x, y, color, maxSize = 15) {
            const ring = pools.particle.acquire();
            ring.x = x;
            ring.y = y;
            ring.vx = 0;
            ring.vy = 0;
            ring.type = 'ring';
            ring.color = color;
            ring.size = maxSize * 0.25;
            ring.maxSize = maxSize;
            ring.life = 0.2;
            ring.maxLife = 0.2;
            particles.push(ring);
        }

        function spawnFloatingText(x, y, text, color) {
            const ft = pools.floatingText.acquire();
            ft.x = x;
            ft.y = y;
            ft.text = text;
            ft.color = color;
            ft.life = 0.7;
            ft.maxLife = 0.7;
            floatingTexts.push(ft);
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.life -= deltaTime;
                
                if (p.type === 'shard' && p.rotSpeed) {
                    p.angle += p.rotSpeed * deltaTime;
                }
                if (p.type === 'thruster' && p.rotationSpeed) {
                    p.rotation += p.rotationSpeed * deltaTime;
                }
                
                // Drag on particles (thruster uses exponential slowdown based on life)
                if (p.type === 'thruster') {
                    const lifeRatio = p.life / p.maxLife;
                    const drag = Math.pow(0.92, 1 + (1 - lifeRatio) * 4);
                    p.vx *= drag;
                    p.vy *= drag;
                } else {
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                }
                
                if (p.life <= 0) {
                    pools.particle.release(p);
                    fastRemove(particles, i);
                }
            }
        }
        
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const t = floatingTexts[i];
                t.y -= 40 * deltaTime;
                t.life -= deltaTime;
                
                if (t.life <= 0) {
                    pools.floatingText.release(t);
                    fastRemove(floatingTexts, i);
                }
            }
        }

        function updateEffects() {
            // Shake
            if (shakeDuration > 0) {
                shakeTimer += deltaTime * 1000;
                if (shakeTimer >= shakeDuration) {
                    shakeDuration = 0;
                    shakeIntensity = 0;
                }
            }
            
            // Flash
            if (flashDuration > 0) {
                flashDuration -= deltaTime * 1000;
                if (flashDuration <= 0) {
                    flashColor = null;
                    flashOpacity = 0;
                }
            }
            
            // Milestone
            if (milestoneActive) {
                milestoneTimer -= deltaTime * 1000;
                if (milestoneTimer <= 0) {
                    milestoneActive = false;
                }
            }
        }
        
        function triggerShake(intensity, duration) {
            shakeIntensity = intensity;
            shakeDuration = duration;
            shakeTimer = 0;
        }
        
        function triggerFlash(color, opacity, duration) {
            flashColor = color;
            flashOpacity = opacity;
            flashDuration = duration;
        }
        
        function triggerSlowmo(duration) {
            slowmoTimer = duration;
            slowmoDuration = duration;
        }
        
        function checkMilestones() {
            const milestone = Math.floor(score / MILESTONE_INTERVAL) * MILESTONE_INTERVAL;
            if (milestone > lastMilestone && milestone > 0) {
                lastMilestone = milestone;
                milestoneActive = true;
                milestoneTimer = 1200;

                // Gold particles
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: Math.random() * CANVAS_WIDTH,
                        y: -20,
                        vx: (Math.random() - 0.5) * 100,
                        vy: 100 + Math.random() * 100,
                        life: 1.5,
                        maxLife: 1.5,
                        size: 4 + Math.random() * 4,
                        color: COLORS.GOLD,
                        type: 'confetti'
                    });
                }
            }
        }


        // ============================================================
        // RENDERING
        // ============================================================

        function render() {
            // Apply shake
            ctx.save();
            if (shakeDuration > 0) {
                const progress = shakeTimer / shakeDuration;
                const currentIntensity = shakeIntensity * (1 - progress);
                ctx.translate(
                    (Math.random() - 0.5) * currentIntensity * 2,
                    (Math.random() - 0.5) * currentIntensity * 2
                );
            }

            // Background (rendered without camera offset)
            renderBackground();

            // *** APPLY CAMERA TRANSFORM FOR ALL GAME ENTITIES ***
            ctx.save();
            const cameraOffset = worldToScreen(0, 0);
            ctx.translate(cameraOffset.x, cameraOffset.y);

            // Game entities (all rendered in world coordinates)
            if (gameState === 'playing' || gameState === 'paused' || gameState === 'gameOver') {
                renderPickups();
                renderEnemies();
                renderBullets();
                renderDrones();
                renderEnemyBullets();
                if (player && gameState !== 'gameOver') {
                    renderAura();
                    renderPlayer();
                    renderShieldArc();
                    renderOrbitals();
                    renderLightning();
                }
                renderParticles();
                renderFloatingTexts();
            }


            ctx.restore(); // Restore camera transform

            ctx.restore(); // Restore shake transform

            // Flash overlay (screen space)
            if (flashColor && flashOpacity > 0) {
                ctx.fillStyle = flashColor;
                ctx.globalAlpha = flashOpacity * (flashDuration / 180);
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.globalAlpha = 1;
            }

            // UI
            renderUI();

            // Debug overlay (toggle with B key)
            if (showDebugOverlay) {
                perfMonitor.renderDebug();
            }
        }

        function renderBackground() {
            // 1. Base gradient (cached in initBackgroundCache)
            ctx.fillStyle = cachedBgGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Skip fancy effects in low performance mode
            if (lowPerfMode) return;

            // 3. Fade-in for grid effects (0 â†’ 1 over 3 seconds)
            const gridFadeIn = Math.min(1, gameTime / 5);
            if (gridFadeIn < 0.01) return;

            // 4. Parallax grid (2 layers)
            // Helper to handle negative modulo correctly
            const mod = (n, m) => ((n % m) + m) % m;

            // Far layer: sparse grid, slow parallax (distant feel)
            const farSpacing = 120;
            const farSpeed = 0.15;
            const farOpacity = 0.025;
            const farLineWidth = 1;
            const farOffsetX = mod(camera.x * farSpeed, farSpacing);
            const farOffsetY = mod(camera.y * farSpeed, farSpacing);
            ctx.strokeStyle = `rgba(127, 219, 255, ${farOpacity * gridFadeIn})`;
            ctx.lineWidth = farLineWidth;
            ctx.beginPath();
            for (let x = -farOffsetX; x <= CANVAS_WIDTH + farSpacing; x += farSpacing) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
            }
            for (let y = -farOffsetY; y <= CANVAS_HEIGHT + farSpacing; y += farSpacing) {
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
            }
            ctx.stroke();

            // Near layer: larger grid, faster parallax (closer feel)
            const nearSpacing = 400;
            const nearSpeed = 0.4;
            const nearOpacity = 0.04;
            const nearLineWidth = 1.5;
            const nearOffsetX = mod(camera.x * nearSpeed, nearSpacing);
            const nearOffsetY = mod(camera.y * nearSpeed, nearSpacing);
            ctx.strokeStyle = `rgba(127, 219, 255, ${nearOpacity * gridFadeIn})`;
            ctx.lineWidth = nearLineWidth;
            ctx.beginPath();
            for (let x = -nearOffsetX; x <= CANVAS_WIDTH + nearSpacing; x += nearSpacing) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
            }
            for (let y = -nearOffsetY; y <= CANVAS_HEIGHT + nearSpacing; y += nearSpacing) {
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
            }
            ctx.stroke();

            // 5. CRT Scanlines (cached pattern)
            ctx.globalAlpha = 0.3 * gridFadeIn;
            ctx.fillStyle = cachedScanlinePattern;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.globalAlpha = 1;

            // 6. Vignette (cached gradient)
            ctx.globalAlpha = gridFadeIn;
            ctx.fillStyle = cachedVignetteGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.globalAlpha = 1;
        }

        // ============================================================
        // SHIELD ARC (around player in world space)
        // ============================================================

        function renderShieldArc() {
            if (!player || player.shield <= 0) return;

            const shieldPercent = player.shield / PLAYER_MAX_SHIELD;
            const isLow = shieldPercent <= SHIELD_ARC_LOW_THRESHOLD && shieldPercent > 0;
            const isRegenerating = player.shieldRegenTimer >= SHIELD_REGEN_DELAY &&
                                   player.shield < PLAYER_MAX_SHIELD;

            const startAngle = -Math.PI / 2; // Start from top
            const endAngle = startAngle + (Math.PI * 2 * shieldPercent);

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.globalAlpha = player.shieldArcOpacity;

            // Determine arc color based on state
            let arcColor = COLORS.HUD_SHIELD;
            let glowIntensity = 0;

            if (player.shieldArcFlashColor) {
                // Flash white on hit
                arcColor = player.shieldArcFlashColor;
                glowIntensity = 20;
            } else if (isLow) {
                // Warning orange with pulse
                const pulse = Math.sin(player.shieldArcPulsePhase * 2) * 0.3 + 0.7;
                ctx.globalAlpha = player.shieldArcOpacity * pulse;
                arcColor = COLORS.HUD_WARNING;
                glowIntensity = 12;
            } else if (isRegenerating) {
                // Regen blue with subtle pulse
                const pulse = Math.sin(player.shieldArcPulsePhase) * 0.2 + 0.8;
                ctx.globalAlpha = player.shieldArcOpacity * pulse;
                arcColor = COLORS.HUD_SHIELD_REGEN;
                glowIntensity = 8;
            }

            // Draw track (faint background circle)
            ctx.strokeStyle = 'rgba(68, 200, 255, 0.06)';
            ctx.lineWidth = SHIELD_ARC_TRACK_STROKE;
            ctx.beginPath();
            ctx.arc(0, 0, SHIELD_ARC_RADIUS, 0, Math.PI * 2);
            ctx.stroke();

            // Draw tick marks around the arc (every 45Â°)
            ctx.strokeStyle = 'rgba(68, 200, 255, 0.12)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i;
                const innerR = SHIELD_ARC_RADIUS - 6;
                const outerR = SHIELD_ARC_RADIUS - 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR);
                ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                ctx.stroke();
            }

            // Draw fill arc (actual shield)
            if (ENABLE_GLOW_EFFECTS && glowIntensity > 0) {
                ctx.shadowColor = arcColor;
                ctx.shadowBlur = glowIntensity;
            }
            ctx.strokeStyle = arcColor;
            ctx.lineWidth = SHIELD_ARC_STROKE;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 0, SHIELD_ARC_RADIUS, startAngle, endAngle);
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            ctx.restore();
        }


        function renderPlayer() {
            const p = player;
            ctx.save();
            ctx.translate(p.x, p.y + p.bobOffset);
            ctx.rotate(p.angle * Math.PI / 180);
            ctx.translate(-PLAYER_PIVOT_OFFSET, 0);  // Aplica el offset del pivote

            
            // Thruster flame
            if (p.thrusterScale > 0) {
                ctx.fillStyle = COLORS.PLAYER;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                const flameLength = 15 + p.thrusterScale * 20;
                ctx.moveTo(-12, -6);
                ctx.lineTo(-12 - flameLength, 0);
                ctx.lineTo(-12, 6);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Ship body (triangle) - outline only style
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 3;
            ctx.shadowColor = COLORS.PLAYER;
            ctx.shadowBlur = 20;
            
            ctx.beginPath();
            ctx.moveTo(22, 0);
            ctx.lineTo(-12, -16);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-12, 16);
            ctx.closePath();
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function renderAura() {
            if (!activeWeapons.includes('plasma_field') || !player) return;

            const stats = getWeaponStats();
            const auraColor = WEAPONS['plasma_field'].color;
            const pulseOffset = Math.sin(auraState.pulseAnimation) * 5;
            const currentRadius = stats.auraRadius + pulseOffset;

            ctx.save();

            // Outer glow ring
            ctx.strokeStyle = auraColor;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            ctx.shadowColor = auraColor;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 15 : 0;
            ctx.beginPath();
            ctx.arc(player.x, player.y, currentRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Semi-transparent fill
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = auraColor;
            ctx.fill();

            // Inner ring
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 1.5;
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(player.x, player.y, currentRadius * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        function renderOrbitals() {
            if (!activeWeapons.includes('orbital_shield') || !player) return;

            const stats = getWeaponStats();
            const orbitalRadius = ORBITAL_RADIUS;
            let orbitalSize = ORBITAL_SIZE * stats.orbSizeMulti;

            // Outline style for orbitals (no glow for performance)
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 2.5;

            for (const orb of orbitals) {
                const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbitalSize, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function renderLightning() {
            if (lightningEffects.length === 0) return;

            for (const effect of lightningEffects) {
                if (effect.points.length < 2) continue;

                const alpha = effect.life / effect.maxLife;

                // Render 3 layers: outer glow, mid glow, core
                for (let layer = 2; layer >= 0; layer--) {
                    ctx.beginPath();
                    ctx.moveTo(effect.points[0].x, effect.points[0].y);

                    // Draw through all pre-computed zigzag points
                    for (let i = 1; i < effect.points.length; i++) {
                        ctx.lineTo(effect.points[i].x, effect.points[i].y);
                    }

                    // Layer styling (narrow lightning)
                    if (layer === 0) {
                        // Core: bright white
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.lineWidth = 1.5;
                    } else if (layer === 1) {
                        // Mid: purple
                        ctx.strokeStyle = `rgba(159, 122, 234, ${alpha * 0.8})`;
                        ctx.lineWidth = 3;
                    } else {
                        // Outer: blue glow
                        ctx.strokeStyle = `rgba(99, 179, 237, ${alpha * 0.5})`;
                        ctx.lineWidth = 6;
                    }

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                }
            }
        }

        function renderBullets() {
            // Sort bullets by type for batched rendering
            const byType = { laser: [], beam: [], rocket: [], spread: [], mini_rocket: [] };

            for (const b of bullets) {
                if (shouldRenderEntity(b, CULLING_DISTANCES.bullets)) {
                    const type = b.type || 'laser';
                    if (byType[type]) byType[type].push(b);
                    else byType.laser.push(b);
                }
            }

            // Batch render lasers
            if (byType.laser.length > 0) {
                ctx.strokeStyle = COLORS.BULLET;
                ctx.shadowColor = COLORS.BULLET;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

                for (const b of byType.laser) {
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.lineWidth = 5;
                    const len = 24;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render beams
            if (byType.beam.length > 0) {
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

                for (const b of byType.beam) {
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.strokeStyle = b.color || COLORS.BULLET;
                    ctx.shadowColor = b.color || COLORS.BULLET;
                    ctx.lineWidth = 5;

                    const len = 24;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render spread shots
            if (byType.spread.length > 0) {
                ctx.strokeStyle = COLORS.GOLD;
                ctx.shadowColor = COLORS.GOLD;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;
                ctx.lineWidth = 2;

                for (const b of byType.spread) {
                    const angle = Math.atan2(b.vy, b.vx);
                    const len = 10;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render rockets with trail
            if (byType.rocket.length > 0) {
                ctx.shadowColor = COLORS.PLAYER;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 10 : 0;

                for (const b of byType.rocket) {
                    // Draw trail as fading line
                    if (b.trail && b.trail.length > 1) {
                        for (let t = 0; t < b.trail.length - 1; t++) {
                            const alpha = 1 - (t / b.trail.length);
                            const width = 2 * (1 - t / b.trail.length);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                            ctx.lineWidth = width;
                            ctx.beginPath();
                            ctx.moveTo(b.trail[t].x, b.trail[t].y);
                            ctx.lineTo(b.trail[t + 1].x, b.trail[t + 1].y);
                            ctx.stroke();
                        }
                    }

                    // Draw rocket
                    ctx.strokeStyle = COLORS.PLAYER;
                    ctx.lineWidth = 2;
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(-6, -5);
                    ctx.lineTo(-4, 0);
                    ctx.lineTo(-6, 5);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Batch render mini rockets with trail (same player color)
            if (byType.mini_rocket.length > 0) {
                ctx.shadowColor = COLORS.PLAYER;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;

                for (const b of byType.mini_rocket) {
                    // Draw trail as fading line
                    if (b.trail && b.trail.length > 1) {
                        for (let t = 0; t < b.trail.length - 1; t++) {
                            const alpha = 1 - (t / b.trail.length);
                            const width = 1.5 * (1 - t / b.trail.length);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                            ctx.lineWidth = width;
                            ctx.beginPath();
                            ctx.moveTo(b.trail[t].x, b.trail[t].y);
                            ctx.lineTo(b.trail[t + 1].x, b.trail[t + 1].y);
                            ctx.stroke();
                        }
                    }

                    // Draw mini rocket
                    ctx.strokeStyle = COLORS.PLAYER;
                    ctx.lineWidth = 1.5;
                    const angle = Math.atan2(b.vy, b.vx);
                    const scale = b.size || 0.6;
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.scale(scale, scale);
                    ctx.beginPath();
                    ctx.moveTo(8, 0);
                    ctx.lineTo(-5, -4);
                    ctx.lineTo(-3, 0);
                    ctx.lineTo(-5, 4);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
        }
        
        function renderEnemyBullets() {
            ctx.strokeStyle = COLORS.ENEMY_BULLET;
            ctx.lineWidth = 2;
            ctx.shadowColor = COLORS.ENEMY_BULLET;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

            for (const b of enemyBullets) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(b, CULLING_DISTANCES.enemyBullets)) continue;

                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function renderDrones() {
            if (drones.length === 0) return;

            const droneColor = COLORS.PLAYER;

            for (const d of drones) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(d, CULLING_DISTANCES.drones)) continue;

                // Draw trail
                if (d.trail.length > 1) {
                    ctx.strokeStyle = droneColor;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.moveTo(d.trail[0].x, d.trail[0].y);
                    for (let i = 1; i < d.trail.length; i++) {
                        ctx.globalAlpha = 0.4 * (1 - i / d.trail.length);
                        ctx.lineTo(d.trail[i].x, d.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Draw drone body
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.angle * Math.PI / 180);

                // Drone shape (small hexagon)
                ctx.strokeStyle = droneColor;
                ctx.fillStyle = droneColor;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * DRONE_SIZE;
                    const y = Math.sin(angle) * DRONE_SIZE;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.stroke();

                // Inner glow dot
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function renderEnemies() {
            // Sort enemies by type for batched rendering
            const byType = { SCOUT: [], KAMIKAZE: [], SPINNER: [], TANK: [], ALIEN: [] };

            for (const e of enemies) {
                if (shouldRenderEntity(e, CULLING_DISTANCES.enemies)) {
                    byType[e.type].push(e);
                }
            }

            // Batch render scouts (no shadowBlur for performance)
            if (byType.SCOUT.length > 0) {
                const config = ENEMY_TYPES['SCOUT'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;

                for (const e of byType.SCOUT) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.4;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.restore();
                }
            }

            // Batch render kamikazes (no shadowBlur for performance)
            if (byType.KAMIKAZE.length > 0) {
                const config = ENEMY_TYPES['KAMIKAZE'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;

                for (const e of byType.KAMIKAZE) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.moveTo(config.radius, 0);
                    ctx.lineTo(-config.radius, -config.radius * 0.7);
                    ctx.lineTo(-config.radius * 0.5, 0);
                    ctx.lineTo(-config.radius, config.radius * 0.7);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                }
            }

            // Batch render spinners (no shadowBlur for performance)
            if (byType.SPINNER.length > 0) {
                const config = ENEMY_TYPES['SPINNER'];
                ctx.strokeStyle = config.color;

                for (const e of byType.SPINNER) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * config.radius;
                        const y = Math.sin(angle) * config.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    ctx.lineWidth = 2;
                    const rimAngle = gameTime * 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius - 5, rimAngle, rimAngle + Math.PI * 0.5);
                    ctx.stroke();

                    ctx.restore();
                }
            }

            // Batch render tanks (special case - has HP bar)
            // Batch render tanks (no shadowBlur for performance)
            if (byType.TANK.length > 0) {
                const config = ENEMY_TYPES['TANK'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;

                for (const e of byType.TANK) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.4;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.restore();
                }
            }

            // Batch render aliens (large green enemies)
            if (byType.ALIEN.length > 0) {
                const config = ENEMY_TYPES['ALIEN'];

                for (const e of byType.ALIEN) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    // Outer circle
                    ctx.strokeStyle = config.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner hexagon
                    ctx.strokeStyle = config.outline;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i + gameTime * 2;
                        const x = Math.cos(angle) * config.radius * 0.6;
                        const y = Math.sin(angle) * config.radius * 0.6;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Pulsing core
                    ctx.fillStyle = config.color;
                    ctx.globalAlpha = 0.3 + Math.sin(gameTime * 5) * 0.15;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
        }

        function renderPickups() {
            for (const p of pickups) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(p, CULLING_DISTANCES.pickups)) continue;

                const bob = Math.sin(p.bobTimer * 4) * 3;
                const pulse = 1 + Math.sin(p.bobTimer * 6) * 0.1;
                
                ctx.save();
                ctx.translate(p.x, p.y + bob);
                ctx.scale(pulse, pulse);
                
                // Outline style
                if (p.type === 'health') {
                    ctx.strokeStyle = COLORS.POWERUP;
                    ctx.shadowColor = COLORS.POWERUP;
                } else {
                    ctx.strokeStyle = COLORS.GOLD;
                    ctx.shadowColor = COLORS.GOLD;
                }
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

                // Fade when about to expire
                if (p.life < 2) {
                    ctx.globalAlpha = p.life / 2;
                }

                if (p.type === 'health') {
                    // Diamond shape - outline only
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 0);
                    ctx.closePath();
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        function renderParticles() {
            for (const p of particles) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(p, CULLING_DISTANCES.particles)) continue;

                const alpha = p.life / p.maxLife;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;
                ctx.lineWidth = 2;

                if (p.type === 'shockwave') {
                    // Expanding ring effect
                    const progress = 1 - (p.life / p.maxLife);
                    const currentSize = p.size + (p.maxSize - p.size) * progress;
                    ctx.lineWidth = 3 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.type === 'shard') {
                    // Line spark style
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle * Math.PI / 180);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(p.size * 1.5, 0);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.type === 'thruster') {
                    // Triangle flame particle (filled)
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation || 0);
                    ctx.fillStyle = p.color;
                    const s = p.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -s * 0.6);
                    ctx.lineTo(s * 0.5, s * 0.4);
                    ctx.lineTo(-s * 0.5, s * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (p.type === 'ring') {
                    // Expanding ring for drone explosions (efficient)
                    const progress = 1 - (p.life / p.maxLife);
                    const radius = p.size + (p.maxSize - p.size) * progress;
                    ctx.lineWidth = 3 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Small line spark
                    const angle = Math.atan2(p.vy || 0, p.vx || 0);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + Math.cos(angle) * p.size * 2, p.y + Math.sin(angle) * p.size * 2);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function renderFloatingTexts() {
            ctx.textAlign = 'center';
            ctx.font = 'bold 16px "Segoe UI", sans-serif';

            for (const t of floatingTexts) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(t, CULLING_DISTANCES.floatingTexts)) continue;

                const alpha = t.life / t.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = t.color;
                ctx.shadowColor = t.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 4 : 0;
                ctx.fillText(t.text, t.x, t.y);
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function drawWeaponIconAt(cx, cy, icon, color, size) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.save();
            ctx.translate(cx, cy);
            const s = size;
            switch (icon) {
                case 'laser':
                    ctx.beginPath();
                    ctx.moveTo(-s, 0);
                    ctx.lineTo(s, 0);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'rocket':
                    ctx.beginPath();
                    ctx.moveTo(0, -s);
                    ctx.lineTo(-s * 0.7, s * 0.7);
                    ctx.lineTo(s * 0.7, s * 0.7);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'orbital':
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(s * 0.6, 0, s * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(-s * 0.6, 0, s * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'lightning':
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.3, -s);
                    ctx.lineTo(-s * 0.2, -s * 0.1);
                    ctx.lineTo(s * 0.3, s * 0.1);
                    ctx.lineTo(-s * 0.3, s);
                    ctx.stroke();
                    break;
                case 'aura':
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'drone':
                    ctx.beginPath();
                    ctx.moveTo(0, -s * 0.8);
                    ctx.lineTo(s * 0.6, 0);
                    ctx.lineTo(0, s * 0.8);
                    ctx.lineTo(-s * 0.6, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
            ctx.restore();
        }


        function renderUI() {
            if (gameState === 'menu') {
                renderMenu();
            } else if (gameState === 'playing' || gameState === 'paused' || gameState === 'skilltree') {
                renderHUD();
                if (gameState === 'paused') {
                    renderPauseOverlay();
                }
                // skilltree rendering is handled by HTML panel
            } else if (gameState === 'gameOver') {
                renderHUD();
                renderGameOver();
            } else if (gameState === 'tutorial') {
                renderTutorial();
            } else if (gameState === 'shop') {
                renderShop();
            }
        }
        
        function renderMenu() {
            // Darken background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            
            // Title
            ctx.font = 'bold 64px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.PLAYER;
            ctx.shadowColor = COLORS.PLAYER;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 20 : 0;
            ctx.fillText('STELLAR SWARM', CANVAS_WIDTH / 2, 140);
            ctx.shadowBlur = 0;
            
            // Tagline
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Drift. Survive. Swarm the stars.', CANVAS_WIDTH / 2, 175);
            
            // High score
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.GOLD;
            ctx.fillText('HIGH SCORE: ' + highScore, CANVAS_WIDTH / 2, 220);
            
            // Start prompt
            ctx.font = 'bold 24px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            ctx.globalAlpha = pulse;
            ctx.fillText('Press ENTER or TAP to Start', CANVAS_WIDTH / 2, 280);
            ctx.globalAlpha = 1;

            // Difficulty selector
            const prog = loadProgression();
            const unlocked = getUnlockedDifficulties(prog);
            ctx.font = '14px "Segoe UI", sans-serif';
            const diffTotalW = unlocked.length * 100 + (unlocked.length - 1) * 10;
            const diffStartX = (CANVAS_WIDTH - diffTotalW) / 2;
            for (let i = 0; i < unlocked.length; i++) {
                const d = unlocked[i];
                const dx = diffStartX + i * 110;
                const isSelected = d === currentDifficulty;
                // Button background
                ctx.fillStyle = isSelected ? DIFFICULTY_COLORS[d] : 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                ctx.roundRect(dx, 300, 100, 28, 4);
                ctx.fill();
                if (isSelected) {
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                // Text
                ctx.textAlign = 'center';
                ctx.fillStyle = isSelected ? '#000' : DIFFICULTY_COLORS[d];
                ctx.font = 'bold 12px "Segoe UI", sans-serif';
                ctx.fillText(DIFFICULTY_NAMES[d], dx + 50, 318);
            }

            // Difficulty switch hint
            ctx.font = '12px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.globalAlpha = 0.6;
            ctx.textAlign = 'center';
            ctx.fillText('[D] Change difficulty', CANVAS_WIDTH / 2, 345);
            ctx.globalAlpha = 1;

            // Shop hint + crystal balance
            let menuBtns = [];
            if (isMobile()) {
                const shopBtnW = 340;
                const shopBtnH = 55;
                const shopBtnX = (CANVAS_WIDTH - shopBtnW) / 2;
                const shopBtnY = 348;
                ctx.fillStyle = 'rgba(224, 240, 255, 0.12)';
                ctx.strokeStyle = 'rgba(224, 240, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(shopBtnX, shopBtnY, shopBtnW, shopBtnH, 8);
                ctx.fill();
                ctx.stroke();
                ctx.font = 'bold 26px "Segoe UI", sans-serif';
                ctx.fillStyle = '#E0F0FF';
                ctx.fillText('SHOP  \u25C6 ' + (prog.crystals || 0), CANVAS_WIDTH / 2, shopBtnY + 37);
                menuBtns.push({ type: 'shop', x: shopBtnX, y: shopBtnY, w: shopBtnW, h: shopBtnH });
            } else {
                ctx.font = '18px "Segoe UI", sans-serif';
                ctx.fillStyle = '#E0F0FF';
                ctx.globalAlpha = 0.8;
                ctx.fillText('[S] SHOP  \u25C6 ' + (prog.crystals || 0), CANVAS_WIDTH / 2, 375);
                ctx.globalAlpha = 1;
            }
            currentMenuButtons = menuBtns;

            // Controls
            renderControlsHelp(410);

            // Arsenal gallery
            renderArsenalGallery();
        }

        function renderArsenalGallery() {
            const mobile = isMobile();

            const ARSENAL_WEAPONS = [
                { id: 'laser_cannon', name: 'LASER CANNON', icon: 'laser', color: '#FF6B5B' },
                { id: 'orbital_shield', name: 'ORBITAL SHIELD', icon: 'orbital', color: '#00DFFF' },
                { id: 'missile_launcher', name: 'MISSILE LAUNCHER', icon: 'rocket', color: '#FFD93D' },
                { id: 'lightning_ray', name: 'LIGHTNING RAY', icon: 'lightning', color: '#9F7AEA' },
                { id: 'plasma_field', name: 'PLASMA FIELD', icon: 'aura', color: '#7FDBFF' },
                { id: 'alien_drone', name: 'ALIEN DRONE', icon: 'drone', color: '#39FF14' }
            ];

            const cols = mobile ? 2 : 3;
            const rows = mobile ? 3 : 2;
            const cardW = mobile ? 140 : 200;
            const cardH = mobile ? 100 : 120;
            const gap = mobile ? 12 : 16;

            const gridW = cols * cardW + (cols - 1) * gap;
            const gridX = (CANVAS_WIDTH - gridW) / 2;
            const titleY = mobile ? 680 : 560;
            const gridStartY = titleY + 30;

            // Title
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = 'bold 18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_CYAN;
            ctx.fillText('ARSENAL', CANVAS_WIDTH / 2, titleY);

            // Underline
            const lineW = 60;
            ctx.strokeStyle = 'rgba(127, 219, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(CANVAS_WIDTH / 2 - lineW, titleY + 8);
            ctx.lineTo(CANVAS_WIDTH / 2 + lineW, titleY + 8);
            ctx.stroke();

            const now = Date.now();

            for (let i = 0; i < ARSENAL_WEAPONS.length; i++) {
                const weapon = ARSENAL_WEAPONS[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cx = gridX + col * (cardW + gap);
                const cy = gridStartY + row * (cardH + gap);
                // Card background
                ctx.fillStyle = 'rgba(10, 20, 40, 0.7)';
                ctx.beginPath();
                ctx.roundRect(cx, cy, cardW, cardH, 6);
                ctx.fill();

                // Card border
                const pulse = Math.sin(now / 800 + i * 1.2) * 0.25 + 0.75;
                ctx.strokeStyle = weapon.color;
                ctx.globalAlpha = pulse;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(cx, cy, cardW, cardH, 6);
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Icon area
                const iconX = cx + cardW / 2;
                const iconY = cy + (mobile ? 30 : 36);

                // Draw weapon icon scaled up
                ctx.save();
                ctx.translate(iconX, iconY);
                ctx.scale(1.8, 1.8);
                drawSkillIcon(ctx, weapon.icon, 0, 0, weapon.color);
                ctx.restore();

                // Weapon name
                ctx.textAlign = 'center';
                const nameY = cy + (mobile ? 62 : 76);
                ctx.font = `bold ${mobile ? 9 : 11}px "Segoe UI", sans-serif`;
                ctx.fillStyle = weapon.color;
                ctx.fillText(weapon.name, cx + cardW / 2, nameY);
            }

            ctx.restore();
        }

        function renderControlsHelp(startY) {
            ctx.textAlign = 'left';
            ctx.font = '14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            
            const controls = [
                ['W / â†‘', 'Thrust'],
                ['S / â†“', 'Reverse'],
                ['A / â†', 'Rotate Left'],
                ['D / â†’', 'Rotate Right'],
                ['P / ESC', 'Pause']
            ];
            
            const colWidth = 180;
            const startX = CANVAS_WIDTH / 2 - colWidth;
            
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.font = 'bold 16px "Segoe UI", sans-serif';
            ctx.fillText('CONTROLS', startX, startY);
            
            ctx.font = '14px "Segoe UI", sans-serif';
            for (let i = 0; i < controls.length; i++) {
                const y = startY + 25 + i * 22;
                ctx.fillStyle = COLORS.PLAYER;
                ctx.fillText(controls[i][0], startX, y);
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText(controls[i][1], startX + 80, y);
            }
            
            // Touch controls note
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.font = 'italic 12px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Touch: Use joystick to move', CANVAS_WIDTH / 2, startY + 180);
        }
        
        function renderHUD() {
            if (!player) return;

            const HUD_PADDING = 16;

            // Difficulty badge (top-center, only if not Normal)
            if (currentDifficulty > 0) {
                ctx.textAlign = 'center';
                ctx.font = 'bold 11px "Segoe UI", sans-serif';
                ctx.fillStyle = DIFFICULTY_COLORS[currentDifficulty];
                ctx.fillText(DIFFICULTY_NAMES[currentDifficulty], CANVAS_WIDTH / 2, 18);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // KILLS & SCORE (top-left)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ctx.textAlign = 'left';

            // "KILLS" label
            ctx.font = '10px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText('KILLS', HUD_PADDING, 25);

            // Kills value (big)
            ctx.font = 'bold 28px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_PRIMARY;
            if (ENABLE_GLOW_EFFECTS) {
                ctx.shadowColor = COLORS.HUD_CYAN_GLOW;
                ctx.shadowBlur = 20;
            }
            ctx.fillText(totalKills.toLocaleString(), HUD_PADDING, 52);
            ctx.shadowBlur = 0;

            // "SCORE" label
            ctx.font = '9px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText('SCORE', HUD_PADDING, 68);

            // Score value (smaller)
            ctx.font = '14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText(Math.floor(score).toLocaleString(), HUD_PADDING, 82);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LEVEL & XP PANEL (top-center)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const levelPanelWidth = 260;
            const levelPanelX = (CANVAS_WIDTH - levelPanelWidth) / 2;

            // "LEVEL" label + hexagon badge
            ctx.textAlign = 'center';
            ctx.font = '10px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText('LEVEL', CANVAS_WIDTH / 2 - 30, 25);

            // Hexagon badge
            const hexX = CANVAS_WIDTH / 2 + 10;
            const hexY = 30;
            const hexSize = 18;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 2;
                const px = hexX + Math.cos(angle) * hexSize;
                const py = hexY + Math.sin(angle) * hexSize;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 255, 170, 0.04)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 255, 170, 0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Level number inside hexagon
            ctx.font = 'bold 14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_GREEN;
            if (ENABLE_GLOW_EFFECTS) {
                ctx.shadowColor = 'rgba(0, 255, 170, 0.5)';
                ctx.shadowBlur = 10;
            }
            ctx.fillText(playerLevel.toString(), hexX, hexY + 5);
            ctx.shadowBlur = 0;

            // XP bar
            const xpBarX = levelPanelX;
            const xpBarY = 52;
            const xpBarWidth = levelPanelWidth;
            const xpBarHeight = 6;
            const xpProgress = playerXP / xpToNextLevel;

            // Bar track
            ctx.fillStyle = 'rgba(255, 255, 255, 0.04)';
            ctx.strokeStyle = 'rgba(0, 255, 170, 0.12)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(xpBarX, xpBarY, xpBarWidth, xpBarHeight, 1);
            ctx.fill();
            ctx.stroke();

            // Bar fill
            if (xpProgress > 0) {
                const fillGrad = ctx.createLinearGradient(xpBarX, 0, xpBarX + xpBarWidth * xpProgress, 0);
                fillGrad.addColorStop(0, COLORS.HUD_GREEN_DIM);
                fillGrad.addColorStop(1, COLORS.HUD_GREEN);
                ctx.fillStyle = fillGrad;
                ctx.beginPath();
                ctx.roundRect(xpBarX, xpBarY, xpBarWidth * xpProgress, xpBarHeight, 1);
                ctx.fill();

                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = 'rgba(0, 255, 170, 0.4)';
                    ctx.shadowBlur = 12;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Tick marks
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 10; i++) {
                const tickX = xpBarX + (xpBarWidth / 10) * i;
                ctx.beginPath();
                ctx.moveTo(tickX, xpBarY);
                ctx.lineTo(tickX, xpBarY + xpBarHeight);
                ctx.stroke();
            }

            // XP text
            ctx.textAlign = 'right';
            ctx.font = '9px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText(playerXP + ' / ' + xpToNextLevel + ' XP', xpBarX + xpBarWidth, xpBarY + xpBarHeight + 12);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // VITALS PANEL (top-right)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const vitalsX = CANVAS_WIDTH - HUD_PADDING;

            // HULL - mini ships (filled)
            ctx.textAlign = 'right';
            const shipScale = 0.4;
            const shipSpacing = 26;
            const hullStartX = vitalsX - (playerMaxHP * shipSpacing) + 10;

            for (let i = 0; i < playerMaxHP; i++) {
                const shipX = hullStartX + i * shipSpacing;
                const shipY = 28;
                const isActive = i < player.hp;

                ctx.save();
                ctx.translate(shipX, shipY);
                ctx.scale(shipScale, shipScale);
                ctx.rotate(-Math.PI / 2); // Ships pointing up

                ctx.beginPath();
                ctx.moveTo(22, 0);
                ctx.lineTo(-12, -16);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-12, 16);
                ctx.closePath();

                if (isActive) {
                    ctx.fillStyle = COLORS.PLAYER;
                    ctx.fill();
                    if (ENABLE_GLOW_EFFECTS) {
                        ctx.shadowColor = COLORS.HUD_CYAN_GLOW;
                        ctx.shadowBlur = 8;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                } else {
                    ctx.fillStyle = COLORS.HUD_CYAN_DIM;
                    ctx.globalAlpha = 0.3;
                    ctx.fill();
                }
                ctx.restore();
            }

            // SHIELD section
            const shieldPercent = player.shield / PLAYER_MAX_SHIELD;
            const isRegenerating = player.shieldRegenTimer >= SHIELD_REGEN_DELAY && player.shield < PLAYER_MAX_SHIELD;

            // Shield bar
            const shieldBarWidth = 160;
            const shieldBarHeight = 10;
            const shieldBarX = vitalsX - shieldBarWidth;
            const shieldBarY = 50;

            // Shield icon (left of bar)
            const shieldIconX = shieldBarX - 18;
            const shieldIconY = shieldBarY + shieldBarHeight / 2;
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(shieldIconX, shieldIconY - 2, 8, -Math.PI * 0.8, Math.PI * 0.8);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(shieldIconX - 6, shieldIconY + 5);
            ctx.lineTo(shieldIconX, shieldIconY + 10);
            ctx.lineTo(shieldIconX + 6, shieldIconY + 5);
            ctx.stroke();

            // Bar background (using player color)
            ctx.fillStyle = 'rgba(127, 219, 255, 0.04)';
            ctx.strokeStyle = 'rgba(127, 219, 255, 0.18)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(shieldBarX, shieldBarY, shieldBarWidth, shieldBarHeight, 2);
            ctx.fill();
            ctx.stroke();

            // Bar fill
            if (shieldPercent > 0) {
                let barColor = COLORS.PLAYER;
                let barGlowColor = COLORS.HUD_CYAN_GLOW;

                if (player.shieldFlashTimer > 0) {
                    barColor = '#FFFFFF';
                    barGlowColor = 'rgba(255, 255, 255, 0.5)';
                } else if (isRegenerating) {
                    const pulse = Math.sin(Date.now() / 80) * 0.2 + 0.8;
                    ctx.globalAlpha = pulse;
                    barColor = COLORS.HUD_SHIELD_REGEN;
                }

                const fillGrad = ctx.createLinearGradient(shieldBarX, 0, shieldBarX + shieldBarWidth * shieldPercent, 0);
                fillGrad.addColorStop(0, COLORS.HUD_CYAN_DIM);
                fillGrad.addColorStop(1, barColor);
                ctx.fillStyle = fillGrad;
                ctx.beginPath();
                ctx.roundRect(shieldBarX, shieldBarY, shieldBarWidth * shieldPercent, shieldBarHeight, 2);
                ctx.fill();

                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = barGlowColor;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                ctx.globalAlpha = 1;
            }

            // Regen icon (spinning arc)
            if (isRegenerating) {
                const regenIconX = shieldBarX - 32;
                const regenIconY = shieldBarY + shieldBarHeight / 2;
                const rotation = Date.now() / 200;

                ctx.save();
                ctx.translate(regenIconX, regenIconY);
                ctx.rotate(rotation);
                ctx.strokeStyle = COLORS.HUD_SHIELD_REGEN;
                ctx.lineWidth = 1.2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 1.5);
                ctx.stroke();
                // Arrow
                ctx.fillStyle = COLORS.HUD_SHIELD_REGEN;
                ctx.beginPath();
                ctx.moveTo(-2, -3.5);
                ctx.lineTo(-2, -6.5);
                ctx.lineTo(1, -5);
                ctx.fill();
                ctx.restore();
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // WAVE ALERT (below level panel, conditional)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (waveAlertActive && waveAlertTimer < WAVE_ALERT_DURATION) {
                const alertProgress = waveAlertTimer / WAVE_ALERT_DURATION;
                const fadeIn = Math.min(1, alertProgress * 4);
                const fadeOut = alertProgress > 0.7 ? 1 - ((alertProgress - 0.7) / 0.3) : 1;
                const alpha = fadeIn * fadeOut;

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.textAlign = 'center';

                // "WAVE X" text
                ctx.font = 'bold 16px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.HUD_RED;
                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
                    ctx.shadowBlur = 20;
                }
                ctx.fillText('WAVE ' + waveAlertNumber, CANVAS_WIDTH / 2, 100);
                ctx.shadowBlur = 0;

                // Subtitle
                if (waveAlertSubtitle) {
                    ctx.font = '9px "Segoe UI", sans-serif';
                    ctx.fillStyle = 'rgba(255, 107, 107, 0.5)';
                    ctx.fillText(waveAlertSubtitle.toUpperCase(), CANVAS_WIDTH / 2, 115);
                }

                ctx.restore();
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ACTIVE WEAPONS (top-right, below shield)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const allWeapons = [
                { id: 'laser_cannon', color: '#FF6B5B', icon: 'laser' },
                { id: 'missile_launcher', color: '#FFD93D', icon: 'rocket' },
                { id: 'orbital_shield', color: '#00DFFF', icon: 'orbital' },
                { id: 'lightning_ray', color: '#9F7AEA', icon: 'lightning' },
                { id: 'plasma_field', color: '#7FDBFF', icon: 'aura' },
                { id: 'alien_drone', color: '#39FF14', icon: 'drone' }
            ];

            // Only show active (unlocked) weapons
            const hudWeapons = allWeapons.filter(w => activeWeapons.includes(w.id));
            const weaponIconSize = 12;
            const weaponSpacing = 32;
            const weaponsStartX = vitalsX - (hudWeapons.length * weaponSpacing) + weaponSpacing / 2;
            const weaponsY = 85;

            for (let i = 0; i < hudWeapons.length; i++) {
                const weapon = hudWeapons[i];
                const iconX = weaponsStartX + i * weaponSpacing;
                const iconY = weaponsY;

                // Weapon icon circle
                ctx.beginPath();
                ctx.arc(iconX, iconY, weaponIconSize, 0, Math.PI * 2);
                ctx.strokeStyle = weapon.color;
                ctx.lineWidth = 1.5;
                ctx.stroke();

                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = weapon.color;
                    ctx.shadowBlur = 6;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Draw weapon icon inside circle
                ctx.fillStyle = weapon.color;
                ctx.strokeStyle = weapon.color;
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';

                ctx.save();
                ctx.translate(iconX, iconY);
                const s = weaponIconSize * 0.5;

                switch (weapon.icon) {
                    case 'laser':
                        // Horizontal beam
                        ctx.beginPath();
                        ctx.moveTo(-s, 0);
                        ctx.lineTo(s, 0);
                        ctx.stroke();
                        break;
                    case 'rocket':
                        // Triangle pointing up
                        ctx.beginPath();
                        ctx.moveTo(0, -s);
                        ctx.lineTo(-s * 0.6, s * 0.6);
                        ctx.lineTo(s * 0.6, s * 0.6);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'orbital':
                        // Small orbit with dot
                        ctx.beginPath();
                        ctx.arc(0, 0, s * 0.5, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(s * 0.5, 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'lightning':
                        // Lightning bolt
                        ctx.beginPath();
                        ctx.moveTo(s * 0.2, -s);
                        ctx.lineTo(-s * 0.2, 0);
                        ctx.lineTo(s * 0.2, 0);
                        ctx.lineTo(-s * 0.2, s);
                        ctx.stroke();
                        break;
                    case 'aura':
                        // Concentric arcs
                        ctx.beginPath();
                        ctx.arc(0, 0, s * 0.3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 0, s * 0.7, Math.PI * 0.2, Math.PI * 0.8);
                        ctx.stroke();
                        break;
                    case 'drone':
                        // Diamond
                        ctx.beginPath();
                        ctx.moveTo(0, -s * 0.7);
                        ctx.lineTo(s * 0.5, 0);
                        ctx.lineTo(0, s * 0.7);
                        ctx.lineTo(-s * 0.5, 0);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();

                // Upgrade dots below icon (3 branches x 3 levels = 9 dots, grouped)
                const weaponDef = WEAPONS[weapon.id];
                if (weaponDef) {
                    const branchIds = Object.keys(weaponDef.branches);
                    const totalDots = branchIds.length * 3;
                    const dotSpacing = 5;
                    const dotY = iconY + weaponIconSize + 7;
                    const dotsStartX = iconX - ((totalDots - 1) * dotSpacing) / 2;
                    let dotIdx = 0;

                    for (const branchId of branchIds) {
                        const lvl = upgradeLevels[branchId] || 0;
                        for (let lv = 0; lv < 3; lv++) {
                            const dotX = dotsStartX + dotIdx * dotSpacing;
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
                            if (lv < lvl) {
                                ctx.fillStyle = weapon.color;
                            } else {
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                            }
                            ctx.fill();
                            dotIdx++;
                        }
                    }
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SKILL POINTS INDICATOR
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (skillPoints > 0) {
                ctx.textAlign = 'center';
                ctx.fillStyle = COLORS.HUD_GOLD;
                ctx.font = 'bold 14px "Segoe UI", sans-serif';
                ctx.fillText('SKILL POINTS: ' + skillPoints + ' (Press TAB)', CANVAS_WIDTH / 2, CANVAS_HEIGHT - 55);
            }

            // Crystal counter (top-right area)
            if (crystalsThisRun > 0) {
                ctx.fillStyle = '#E0F0FF';
                ctx.font = 'bold 14px "Segoe UI", sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText('\u25C6 ' + crystalsThisRun, CANVAS_WIDTH - 15, 60);
            }

        }
        // ============================================================
        // TUTORIAL SCREEN
        // ============================================================
        function renderTutorial() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.textAlign = 'center';

            const mobile = isMobile();

            // Title
            ctx.font = mobile ? 'bold 50px "Segoe UI", sans-serif' : 'bold 42px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('CHOOSE YOUR SECOND WEAPON', CANVAS_WIDTH / 2, mobile ? 180 : 200);

            ctx.font = mobile ? '24px "Segoe UI", sans-serif' : '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('You already have the Laser Cannon. Pick a free companion weapon.', CANVAS_WIDTH / 2, mobile ? 230 : 240);

            // Two weapon cards
            const weapons = [
                { id: 'orbital_shield', key: '1' },
                { id: 'missile_launcher', key: '2' }
            ];

            const cardW = mobile ? 450 : 300;
            const cardH = mobile ? 400 : 320;
            const gap = mobile ? 50 : 60;
            const totalW = weapons.length * cardW + (weapons.length - 1) * gap;
            const startX = (CANVAS_WIDTH - totalW) / 2;
            const cardY = mobile ? 270 : 290;

            let tutButtons = [];

            for (let i = 0; i < weapons.length; i++) {
                const w = WEAPONS[weapons[i].id];
                const x = startX + i * (cardW + gap);
                const cx = x + cardW / 2;

                // Card background
                ctx.fillStyle = 'rgba(20, 25, 40, 0.9)';
                ctx.strokeStyle = w.color;
                ctx.lineWidth = mobile ? 3 : 2;
                ctx.beginPath();
                ctx.roundRect(x, cardY, cardW, cardH, 12);
                ctx.fill();
                ctx.stroke();

                // Store full card as clickable region
                tutButtons.push({ id: weapons[i].id, x: x, y: cardY, w: cardW, h: cardH });

                if (mobile) {
                    // TAP badge
                    ctx.fillStyle = w.color;
                    ctx.font = 'bold 30px "Segoe UI", sans-serif';
                    ctx.fillText('TAP', cx, cardY + 50);
                } else {
                    // Key badge
                    ctx.fillStyle = w.color;
                    ctx.font = 'bold 28px "Segoe UI", sans-serif';
                    ctx.fillText('[' + weapons[i].key + ']', cx, cardY + 45);
                }

                // Weapon name
                ctx.font = mobile ? 'bold 30px "Segoe UI", sans-serif' : 'bold 22px "Segoe UI", sans-serif';
                ctx.fillStyle = w.color;
                ctx.fillText(w.name, cx, cardY + (mobile ? 100 : 85));

                // Description
                ctx.font = mobile ? '22px "Segoe UI", sans-serif' : '16px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText(w.description, cx, cardY + (mobile ? 140 : 115));

                // Branch preview
                ctx.font = mobile ? '20px "Segoe UI", sans-serif' : '14px "Segoe UI", sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                let by = cardY + (mobile ? 185 : 155);
                const branchGap = mobile ? 30 : 22;
                for (const [, branch] of Object.entries(w.branches)) {
                    ctx.fillText('\u2022 ' + branch.name, cx, by);
                    by += branchGap;
                }

                // FREE tag
                ctx.font = mobile ? 'bold 24px "Segoe UI", sans-serif' : 'bold 16px "Segoe UI", sans-serif';
                ctx.fillStyle = '#39FF14';
                ctx.fillText('FREE', cx, cardY + cardH - (mobile ? 25 : 20));
            }

            currentTutorialButtons = tutButtons;

            // Instruction
            ctx.font = mobile ? '24px "Segoe UI", sans-serif' : '16px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText(mobile ? 'Tap a card to choose' : 'Press 1 or 2 to choose', CANVAS_WIDTH / 2, cardY + cardH + (mobile ? 50 : 40));
        }

        // ============================================================
        // SHOP SCREEN
        // ============================================================
        let shopScroll = 0;
        let shopHover = -1; // Index of hovered item for click handling

        function renderShop() {
            ctx.fillStyle = 'rgba(5, 8, 18, 0.95)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.textAlign = 'center';

            const prog = loadProgression();
            const mobile = isMobile();

            // Header
            ctx.font = mobile ? 'bold 52px "Segoe UI", sans-serif' : 'bold 42px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('SHOP', CANVAS_WIDTH / 2, mobile ? 55 : 60);

            // Crystal balance
            ctx.font = mobile ? 'bold 30px "Segoe UI", sans-serif' : 'bold 22px "Segoe UI", sans-serif';
            ctx.fillStyle = '#E0F0FF';
            ctx.fillText('\u25C6 ' + (prog.crystals || 0), CANVAS_WIDTH / 2, mobile ? 90 : 95);

            // === WEAPONS SECTION ===
            ctx.font = mobile ? 'bold 28px "Segoe UI", sans-serif' : 'bold 20px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_CYAN;
            ctx.textAlign = 'left';
            ctx.fillText('WEAPONS', mobile ? 60 : 80, mobile ? 130 : 140);

            const weaponIds = WEAPON_IDS;
            let shopButtons = [];

            if (mobile) {
                // Mobile: 2 columns, bigger cards
                const wCardW = 580;
                const wCardH = 130;
                const wGap = 24;
                const wCols = 2;
                const wTotalW = wCols * wCardW + (wCols - 1) * wGap;
                const wStartX = (CANVAS_WIDTH - wTotalW) / 2;
                const wStartY = 150;

                for (let i = 0; i < weaponIds.length; i++) {
                    const wid = weaponIds[i];
                    const w = WEAPONS[wid];
                    const col = i % wCols;
                    const row = Math.floor(i / wCols);
                    const x = wStartX + col * (wCardW + wGap);
                    const y = wStartY + row * (wCardH + wGap);
                    const isUnlocked = !!prog.unlockedWeapons[wid];
                    const canBuy = !isUnlocked && canBuyWeapon(wid, prog);
                    const reqText = !isUnlocked ? getWeaponRequirementText(wid, prog) : null;

                    // Card background
                    ctx.fillStyle = isUnlocked ? 'rgba(20, 40, 30, 0.8)' : 'rgba(20, 25, 40, 0.8)';
                    ctx.strokeStyle = isUnlocked ? 'rgba(57, 255, 20, 0.4)' : (canBuy ? w.color : 'rgba(255,255,255,0.15)');
                    ctx.lineWidth = isUnlocked ? 2 : 1;
                    ctx.beginPath();
                    ctx.roundRect(x, y, wCardW, wCardH, 10);
                    ctx.fill();
                    ctx.stroke();

                    // Weapon name
                    ctx.textAlign = 'left';
                    ctx.font = 'bold 24px "Segoe UI", sans-serif';
                    ctx.fillStyle = isUnlocked ? '#39FF14' : (canBuy ? w.color : 'rgba(255,255,255,0.4)');
                    ctx.fillText(w.name, x + 20, y + 35);

                    // Description
                    ctx.font = '18px "Segoe UI", sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillText(w.description, x + 20, y + 62);

                    if (isUnlocked) {
                        ctx.font = 'bold 22px "Segoe UI", sans-serif';
                        ctx.fillStyle = '#39FF14';
                        ctx.fillText('OWNED', x + 20, y + 100);
                    } else if (canBuy) {
                        ctx.font = 'bold 20px "Segoe UI", sans-serif';
                        ctx.fillStyle = '#E0F0FF';
                        ctx.fillText('\u25C6 ' + w.shopPrice, x + 20, y + 100);

                        // Buy button - large tap target
                        const btnW = 140;
                        const btnH = 44;
                        const btnX = x + wCardW - btnW - 15;
                        const btnY = y + wCardH - btnH - 12;
                        ctx.fillStyle = w.color;
                        ctx.beginPath();
                        ctx.roundRect(btnX, btnY, btnW, btnH, 6);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 20px "Segoe UI", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('BUY', btnX + btnW / 2, btnY + 30);
                        ctx.textAlign = 'left';

                        shopButtons.push({ type: 'weapon', id: wid, x: btnX, y: btnY, w: btnW, h: btnH });
                    } else if (reqText) {
                        ctx.font = '18px "Segoe UI", sans-serif';
                        ctx.fillStyle = 'rgba(255,100,100,0.6)';
                        ctx.fillText(reqText, x + 20, y + 100);
                    } else {
                        ctx.font = 'bold 20px "Segoe UI", sans-serif';
                        ctx.fillStyle = 'rgba(224, 240, 255, 0.4)';
                        ctx.fillText('\u25C6 ' + w.shopPrice, x + 20, y + 100);
                    }
                }

                // === PERMANENT UPGRADES SECTION (mobile) ===
                const puStartY = wStartY + 3 * (wCardH + wGap) + 10;
                ctx.font = 'bold 28px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.HUD_CYAN;
                ctx.textAlign = 'left';
                ctx.fillText('UPGRADES', 60, puStartY);

                const puKeys = Object.keys(PERMANENT_UPGRADES);
                const puCols = 3;
                const puCardGap = 20;
                const puCardW = (CANVAS_WIDTH - 120 - (puCols - 1) * puCardGap) / puCols;
                const puCardH = 155;
                const puY = puStartY + 16;

                for (let i = 0; i < puKeys.length; i++) {
                    const key = puKeys[i];
                    const def = PERMANENT_UPGRADES[key];
                    const level = (prog.permanentUpgrades && prog.permanentUpgrades[key]) || 0;
                    const cost = getUpgradeCost(key, level);
                    const canAfford = (prog.crystals || 0) >= cost && level < def.maxLevel;
                    const isMaxed = level >= def.maxLevel;

                    const col = i < puCols ? i : (i - puCols);
                    const row = i < puCols ? 0 : 1;
                    // Center the second row if it has fewer items
                    let rowStartX = 60;
                    if (row === 1) {
                        const itemsInRow = puKeys.length - puCols;
                        const rowW = itemsInRow * puCardW + (itemsInRow - 1) * puCardGap;
                        rowStartX = (CANVAS_WIDTH - rowW) / 2;
                    }
                    const x = rowStartX + col * (puCardW + puCardGap);
                    const y = puY + row * (puCardH + puCardGap);

                    // Card
                    ctx.fillStyle = 'rgba(20, 25, 40, 0.8)';
                    ctx.strokeStyle = isMaxed ? 'rgba(57, 255, 20, 0.4)' : (canAfford ? def.color : 'rgba(255,255,255,0.15)');
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(x, y, puCardW, puCardH, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.textAlign = 'center';
                    const cx = x + puCardW / 2;
                    ctx.font = 'bold 20px "Segoe UI", sans-serif';
                    ctx.fillStyle = def.color;
                    ctx.fillText(def.name, cx, y + 28);

                    // Progress bar
                    const barW = puCardW - 40;
                    const barX = x + 20;
                    const barY = y + 45;
                    const segW = (barW - 9) / 10;
                    for (let s = 0; s < 10; s++) {
                        const sx = barX + s * (segW + 1);
                        ctx.fillStyle = s < level ? def.color : 'rgba(255,255,255,0.1)';
                        ctx.fillRect(sx, barY, segW, 14);
                    }

                    ctx.font = 'bold 16px "Segoe UI", sans-serif';
                    ctx.fillStyle = COLORS.UI_SECONDARY;
                    ctx.fillText(level + '/' + def.maxLevel, cx, barY + 34);

                    if (isMaxed) {
                        ctx.font = 'bold 20px "Segoe UI", sans-serif';
                        ctx.fillStyle = '#39FF14';
                        ctx.fillText('MAX', cx, y + puCardH - 20);
                    } else {
                        ctx.font = 'bold 18px "Segoe UI", sans-serif';
                        ctx.fillStyle = canAfford ? '#E0F0FF' : 'rgba(224, 240, 255, 0.4)';
                        ctx.fillText('\u25C6 ' + cost, cx, y + puCardH - 38);

                        if (canAfford) {
                            const btnW = puCardW - 30;
                            const btnH = 36;
                            const btnX = x + 15;
                            const btnY = y + puCardH - btnH - 5;
                            ctx.fillStyle = def.color;
                            ctx.beginPath();
                            ctx.roundRect(btnX, btnY, btnW, btnH, 4);
                            ctx.fill();
                            ctx.fillStyle = '#000';
                            ctx.font = 'bold 18px "Segoe UI", sans-serif';
                            ctx.fillText('BUY', cx, btnY + 25);

                            shopButtons.push({ type: 'upgrade', id: key, x: btnX, y: btnY, w: btnW, h: btnH });
                        }
                    }
                }

                // BACK button (mobile)
                const backW = 300;
                const backH = 55;
                const backX = (CANVAS_WIDTH - backW) / 2;
                const backY = CANVAS_HEIGHT - backH - 15;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(backX, backY, backW, backH, 8);
                ctx.fill();
                ctx.stroke();
                ctx.textAlign = 'center';
                ctx.font = 'bold 26px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText('BACK', CANVAS_WIDTH / 2, backY + 37);
                shopButtons.push({ type: 'back', x: backX, y: backY, w: backW, h: backH });

            } else {
                // Desktop layout (original)
                const wCardW = 260;
                const wCardH = 100;
                const wGap = 16;
                const wTotalW = 3 * wCardW + 2 * wGap;
                const wStartX = (CANVAS_WIDTH - wTotalW) / 2;

                for (let i = 0; i < weaponIds.length; i++) {
                    const wid = weaponIds[i];
                    const w = WEAPONS[wid];
                    const col = i % 3;
                    const row = Math.floor(i / 3);
                    const x = wStartX + col * (wCardW + wGap);
                    const y = 160 + row * (wCardH + wGap);
                    const isUnlocked = !!prog.unlockedWeapons[wid];
                    const canBuy = !isUnlocked && canBuyWeapon(wid, prog);
                    const reqText = !isUnlocked ? getWeaponRequirementText(wid, prog) : null;

                    ctx.fillStyle = isUnlocked ? 'rgba(20, 40, 30, 0.8)' : 'rgba(20, 25, 40, 0.8)';
                    ctx.strokeStyle = isUnlocked ? 'rgba(57, 255, 20, 0.4)' : (canBuy ? w.color : 'rgba(255,255,255,0.15)');
                    ctx.lineWidth = isUnlocked ? 2 : 1;
                    ctx.beginPath();
                    ctx.roundRect(x, y, wCardW, wCardH, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.textAlign = 'left';
                    ctx.font = 'bold 16px "Segoe UI", sans-serif';
                    ctx.fillStyle = isUnlocked ? '#39FF14' : (canBuy ? w.color : 'rgba(255,255,255,0.4)');
                    ctx.fillText(w.name, x + 15, y + 28);

                    ctx.font = '12px "Segoe UI", sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillText(w.description, x + 15, y + 48);

                    if (isUnlocked) {
                        ctx.font = 'bold 14px "Segoe UI", sans-serif';
                        ctx.fillStyle = '#39FF14';
                        ctx.fillText('OWNED', x + 15, y + 75);
                    } else if (canBuy) {
                        ctx.font = 'bold 14px "Segoe UI", sans-serif';
                        ctx.fillStyle = '#E0F0FF';
                        ctx.fillText('\u25C6 ' + w.shopPrice, x + 15, y + 75);

                        const btnX = x + wCardW - 75;
                        const btnY = y + 60;
                        const btnW = 60;
                        const btnH = 26;
                        ctx.fillStyle = w.color;
                        ctx.beginPath();
                        ctx.roundRect(btnX, btnY, btnW, btnH, 4);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 12px "Segoe UI", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('BUY', btnX + btnW / 2, btnY + 18);
                        ctx.textAlign = 'left';

                        shopButtons.push({ type: 'weapon', id: wid, x: btnX, y: btnY, w: btnW, h: btnH });
                    } else if (reqText) {
                        ctx.font = '12px "Segoe UI", sans-serif';
                        ctx.fillStyle = 'rgba(255,100,100,0.6)';
                        ctx.fillText(reqText, x + 15, y + 75);
                    } else {
                        ctx.font = 'bold 14px "Segoe UI", sans-serif';
                        ctx.fillStyle = 'rgba(224, 240, 255, 0.4)';
                        ctx.fillText('\u25C6 ' + w.shopPrice, x + 15, y + 75);
                    }
                }

                // === PERMANENT UPGRADES SECTION (desktop) ===
                const wCardHDesktop = wCardH;
                const puStartY = 160 + 2 * (wCardHDesktop + wGap) + 30;
                ctx.font = 'bold 20px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.HUD_CYAN;
                ctx.textAlign = 'left';
                ctx.fillText('PERMANENT UPGRADES', 80, puStartY);

                const puKeys = Object.keys(PERMANENT_UPGRADES);
                const puCardW = (CANVAS_WIDTH - 160 - (puKeys.length - 1) * 12) / puKeys.length;
                const puCardH = 200;
                const puY = puStartY + 20;

                for (let i = 0; i < puKeys.length; i++) {
                    const key = puKeys[i];
                    const def = PERMANENT_UPGRADES[key];
                    const level = (prog.permanentUpgrades && prog.permanentUpgrades[key]) || 0;
                    const cost = getUpgradeCost(key, level);
                    const canAfford = (prog.crystals || 0) >= cost && level < def.maxLevel;
                    const isMaxed = level >= def.maxLevel;
                    const x = 80 + i * (puCardW + 12);

                    ctx.fillStyle = 'rgba(20, 25, 40, 0.8)';
                    ctx.strokeStyle = isMaxed ? 'rgba(57, 255, 20, 0.4)' : (canAfford ? def.color : 'rgba(255,255,255,0.15)');
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(x, puY, puCardW, puCardH, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.textAlign = 'center';
                    const cx = x + puCardW / 2;
                    ctx.font = 'bold 14px "Segoe UI", sans-serif';
                    ctx.fillStyle = def.color;
                    ctx.fillText(def.name, cx, puY + 25);

                    ctx.font = '11px "Segoe UI", sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillText(def.description, cx, puY + 45);

                    const barW = puCardW - 30;
                    const barX = x + 15;
                    const barY = puY + 60;
                    const segW = (barW - 9) / 10;
                    for (let s = 0; s < 10; s++) {
                        const sx = barX + s * (segW + 1);
                        ctx.fillStyle = s < level ? def.color : 'rgba(255,255,255,0.1)';
                        ctx.fillRect(sx, barY, segW, 12);
                    }

                    ctx.font = 'bold 12px "Segoe UI", sans-serif';
                    ctx.fillStyle = COLORS.UI_SECONDARY;
                    ctx.fillText(level + '/' + def.maxLevel, cx, barY + 32);

                    if (isMaxed) {
                        ctx.font = 'bold 14px "Segoe UI", sans-serif';
                        ctx.fillStyle = '#39FF14';
                        ctx.fillText('MAX', cx, puY + puCardH - 35);
                    } else {
                        ctx.font = '13px "Segoe UI", sans-serif';
                        ctx.fillStyle = canAfford ? '#E0F0FF' : 'rgba(224, 240, 255, 0.4)';
                        ctx.fillText('\u25C6 ' + cost, cx, puY + puCardH - 50);

                        if (canAfford) {
                            const btnW = 70;
                            const btnH = 26;
                            const btnX = cx - btnW / 2;
                            const btnY = puY + puCardH - 38;
                            ctx.fillStyle = def.color;
                            ctx.beginPath();
                            ctx.roundRect(btnX, btnY, btnW, btnH, 4);
                            ctx.fill();
                            ctx.fillStyle = '#000';
                            ctx.font = 'bold 12px "Segoe UI", sans-serif';
                            ctx.fillText('BUY', cx, btnY + 18);

                            shopButtons.push({ type: 'upgrade', id: key, x: btnX, y: btnY, w: btnW, h: btnH });
                        }
                    }
                }

                // Back instruction (desktop)
                ctx.textAlign = 'center';
                ctx.font = '16px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText('Press ESC or S to go back', CANVAS_WIDTH / 2, CANVAS_HEIGHT - 30);
            }

            // Store buttons for click handling
            currentShopButtons = shopButtons;
        }

        let currentShopButtons = [];
        let currentTutorialButtons = [];
        let currentMenuButtons = [];

        function handleShopClick(clickX, clickY) {
            for (const btn of currentShopButtons) {
                if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                    clickY >= btn.y && clickY <= btn.y + btn.h) {
                    if (btn.type === 'back') {
                        gameState = shopReturnState || 'menu';
                        return true;
                    }
                    const prog = loadProgression();
                    if (btn.type === 'weapon') {
                        if (canBuyWeapon(btn.id, prog)) {
                            prog.crystals -= WEAPONS[btn.id].shopPrice;
                            prog.unlockedWeapons[btn.id] = true;
                            saveProgression(prog);
                        }
                    } else if (btn.type === 'upgrade') {
                        const level = (prog.permanentUpgrades[btn.id]) || 0;
                        const cost = getUpgradeCost(btn.id, level);
                        if ((prog.crystals || 0) >= cost && level < PERMANENT_UPGRADES[btn.id].maxLevel) {
                            prog.crystals -= cost;
                            prog.permanentUpgrades[btn.id] = level + 1;
                            saveProgression(prog);
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        function handleTutorialClick(clickX, clickY) {
            for (const btn of currentTutorialButtons) {
                if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                    clickY >= btn.y && clickY <= btn.y + btn.h) {
                    selectTutorialWeapon(btn.id);
                    return true;
                }
            }
            return false;
        }

        function handleMenuClick(clickX, clickY) {
            for (const btn of currentMenuButtons) {
                if (clickX >= btn.x && clickX <= btn.x + btn.w &&
                    clickY >= btn.y && clickY <= btn.y + btn.h) {
                    if (btn.type === 'shop') {
                        shopReturnState = gameState;
                        gameState = 'shop';
                        return true;
                    }
                }
            }
            return false;
        }

        function renderPauseOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            ctx.font = 'bold 48px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
            
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Press P or ESC to Resume', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.fillText('Press R to Restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
        }
        
        function renderGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            
            // Game Over title
            ctx.font = 'bold 56px "Segoe UI", sans-serif';
            ctx.fillStyle = '#FF6B6B';
            ctx.shadowColor = '#FF6B6B';
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 15 : 0;
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 80);
            ctx.shadowBlur = 0;
            
            // Score
            ctx.font = 'bold 32px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('SCORE: ' + Math.floor(score), CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            
            // High score
            ctx.font = '24px "Segoe UI", sans-serif';
            if (isNewHighScore) {
                ctx.fillStyle = COLORS.GOLD;
                ctx.shadowColor = COLORS.GOLD;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 10 : 0;
                ctx.fillText('â˜… NEW HIGH SCORE! â˜…', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText('BEST: ' + highScore, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            }
            
            // Difficulty badge
            if (currentDifficulty > 0) {
                ctx.font = 'bold 14px "Segoe UI", sans-serif';
                ctx.fillStyle = DIFFICULTY_COLORS[currentDifficulty];
                ctx.fillText(DIFFICULTY_NAMES[currentDifficulty], CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 42);
            }

            // New difficulty unlocked
            if (lastRunCrystals && lastRunCrystals.newDifficultyUnlocked) {
                ctx.font = 'bold 16px "Segoe UI", sans-serif';
                ctx.fillStyle = '#39FF14';
                ctx.shadowColor = '#39FF14';
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;
                ctx.fillText('NEW DIFFICULTY UNLOCKED!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 42 + (currentDifficulty > 0 ? 20 : 0));
                ctx.shadowBlur = 0;
            }

            // Time survived
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Time: ' + minutes + 'm ' + seconds + 's', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 55);

            // Crystal breakdown
            if (lastRunCrystals) {
                const cx = CANVAS_WIDTH / 2;
                let cy = CANVAS_HEIGHT / 2 + 95;

                // Crystal section header
                ctx.font = 'bold 20px "Segoe UI", sans-serif';
                ctx.fillStyle = '#E0F0FF';
                ctx.fillText('â—† CRYSTALS EARNED', cx, cy);
                cy += 28;

                ctx.font = '16px "Segoe UI", sans-serif';
                ctx.fillStyle = 'rgba(224, 240, 255, 0.7)';
                if (lastRunCrystals.picked > 0) {
                    ctx.fillText('Collected: ' + lastRunCrystals.picked, cx, cy);
                    cy += 22;
                }
                if (lastRunCrystals.killBonus > 0) {
                    ctx.fillText('Kill bonus (' + totalKills + '/50): +' + lastRunCrystals.killBonus, cx, cy);
                    cy += 22;
                }
                if (lastRunCrystals.scoreBonus > 0) {
                    ctx.fillText('Score bonus (' + Math.floor(score) + '/1000): +' + lastRunCrystals.scoreBonus, cx, cy);
                    cy += 22;
                }
                if (lastRunCrystals.crystalMulti > 1) {
                    ctx.fillText('Crystal Attractor: x' + lastRunCrystals.crystalMulti.toFixed(2), cx, cy);
                    cy += 22;
                }

                // Total
                ctx.font = 'bold 22px "Segoe UI", sans-serif';
                ctx.fillStyle = '#E0F0FF';
                ctx.shadowColor = '#E0F0FF';
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;
                ctx.fillText('TOTAL: â—† ' + lastRunCrystals.total, cx, cy + 5);
                ctx.shadowBlur = 0;
                cy += 35;

                // Retry prompt + Shop button
                if (isMobile()) {
                    ctx.font = 'bold 26px "Segoe UI", sans-serif';
                    ctx.fillStyle = COLORS.UI_PRIMARY;
                    const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.fillText('TAP TO RETRY', cx, cy + 5);
                    ctx.globalAlpha = 1;

                    // Shop button
                    const shopBtnW = 280;
                    const shopBtnH = 50;
                    const shopBtnX = cx - shopBtnW / 2;
                    const shopBtnY = cy + 22;
                    ctx.fillStyle = 'rgba(224, 240, 255, 0.12)';
                    ctx.strokeStyle = 'rgba(224, 240, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(shopBtnX, shopBtnY, shopBtnW, shopBtnH, 8);
                    ctx.fill();
                    ctx.stroke();
                    ctx.font = 'bold 24px "Segoe UI", sans-serif';
                    ctx.fillStyle = '#E0F0FF';
                    ctx.fillText('SHOP', cx, shopBtnY + 34);
                    currentMenuButtons = [{ type: 'shop', x: shopBtnX, y: shopBtnY, w: shopBtnW, h: shopBtnH }];
                } else {
                    ctx.font = 'bold 22px "Segoe UI", sans-serif';
                    ctx.fillStyle = COLORS.UI_PRIMARY;
                    const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.fillText('Press R or TAP to Retry    [S] SHOP', cx, cy + 5);
                    ctx.globalAlpha = 1;
                }
            } else {
                // Retry prompt (fallback)
                if (isMobile()) {
                    ctx.font = 'bold 26px "Segoe UI", sans-serif';
                    ctx.fillStyle = COLORS.UI_PRIMARY;
                    const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.fillText('TAP TO RETRY', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 100);
                    ctx.globalAlpha = 1;

                    const shopBtnW = 280;
                    const shopBtnH = 50;
                    const shopBtnX = CANVAS_WIDTH / 2 - shopBtnW / 2;
                    const shopBtnY = CANVAS_HEIGHT / 2 + 118;
                    ctx.fillStyle = 'rgba(224, 240, 255, 0.12)';
                    ctx.strokeStyle = 'rgba(224, 240, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(shopBtnX, shopBtnY, shopBtnW, shopBtnH, 8);
                    ctx.fill();
                    ctx.stroke();
                    ctx.font = 'bold 24px "Segoe UI", sans-serif';
                    ctx.fillStyle = '#E0F0FF';
                    ctx.fillText('SHOP', CANVAS_WIDTH / 2, shopBtnY + 34);
                    currentMenuButtons = [{ type: 'shop', x: shopBtnX, y: shopBtnY, w: shopBtnW, h: shopBtnH }];
                } else {
                    ctx.font = 'bold 22px "Segoe UI", sans-serif';
                    ctx.fillStyle = COLORS.UI_PRIMARY;
                    const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.fillText('Press R or TAP to Retry    [S] SHOP', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 100);
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        // ============================================================
        // UTILITIES
        // ============================================================
        
        function normalizeAngle(angle) {
            while (angle > 180) angle -= 360;
            while (angle < -180) angle += 360;
            return angle;
        }

        // ============================================================
        // START GAME
        // ============================================================
        
        init();
        
    })();
    </script>
</body>
</html>
