<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Stellar Swarm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100dvh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        #gameContainer {
            position: relative;
            background: #020617;
        }
        
        #game {
            display: block;
        }
        
        /* Touch Controls */
        #touchControls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .touch-zone {
            position: absolute;
            pointer-events: auto;
        }
        
        #joystickZone {
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }

        #joystickBase {
            position: fixed;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 50%;
            display: none;
            pointer-events: none;
        }

        @media (pointer: coarse) {
            #joystickBase {
                display: block;
                left: 50%;
                bottom: 140px;
                transform: translateX(-50%);
            }
        }

        #joystickKnob {
            position: absolute;
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 50%;
            left: 12px;
            top: 12px;
            transition: none;
        }
        
        @media (pointer: coarse) {
            #touchControls {
                display: block;
            }
        }

        /* Upgrade Selection Panel */
        #upgradePanel {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 20, 0.95);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #upgradePanel.active {
            display: flex;
        }

        .upgrade-title {
            color: #FFD700;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            text-align: center;
        }

        .upgrade-subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 30px;
            text-align: center;
        }

        .upgrade-cards {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 380px;
        }

        .upgrade-card {
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.95) 0%, rgba(30, 40, 70, 0.9) 100%);
            border: 2px solid rgba(100, 100, 140, 0.4);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .upgrade-card:hover {
            transform: scale(1.02);
            border-color: var(--skill-color);
            box-shadow: 0 0 25px var(--skill-color-glow);
            background: linear-gradient(135deg, rgba(30, 40, 60, 0.95) 0%, rgba(40, 50, 80, 0.9) 100%);
        }

        .upgrade-card:active {
            transform: scale(0.98);
        }

        .upgrade-icon {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        .upgrade-info {
            flex: 1;
            min-width: 0;
        }

        .upgrade-name {
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .upgrade-desc {
            font-size: 13px;
            color: #aaa;
            line-height: 1.35;
        }

        .upgrade-key {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #666;
            flex-shrink: 0;
        }

        @media (max-height: 500px) {
            .upgrade-title {
                font-size: 24px;
                margin-bottom: 4px;
            }
            .upgrade-subtitle {
                font-size: 14px;
                margin-bottom: 15px;
            }
            .upgrade-card {
                padding: 12px;
            }
            .upgrade-icon {
                width: 44px;
                height: 44px;
            }
            .upgrade-name {
                font-size: 15px;
            }
            .upgrade-desc {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="touchControls">
            <div id="joystickZone" class="touch-zone"></div>
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <div id="upgradePanel">
            <div class="upgrade-title">LEVEL UP!</div>
            <div class="upgrade-subtitle">Choose an upgrade</div>
            <div class="upgrade-cards" id="upgradeCards"></div>
        </div>
    </div>

    <script>
    // ============================================================
    // STELLAR SWARM - Single File Game
    // ============================================================

    (function() {
        'use strict';

        // ============================================================
        // CONSTANTS
        // ============================================================
        
        // Canvas dimensions - set dynamically based on device
        let CANVAS_WIDTH = 1920;
        let CANVAS_HEIGHT = 1080;

        // Detect mobile device
        function isMobile() {
            return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) && window.innerWidth < 1024;
        }
        
        // Physics
        const ROTATION_SPEED = 300;          // deg/sec
        const THRUST_ACCEL = 2200;           // px/sec²
        const REVERSE_ACCEL = 450;           // px/sec²
        const MAX_SPEED = 600;               // px/sec
        const DRAG_FACTOR = 0.5;             // Increased drag to reduce inertia
        const BULLET_SPEED = 2000;           // px/sec
        const ORBITAL_RADIUS = 130;          // px - Radio base de los escudos orbitales
        const ORBITAL_SIZE = 26;             // px - Tamaño base de cada esfera orbital
        const ORBITAL_SPEED = 3;           // rad/sec - Velocidad base de rotacion

        // Garlic Aura
        const AURA_BASE_RADIUS = 100;      // px
        const AURA_BASE_DAMAGE = 4;        // damage per tick
        const AURA_BASE_TICK_RATE = 0.5;   // seconds between ticks

        // Alien Drone
        const DRONE_SPEED = 450;           // px/sec
        const DRONE_BASE_DAMAGE = 1;       // damage on impact
        const DRONE_EXPLOSION_RADIUS = 80; // px - explosion AoE radius
        const DRONE_EXPLOSION_DAMAGE = 1;  // damage in explosion area
        const DRONE_TURN_RATE = 360;       // degrees/sec
        const DRONE_SIZE = 5;              // px - small drones

        // Player
        const PLAYER_SIZE = 48;
        const PLAYER_COLLISION_RADIUS = 20;
        const PLAYER_VISUAL_RADIUS = 24;
        const PLAYER_MAX_HP = 3;
        const PLAYER_PIVOT_OFFSET = -5;
        const PLAYER_MASS = 2.5;             // Mass factor: higher = more inertia, harder to change direction       // Offset del punto de pivote: positivo = hacia el morro, negativo = hacia la cola
        const THRUSTER_PARTICLE_INTERVAL = 0.08; // Segundos entre partículas del thruster (menor = más partículas)

        // Pickups
        const PICKUP_MAGNET_RADIUS = 150;    // Radio de atracción de pickups hacia el jugador

        // Shield System
        const PLAYER_MAX_SHIELD = 400;           // Escudo máximo (16 golpes para vaciarlo)
        const SHIELD_REGEN_RATE = 50;            // Puntos por segundo
        const SHIELD_REGEN_DELAY = 2.5;          // Segundos sin daño para regenerar
        const SHIELD_DAMAGE_ABSORPTION = 25;     // Daño por golpe (4 golpes = escudo vacío)

        // Weapons
        const AUTO_FIRE_INTERVAL = 0.35;
        const BULLET_LIFETIME = 1.2;
        
        // Enemies
        const ENEMY_TYPES = {
            SCOUT: { radius: 10, speed: 120, turnRate: 90, hp: 4, points: 10, color: '#FF6B6B', outline: '#C04848' },
            KAMIKAZE: { radius: 10, speed: 180, turnRate: 60, hp: 4, points: 25, color: '#FF9A6B', outline: '#D86A3A' },
            SPINNER: { radius: 14, speed: 90, turnRate: 60, hp: 4, points: 40, color: '#3A9AD9', outline: '#1E6F9A', fireRate: 1.2 },
            TANK: { radius: 22, speed: 70, turnRate: 45, hp: 12, points: 75, color: '#C792FF', outline: '#8A5DBF' }
        };
        
        const INITIAL_SPAWN_INTERVAL_MIN = 0.15;
        const INITIAL_SPAWN_INTERVAL_MAX = 0.35;
        const MIN_SPAWN_INTERVAL = 0.03;
        const SPAWN_DECAY_RATE = 0.05;
        const SPAWN_DECAY_INTERVAL = 10;
        const MAX_ENEMIES = 500;
        const MAX_ENEMIES_LOW_PERF = 200;
        
        // Scoring
        const NEAR_MISS_RADIUS = 12;
        const NEAR_MISS_POINTS = 5;
        const MILESTONE_INTERVAL = 5000;
        
        // Effects
        const SHAKE_INTENSITY_HIT = 6;
        const SHAKE_DURATION_HIT = 220;
        const SHAKE_DURATION_DEATH = 420;
        const SLOWMO_FACTOR = 0.45;
        const SLOWMO_DURATION = 180;
        
        // Colors
        const COLORS = {
            PLAYER: '#7FDBFF',
            PLAYER_OUTLINE: '#3A9AD9',
            SHIELD: '#3A9AD9',
            SHIELD_BG: '#1A4A6A',
            THRUSTER: '#FFDD57',
            BULLET: '#7FDBFF',
            ENEMY_BULLET: '#FF6B6B',
            POWERUP: '#00FFAA',
            GOLD: '#FFDD57',
            RARE: '#C792FF',
            XP: '#00FFAA',
            UI_PRIMARY: '#FFFFFF',
            UI_SECONDARY: '#AAAAAA',
            BG_TOP: '#0a1628',
            BG_BOTTOM: '#020610',
            // HUD Colors
            HUD_CYAN: '#7FDBFF',
            HUD_CYAN_DIM: '#3A9AD9',
            HUD_CYAN_GLOW: 'rgba(127, 219, 255, 0.4)',
            HUD_RED: '#FF6B6B',
            HUD_RED_DIM: '#C04848',
            HUD_GOLD: '#FFDD57',
            HUD_GREEN: '#00FFAA',
            HUD_GREEN_DIM: '#00AA66',
            HUD_PURPLE: '#9F7AEA',
            HUD_SHIELD: '#44C8FF',
            HUD_SHIELD_DIM: '#1A6B99',
            HUD_SHIELD_GLOW: 'rgba(68, 200, 255, 0.35)',
            HUD_SHIELD_REGEN: '#66EEFF',
            HUD_WARNING: '#FF8844',
            HUD_TEXT_PRIMARY: '#E8F0FF',
            HUD_TEXT_SECONDARY: 'rgba(200, 215, 240, 0.55)',
            HUD_PANEL_BG: 'rgba(5, 12, 30, 0.85)',
            HUD_PANEL_BORDER: 'rgba(127, 219, 255, 0.15)'
        };

        // Shield Arc Constants (around player)
        const SHIELD_ARC_RADIUS = 42;
        const SHIELD_ARC_STROKE = 3;
        const SHIELD_ARC_TRACK_STROKE = 3;
        const SHIELD_ARC_IDLE_OPACITY = 0;
        const SHIELD_ARC_HIT_OPACITY = 1.0;
        const SHIELD_ARC_REGEN_OPACITY = 0.6;
        const SHIELD_ARC_LOW_THRESHOLD = 0.25;
        const SHIELD_ARC_FADE_DELAY = 2.0;
        const SHIELD_ARC_FLASH_DURATION = 0.12;

        // XP & Level System
        const XP_PER_LEVEL_BASE = 25;
        const XP_PER_LEVEL_GROWTH = 1.4;

        // Touch Controls
        const JOYSTICK_MAX_DISTANCE = 38;
        const JOYSTICK_DEADZONE = 0;
        const JOYSTICK_THRUST_THRESHOLD = 0.3;

        // Auto-Aim
        const AUTO_AIM_CONE_DEGREES = 30; // ±30° = 60° total cone
        const AUTO_AIM_MAX_DISTANCE = 700; // px - max range for laser auto-aim

        // Enemy Spawn
        const ENEMY_SPAWN_OFFSET_MIN = 50;
        const ENEMY_SPAWN_OFFSET_RANGE = 30;
        const ENEMY_SEPARATION_PADDING = 8;

        // Wave System - Vampire Survivor style
        const WAVE_INTERVAL_BASE = 2.5;       // Base seconds between waves (gets faster with level)
        const WAVE_INTERVAL_VARIANCE = 1.5;   // Random variance in seconds
        const WAVE_SPAWN_DISTANCE = 850;      // Distance from player
        const WAVE_PATTERNS = [
            'arc',           // Enemies in an arc around player
            'side',          // All enemies from one side
            'pincer',        // Enemies from two opposite sides
            'circle',        // Hexagonal staggered pattern (3 inner, 3 outer)
            'line',          // Horizontal or vertical line
            'cluster',       // Tight cluster from one direction
            'spiral',        // Spiral pattern converging on player
            'corners',       // From all 4 corners
            'rush',          // Dense column rushing from one direction
            'scatter',       // Random positions all around
            'v_formation'    // V-shape formation
        ];

        // Sector System - Infinite World
        const SECTOR_WIDTH = 3840;      // 2x viewport width
        const SECTOR_HEIGHT = 2160;     // 2x viewport height
        const GRID_SIZE = 3;            // 3x3 grid
        const WORLD_WIDTH = SECTOR_WIDTH * GRID_SIZE;   // 11520
        const WORLD_HEIGHT = SECTOR_HEIGHT * GRID_SIZE; // 6480

        const SECTOR_BOUNDS = {
            minX: -SECTOR_WIDTH / 2,     // -1920
            maxX: SECTOR_WIDTH / 2,      // +1920
            minY: -SECTOR_HEIGHT / 2,    // -1080
            maxY: SECTOR_HEIGHT / 2      // +1080
        };

        // Player Rotation
        const JOYSTICK_ROTATION_THRESHOLD = 5; // degrees
        
        // Skill Tree Definitions
        const SKILL_TREE = {
            // Root node - Ship Arsenal (unlocked by default)
            'arsenal': {
                name: 'SHIP ARSENAL',
                description: 'Your ship\'s weapon systems',
                prereqs: [],
                cost: 0,
                color: '#00DFFF',
                icon: 'arsenal',
                nodeType: 'hexagon'
            },
            // LASER CANNON branch (red/coral theme)
            'laser_cannon': {
                name: 'LASER CANNON',
                description: 'High-powered energy weapon',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'laser',
                nodeType: 'rectangle'
            },
            'rapid_fire': {
                name: 'Rapid Fire Module',
                description: 'Faster fire rate',
                prereqs: ['laser_cannon'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'rate',
                nodeType: 'circle'
            },
            'piercing_lens': {
                name: 'Piercing Lens',
                description: 'Laser penetrates enemies',
                prereqs: ['laser_cannon'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'beam',
                nodeType: 'circle'
            },
            'beam_splitter': {
                name: 'Beam Splitter',
                description: 'Fire 3 beams in a cone',
                prereqs: ['laser_cannon'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'spread',
                nodeType: 'circle'
            },
            // MISSILE LAUNCHER branch (yellow/gold theme)
            'missile_launcher': {
                name: 'MISSILE LAUNCHER',
                description: 'Homing missile system',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#FFD93D',
                icon: 'rocket',
                nodeType: 'rectangle'
            },
            'homing_guidance': {
                name: 'Rapid Barrage',
                description: 'Double burst (6 missiles per salvo)',
                prereqs: ['missile_launcher'],
                cost: 1,
                color: '#FFD93D',
                icon: 'target',
                nodeType: 'circle'
            },
            'cluster_payload': {
                name: 'Ricochet Warhead',
                description: 'Spawn 2 mini missiles on hit',
                prereqs: ['missile_launcher'],
                cost: 1,
                color: '#FFD93D',
                icon: 'cluster',
                nodeType: 'circle'
            },
            'armor_piercing': {
                name: 'Heavy Payload',
                description: '+12 missile & +8 explosion damage',
                prereqs: ['missile_launcher'],
                cost: 1,
                color: '#FFD93D',
                icon: 'damage',
                nodeType: 'circle'
            },
            // ORBITAL SHIELD branch (cyan/teal theme)
            'orbital_shield': {
                name: 'ORBITAL SHIELD',
                description: '3 fast rotating orbs damage enemies',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#00DFFF',
                icon: 'orbital',
                nodeType: 'rectangle'
            },
            'regen_capacitors': {
                name: 'Orbital Expansion',
                description: '+2 orbs (5 total)',
                prereqs: ['orbital_shield'],
                cost: 1,
                color: '#00DFFF',
                icon: 'regen',
                nodeType: 'circle'
            },
            'shockwave_emitter': {
                name: 'Orbital Amplification',
                description: 'Orbs +50% size',
                prereqs: ['orbital_shield'],
                cost: 1,
                color: '#00DFFF',
                icon: 'shockwave',
                nodeType: 'circle'
            },
            'energy_absorption': {
                name: 'Energy Absorption',
                description: 'Orbs deal +16 damage',
                prereqs: ['orbital_shield'],
                cost: 1,
                color: '#00DFFF',
                icon: 'absorb',
                nodeType: 'circle'
            },
            // LIGHTNING RAY branch (electric purple/blue theme)
            'lightning_ray': {
                name: 'LIGHTNING RAY',
                description: 'Chain lightning hits nearby enemies',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'lightning',
                nodeType: 'rectangle'
            },
            'chain_amplifier': {
                name: 'Chain Amplifier',
                description: '+6 chain bounces (12 total)',
                prereqs: ['lightning_ray'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'chain',
                nodeType: 'circle'
            },
            'rapid_discharge': {
                name: 'Rapid Discharge',
                description: '+50% lightning fire rate',
                prereqs: ['lightning_ray'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'discharge',
                nodeType: 'circle'
            },
            'extended_arc': {
                name: 'Extended Arc',
                description: '+50% detection & chain range',
                prereqs: ['lightning_ray'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'arc',
                nodeType: 'circle'
            },
            // PLASMA FIELD branch (cyan theme - same as player)
            'plasma_field': {
                name: 'PLASMA FIELD',
                description: 'Damaging energy field around the ship',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'aura',
                nodeType: 'rectangle'
            },
            'field_expansion': {
                name: 'Field Expansion',
                description: '+50% field radius',
                prereqs: ['plasma_field'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'expand',
                nodeType: 'circle'
            },
            'field_intensity': {
                name: 'Field Intensity',
                description: '+8 field damage',
                prereqs: ['plasma_field'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'damage',
                nodeType: 'circle'
            },
            'field_pulse': {
                name: 'Rapid Pulse',
                description: '+50% tick rate',
                prereqs: ['plasma_field'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'pulse',
                nodeType: 'circle'
            },
            // ALIEN DRONE branch (green/toxic theme)
            'alien_drone': {
                name: 'ALIEN DRONE',
                description: 'Kamikaze drones spawn from killed enemies',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#39FF14',
                icon: 'drone',
                nodeType: 'rectangle'
            },
            'drone_duo': {
                name: 'Drone Swarm',
                description: 'Spawn 2 drones per kill',
                prereqs: ['alien_drone'],
                cost: 1,
                color: '#39FF14',
                icon: 'swarm',
                nodeType: 'circle'
            },
            'drone_duration': {
                name: 'Extended Range',
                description: 'Drones last twice as long',
                prereqs: ['alien_drone'],
                cost: 1,
                color: '#39FF14',
                icon: 'duration',
                nodeType: 'circle'
            },
            'drone_explosion': {
                name: 'Volatile Core',
                description: 'Drones explode on impact (AoE damage)',
                prereqs: ['alien_drone'],
                cost: 1,
                color: '#39FF14',
                icon: 'explosion',
                nodeType: 'circle'
            }
        };

        // Weapon upgrade mapping for HUD display
        const WEAPON_UPGRADES = {
            'laser_cannon': ['rapid_fire', 'piercing_lens', 'beam_splitter'],
            'missile_launcher': ['homing_guidance', 'cluster_payload', 'armor_piercing'],
            'orbital_shield': ['regen_capacitors', 'shockwave_emitter', 'energy_absorption'],
            'lightning_ray': ['chain_amplifier', 'rapid_discharge', 'extended_arc'],
            'plasma_field': ['field_expansion', 'field_intensity', 'field_pulse'],
            'alien_drone': ['drone_duo', 'drone_duration', 'drone_explosion']
        };

        // ============================================================
        // GAME STATE
        // ============================================================
        
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        
        let gameState = 'menu'; // menu, playing, paused, gameOver, skilltree
        let lastTime = 0;
        let deltaTime = 0;
        let timeScale = 1;
        let gameTime = 0;
        let score = 0;
        let highScore = 0;
        let isNewHighScore = false;
        let totalKills = 0;

        // Wave Alert System
        let waveAlertActive = false;
        let waveAlertTimer = 0;
        let waveAlertNumber = 0;
        let waveAlertSubtitle = '';
        const WAVE_ALERT_DURATION = 2.5;

        // Safe localStorage access
        try {
            highScore = parseInt(localStorage.getItem('StellarSwarm_highscore_v1')) || 0;
        } catch (e) {
            console.warn('localStorage not available:', e);
            highScore = 0;
        }

        // ============================================================
        // META-PROGRESSION SYSTEM
        // ============================================================
        const PROGRESSION_SAVE_KEY = 'StellarSwarm_progression_v1';
        const WEAPON_IDS = ['laser_cannon', 'orbital_shield', 'missile_launcher', 'lightning_ray', 'plasma_field', 'alien_drone'];

        function createDefaultProgression() {
            const unlockedWeapons = {};
            for (const wid of WEAPON_IDS) {
                unlockedWeapons[wid] = (wid === 'laser_cannon');
            }
            return {
                unlockedWeapons,
                bossDefeats: {},
                stats: { totalBossDefeats: 0, totalRuns: 0 }
            };
        }

        function loadProgression() {
            try {
                const raw = localStorage.getItem(PROGRESSION_SAVE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    // Ensure all weapon keys exist (forward-compat)
                    const defaults = createDefaultProgression();
                    for (const wid of WEAPON_IDS) {
                        if (data.unlockedWeapons[wid] === undefined) {
                            data.unlockedWeapons[wid] = defaults.unlockedWeapons[wid];
                        }
                    }
                    if (!data.bossDefeats) data.bossDefeats = {};
                    if (!data.stats) data.stats = defaults.stats;
                    if (data.stats.totalBossDefeats === undefined) data.stats.totalBossDefeats = 0;
                    if (data.stats.totalRuns === undefined) data.stats.totalRuns = 0;
                    return data;
                }
            } catch (e) {
                console.warn('Could not load progression:', e);
            }
            return createDefaultProgression();
        }

        function saveProgression(data) {
            try {
                localStorage.setItem(PROGRESSION_SAVE_KEY, JSON.stringify(data));
            } catch (e) {
                console.warn('Could not save progression:', e);
            }
        }

        function getUnlockedWeaponsForRun() {
            const prog = loadProgression();
            return WEAPON_IDS.filter(wid => prog.unlockedWeapons[wid]);
        }

        let currentRunUnlockedWeapons = ['laser_cannon'];
        
        // Performance monitoring
        let frameTimeAccum = 0;
        let frameCount = 0;
        let avgFrameTime = 16;
        let lowPerfMode = false;

        // Disable glow effects for massive performance boost
        // shadowBlur is extremely expensive on canvas
        const ENABLE_GLOW_EFFECTS = false;

        // Helper to set glow only when enabled
        function setGlow(context, color, blur) {
            if (ENABLE_GLOW_EFFECTS) {
                context.shadowColor = color;
                context.shadowBlur = blur;
            }
        }

        function clearGlow(context) {
            if (ENABLE_GLOW_EFFECTS) {
                context.shadowBlur = 0;
            }
        }
        
        // Input state
        const keys = {};
        const input = {
            rotateLeft: false,
            rotateRight: false,
            thrust: false,
            reverse: false,
            pause: false
        };
        
        // Cheat code system
        let cheatCodeBuffer = '';
        const CHEAT_CODES = {
            'rocket': () => {
                // Unlock missile launcher and all missile upgrades
                if (!unlockedSkills.includes('missile_launcher')) {
                    unlockedSkills.push('missile_launcher');
                }
                ['homing_guidance', 'cluster_payload', 'armor_piercing'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                spawnFloatingText(player.x, player.y - 50, 'MISSILES UNLOCKED', '#FFD93D');
                spawnFloatingText(player.x, player.y, 'MISSILES UNLOCKED', '#FFD93D');
            },
            'orbit': () => {
                // Unlock orbital shield and all shield upgrades
                if (!unlockedSkills.includes('orbital_shield')) {
                    unlockedSkills.push('orbital_shield');
                }
                ['regen_capacitors', 'shockwave_emitter', 'energy_absorption'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                spawnFloatingText(player.x, player.y - 50, 'ORBITAL SHIELD UNLOCKED', '#00DFFF');
                spawnFloatingText(player.x, player.y, 'ORBITAL SHIELD UNLOCKED', '#00DFFF');
            },
            'chain': () => {
                // Unlock lightning ray and all lightning upgrades
                if (!unlockedSkills.includes('lightning_ray')) {
                    unlockedSkills.push('lightning_ray');
                }
                ['chain_amplifier', 'rapid_discharge', 'extended_arc'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                spawnFloatingText(player.x, player.y - 50, 'LIGHTNING RAY UNLOCKED', '#9F7AEA');
                spawnFloatingText(player.x, player.y, 'LIGHTNING RAY UNLOCKED', '#9F7AEA');
            },
            'drone': () => {
                // Unlock alien drone and all drone upgrades
                if (!unlockedSkills.includes('alien_drone')) {
                    unlockedSkills.push('alien_drone');
                }
                ['drone_duo', 'drone_duration', 'drone_explosion'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                spawnFloatingText(player.x, player.y - 50, 'ALIEN DRONES UNLOCKED', '#39FF14');
                spawnFloatingText(player.x, player.y, 'ALIEN DRONES UNLOCKED', '#39FF14');
            },
            'full': () => {
                // Unlock ALL skills
                Object.keys(SKILL_TREE).forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                spawnFloatingText(player.x, player.y - 50, 'ALL ABILITIES UNLOCKED', '#FFD700');
                spawnFloatingText(player.x, player.y, 'FULL ARSENAL', '#FFD700');
            },
            'arena': () => {
                // Toggle arena for testing
                if (arenaActive) {
                    deactivateArena();
                } else {
                    activateArena(player.x, player.y);
                }
            },
            'boss': () => {
                spawnBoss(0);
            },
            'titan': () => {
                spawnBoss(1);
            },
            'nexus': () => {
                spawnBoss(2);
            }
        };
        
        // Touch state
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickMagnitude = 0;
        
        // Player
        let player = null;
        
        // Entity pools
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let particles = [];
        let floatingTexts = [];
        let pickups = [];
        let orbitals = [];
        let lightningEffects = [];
        let drones = [];
        let auraState = {
            tickTimer: 0,
            pulseAnimation: 0
        };

        // Camera system
        let camera = {
            x: 0,              // World X position (center of viewport)
            y: 0,              // World Y position (center of viewport)
            targetX: 0,        // Target X to follow (player.x)
            targetY: 0,        // Target Y to follow (player.y)
            smoothing: 0.1     // Camera lag for smooth follow (0.1 = 10% per frame)
        };


        // XP & Level state
        let playerXP = 0;
        let playerLevel = 1;
        let xpToNextLevel = XP_PER_LEVEL_BASE;
        
        // Skill Tree state
        let skillPoints = 0;
        let unlockedSkills = ['arsenal', 'laser_cannon'];
        let upgradeOptions = [];
        let upgradeSelectionActive = false;
        
        // Spawn system
        let spawnTimer = 0;
        let spawnInterval = INITIAL_SPAWN_INTERVAL_MAX;
        let lastSpawnDecayTime = 0;
        let waveNumber = 0;

        // Wave system
        let waveTimer = WAVE_INTERVAL_BASE + Math.random() * WAVE_INTERVAL_VARIANCE;
        let lastWavePattern = null;

        // Effects
        let shakeIntensity = 0;
        let shakeDuration = 0;
        let shakeTimer = 0;
        let flashColor = null;
        let flashOpacity = 0;
        let flashDuration = 0;
        let slowmoTimer = 0;
        let slowmoDuration = 0;

        // Arena system (boss fights)
        let arenaActive = false;
        let arenaCenter = { x: 0, y: 0 };
        const ARENA_RADIUS = 1200;
        const ARENA_START_RADIUS = 5000;
        const ARENA_CLOSE_SPEED = 900;
        let arenaCurrentRadius = ARENA_RADIUS;
        let arenaSpawnPaused = false;

        // ============================================================
        // BOSS SYSTEM
        // ============================================================
        const BOSS_SPAWN_LEVELS = [8, 14, 20, 27, 35];
        const BOSS_TYPES = ['orbitalGuardian', 'missileTitan', 'lightningNexus', 'plasmaOverlord', 'swarmMother'];
        const BOSS_NAMES = ['ORBITAL GUARDIAN', 'MISSILE TITAN', 'LIGHTNING NEXUS', 'PLASMA OVERLORD', 'SWARM MOTHER'];
        const BOSS_COLORS = ['#00DFFF', '#FFD93D', '#9F7AEA', '#FF6600', '#39FF14'];
        const BOSS_BASE_HP = [2000, 6000, 8000, 12000, 16000];
        const BOSS_WEAPON_UNLOCK = ['orbital_shield', 'missile_launcher', 'lightning_ray', 'plasma_field', 'alien_drone'];

        // Boss projectile constants
        const BOSS_PROJ_SPEED = 350;
        const BOSS_PROJ_DAMAGE = 1;
        const BOSS_PROJ_HP = 3;
        const BOSS_PROJ_RADIUS = 8;
        const BOSS_PROJ_LIFETIME = 12;

        let currentBoss = null;
        let bossProjectiles = [];
        let bossPhase = 1;
        let bossPatternTimer = 0;
        let bossDefeated = false;
        let bossesDefeatedThisRun = [];
        let bossHealthBarDisplayHP = 0;
        let bossIncoming = null; // { bossIndex, timer } — pending boss during arena close

        // Orbital Guardian sphere system
        let bossSpheres = [];

        // Missile Titan homing missiles
        let bossHomingMissiles = [];
        let bossMTCannonTimer = 0; // tracks cannon reload visual

        // Lightning Nexus systems
        let bossLightningStrikes = []; // { startX, startY, endX, endY, phase, timer, zigzag }
        let bossTrailNodes = [];    // { x, y, radius, maxRadius, growing, growTimer, maxGrowTime, active }
        let bossTrailRays = [];     // { startX, startY, endX, endY }
        let bossTrailTimer = 0;     // countdown to spawn next node

        // Milestones
        let lastMilestone = 0;
        let milestoneActive = false;
        let milestoneTimer = 0;
        
        // Background
        let nebulas = [];
        let cachedBgGradient = null;
        let cachedScanlinePattern = null;
        let cachedVignetteGradient = null;
        let lastCacheWidth = 0;
        let lastCacheHeight = 0;

        // Idle state
        let idleTimer = 0;

        // ============================================================
        // PERFORMANCE OPTIMIZATIONS
        // ============================================================

        // Spatial Grid for collision detection optimization
        const SPATIAL_GRID_CELL_SIZE = 250;

        const spatialGrid = {
            cellSize: SPATIAL_GRID_CELL_SIZE,
            cells: new Map(),
            // Reusable arrays to avoid allocations
            _queryResults: [],
            _querySeen: new Set(),
            _cellKeys: [],

            getCellKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            },

            clear() {
                for (const cell of this.cells.values()) {
                    cell.length = 0;
                }
            },

            insert(entity, radius = 50) {
                const minCellX = Math.floor((entity.x - radius) / this.cellSize);
                const maxCellX = Math.floor((entity.x + radius) / this.cellSize);
                const minCellY = Math.floor((entity.y - radius) / this.cellSize);
                const maxCellY = Math.floor((entity.y + radius) / this.cellSize);

                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    for (let cy = minCellY; cy <= maxCellY; cy++) {
                        const key = `${cx},${cy}`;
                        if (!this.cells.has(key)) {
                            this.cells.set(key, []);
                        }
                        this.cells.get(key).push(entity);
                    }
                }
            },

            queryRadius(x, y, radius) {
                // Reuse arrays to avoid garbage collection
                const results = this._queryResults;
                const seen = this._querySeen;
                results.length = 0;
                seen.clear();

                const minCellX = Math.floor((x - radius) / this.cellSize);
                const maxCellX = Math.floor((x + radius) / this.cellSize);
                const minCellY = Math.floor((y - radius) / this.cellSize);
                const maxCellY = Math.floor((y + radius) / this.cellSize);

                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    for (let cy = minCellY; cy <= maxCellY; cy++) {
                        const cell = this.cells.get(`${cx},${cy}`);
                        if (cell) {
                            for (let i = 0; i < cell.length; i++) {
                                const entity = cell[i];
                                if (!seen.has(entity)) {
                                    seen.add(entity);
                                    results.push(entity);
                                }
                            }
                        }
                    }
                }
                return results;
            }
        };

        // Object Pool for reducing garbage collection
        class ObjectPool {
            constructor(factory, resetFn, capacity) {
                this.factory = factory;
                this.resetFn = resetFn;
                this.capacity = capacity;
                this.available = [];

                for (let i = 0; i < capacity; i++) {
                    this.available.push(factory());
                }
            }

            acquire() {
                if (this.available.length > 0) {
                    return this.available.pop();
                }
                return this.factory();
            }

            release(obj) {
                if (this.available.length < this.capacity) {
                    this.resetFn(obj);
                    this.available.push(obj);
                }
            }

            releaseAll(array) {
                for (const obj of array) {
                    this.release(obj);
                }
                array.length = 0;
            }
        }

        // Create object pools for all entity types (sized to support 1000+ entities)
        const pools = {
            bullet: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, damage: 1, type: 'laser', color: '', piercing: false, hitEnemies: null, turnRate: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.hitEnemies = null; obj.piercing = false; obj.turnRate = 0; },
                500
            ),

            enemy: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, angle: 0, type: '', hp: 1, maxHp: 1, fireTimer: 0, burstCooldown: 0, spawnTime: 0, offScreenTime: 0, nearMissTriggered: false }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.hp = 1; obj.nearMissTriggered = false; obj.offScreenTime = 0; },
                400
            ),

            particle: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, size: 0, color: '', type: '', angle: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.angle = 0; },
                400
            ),

            enemyBullet: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, nearMissTriggered: false }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.nearMissTriggered = false; },
                300
            ),

            floatingText: new ObjectPool(
                () => ({ x: 0, y: 0, text: '', color: '', life: 0, maxLife: 0, vy: -50 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.text = ''; obj.life = 0; },
                100
            ),

            pickup: new ObjectPool(
                () => ({ x: 0, y: 0, type: '', life: 0, bobTimer: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.type = ''; obj.life = 0; obj.bobTimer = 0; },
                50
            ),

            drone: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, angle: 0, life: 0, damage: 1, hasExplosion: false, trail: [] }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.angle = 0; obj.life = 0; obj.trail = []; },
                100
            )
        };

        // Culling distance thresholds
        const CULLING_DISTANCES = {
            enemies: 6000,
            particles: 4000,
            pickups: 5000,
            floatingTexts: 3000,
            bullets: 5760,
            enemyBullets: 5760,
            drones: 5000
        };

        // Fast removal helper: swap-and-pop is O(1) instead of splice's O(n)
        function fastRemove(array, index) {
            if (index < array.length - 1) {
                array[index] = array[array.length - 1];
            }
            array.pop();
        }

        // Performance monitoring
        const perfMonitor = {
            frameTimeAccum: 0,
            frameCount: 0,
            avgFrameTime: 16,
            fps: 60,

            entityCounts: {
                bullets: 0,
                enemies: 0,
                particles: 0,
                enemyBullets: 0,
                pickups: 0
            },

            optimizationStats: {
                spatialGridCells: 0,
                entitiesCulled: 0
            },

            update(dt) {
                this.frameTimeAccum += dt * 1000;
                this.frameCount++;

                if (this.frameCount >= 30) {
                    this.avgFrameTime = this.frameTimeAccum / this.frameCount;
                    this.fps = Math.round(1000 / this.avgFrameTime);
                    this.frameTimeAccum = 0;
                    this.frameCount = 0;
                }

                this.entityCounts.bullets = bullets.length;
                this.entityCounts.enemies = enemies.length;
                this.entityCounts.particles = particles.length;
                this.entityCounts.enemyBullets = enemyBullets.length;
                this.entityCounts.pickups = pickups.length;

                this.optimizationStats.spatialGridCells = spatialGrid.cells.size;
            },

            renderDebug() {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 100, 220, 220);

                ctx.font = '12px monospace';
                ctx.fillStyle = '#00FF00';
                ctx.textAlign = 'left';

                let y = 120;
                ctx.fillText(`FPS: ${this.fps}`, 20, y); y += 18;
                ctx.fillText(`Frame: ${this.avgFrameTime.toFixed(2)}ms`, 20, y); y += 18;
                ctx.fillText(`---`, 20, y); y += 18;
                ctx.fillText(`Bullets: ${this.entityCounts.bullets}`, 20, y); y += 18;
                ctx.fillText(`Enemies: ${this.entityCounts.enemies}`, 20, y); y += 18;
                ctx.fillText(`Particles: ${this.entityCounts.particles}`, 20, y); y += 18;
                ctx.fillText(`EnemyBullets: ${this.entityCounts.enemyBullets}`, 20, y); y += 18;
                ctx.fillText(`Pickups: ${this.entityCounts.pickups}`, 20, y); y += 18;
                ctx.fillText(`---`, 20, y); y += 18;
                ctx.fillText(`Grid Cells: ${this.optimizationStats.spatialGridCells}`, 20, y); y += 18;

                ctx.restore();
            }
        };

        let showDebugOverlay = false;

        // ============================================================
        // INITIALIZATION
        // ============================================================

        function initBackgroundCache() {
            // Only regenerate if dimensions changed
            if (lastCacheWidth === CANVAS_WIDTH && lastCacheHeight === CANVAS_HEIGHT) {
                return;
            }
            lastCacheWidth = CANVAS_WIDTH;
            lastCacheHeight = CANVAS_HEIGHT;

            // Regenerate background gradient (radial, lighter in center)
            const bgCenterX = CANVAS_WIDTH / 2;
            const bgCenterY = CANVAS_HEIGHT / 2;
            const bgOuterRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
            cachedBgGradient = ctx.createRadialGradient(
                bgCenterX, bgCenterY, 0,
                bgCenterX, bgCenterY, bgOuterRadius
            );
            cachedBgGradient.addColorStop(0, COLORS.BG_TOP);
            cachedBgGradient.addColorStop(1, COLORS.BG_BOTTOM);

            // Create scanline pattern (1x4 canvas with alternating lines)
            const scanlineCanvas = document.createElement('canvas');
            scanlineCanvas.width = 1;
            scanlineCanvas.height = 4;
            const scanlineCtx = scanlineCanvas.getContext('2d');
            scanlineCtx.fillStyle = 'rgba(127, 219, 255, 0.04)';
            scanlineCtx.fillRect(0, 0, 1, 2);
            // Lines 2-3 remain transparent
            cachedScanlinePattern = ctx.createPattern(scanlineCanvas, 'repeat');

            // Create vignette gradient
            const centerX = CANVAS_WIDTH / 2;
            const centerY = CANVAS_HEIGHT / 2;
            const innerRadius = CANVAS_HEIGHT * 0.3;
            const outerRadius = CANVAS_HEIGHT * 0.8;
            cachedVignetteGradient = ctx.createRadialGradient(
                centerX, centerY, innerRadius,
                centerX, centerY, outerRadius
            );
            cachedVignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            cachedVignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        }

        function init() {
            // Set canvas dimensions based on device
            if (isMobile()) {
                CANVAS_WIDTH = 720;
                CANVAS_HEIGHT = 1280;
            } else {
                CANVAS_WIDTH = 1920;
                CANVAS_HEIGHT = 1080;
            }

            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            generateBackground();
            initBackgroundCache();
            setupInput();
            setupTouchControls();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            requestAnimationFrame(gameLoop);
        }
        
        function resizeCanvas() {
            const windowRatio = window.innerWidth / window.innerHeight;
            const gameRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            
            let width, height;
            if (windowRatio > gameRatio) {
                height = window.innerHeight;
                width = height * gameRatio;
            } else {
                width = window.innerWidth;
                height = width / gameRatio;
            }
            
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        
        function generateBackground() {
            // Generate nebula blobs
            nebulas = [];
            for (let i = 0; i < 5; i++) {
                nebulas.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    radius: Math.random() * 100 + 50,
                    color: Math.random() > 0.5 ? 'rgba(199, 146, 255, 0.05)' : 'rgba(58, 154, 217, 0.05)'
                });
            }
        }
        
        function resetGame() {
            // Reset arena state
            arenaActive = false;
            arenaCurrentRadius = ARENA_RADIUS;
            arenaSpawnPaused = false;

            // Reset boss state
            currentBoss = null;
            bossIncoming = null;
            bossProjectiles = [];
            bossPhase = 1;
            bossPatternTimer = 0;
            bossDefeated = false;
            bossesDefeatedThisRun = [];
            bossHealthBarDisplayHP = 0;
            bossPatternIndex = 0;
            bossPatternCooldown = 2.5;
            bossPatternActive = false;
            bossPatternState = null;
            bossSpheres = [];

            player = {
                x: WORLD_WIDTH / 2,   // Center of world (5760)
                y: WORLD_HEIGHT / 2,  // Center of world (3240)
                vx: 0,
                vy: 0,
                angle: -90, // Pointing up
                hp: PLAYER_MAX_HP,
                shield: PLAYER_MAX_SHIELD,
                shieldRegenTimer: 0,
                shieldFlashTimer: 0,
                fireTimer: 0,
                invulnerable: 0,
                thrusterScale: 0,
                thrusterParticleTimer: 0,
                bobOffset: 0,
                bobTimer: 0,
                // Shield Arc State
                shieldArcOpacity: SHIELD_ARC_IDLE_OPACITY,
                shieldArcTargetOpacity: SHIELD_ARC_IDLE_OPACITY,
                shieldArcIdleTimer: 0,
                shieldArcFlashTimer: 0,
                shieldArcFlashColor: null,
                shieldArcPulsePhase: 0,
                shieldArcLastValue: PLAYER_MAX_SHIELD
            };

            // Initialize camera at player position
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;

            // Release all pooled objects
            pools.bullet.releaseAll(bullets);
            pools.enemy.releaseAll(enemies);
            pools.particle.releaseAll(particles);
            pools.enemyBullet.releaseAll(enemyBullets);
            pools.floatingText.releaseAll(floatingTexts);
            pools.pickup.releaseAll(pickups);
            pools.drone.releaseAll(drones);

            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            floatingTexts = [];
            pickups = [];
            orbitals = [];
            lightningEffects = [];
            drones = [];
            auraState = { tickTimer: 0, pulseAnimation: 0 };

            score = 0;
            gameTime = 0;
            totalKills = 0;

            // Wave alert reset
            waveAlertActive = false;
            waveAlertTimer = 0;
            waveAlertNumber = 0;
            waveAlertSubtitle = '';
            
            // XP & Level reset
            playerXP = 0;
            playerLevel = 1;
            xpToNextLevel = XP_PER_LEVEL_BASE;
            
            // Skill Tree reset - load persistent progression
            skillPoints = 0;
            currentRunUnlockedWeapons = getUnlockedWeaponsForRun();
            unlockedSkills = ['arsenal', 'laser_cannon'];
            upgradeOptions = [];
            upgradeSelectionActive = false;

            // Increment totalRuns
            const prog = loadProgression();
            prog.stats.totalRuns++;
            saveProgression(prog);
            document.getElementById('upgradePanel').classList.remove('active');
            
            spawnTimer = 0;
            spawnInterval = INITIAL_SPAWN_INTERVAL_MAX;
            lastSpawnDecayTime = 0;
            waveNumber = 0;
            waveTimer = WAVE_INTERVAL_BASE + Math.random() * WAVE_INTERVAL_VARIANCE;
            lastWavePattern = null;

            shakeIntensity = 0;
            shakeDuration = 0;
            flashColor = null;
            slowmoTimer = 0;
            
            lastMilestone = 0;
            milestoneActive = false;
            isNewHighScore = false;
            idleTimer = 0;
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================
        
        function setupInput() {
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                // Handle cheat codes (only when playing)
                if (gameState === 'playing' && e.key.length === 1) {
                    cheatCodeBuffer += e.key.toLowerCase();
                    
                    // Check if any cheat code matches the buffer
                    for (const [code, action] of Object.entries(CHEAT_CODES)) {
                        if (cheatCodeBuffer.includes(code)) {
                            action();
                            cheatCodeBuffer = '';
                            break;
                        }
                    }
                    
                    // Keep buffer manageable
                    if (cheatCodeBuffer.length > 20) {
                        cheatCodeBuffer = cheatCodeBuffer.slice(-10);
                    }
                }
                
                if (e.code === 'Escape') {
                    if (gameState === 'playing') {
                        gameState = 'paused';
                    } else if (gameState === 'paused') {
                        gameState = 'playing';
                    }
                    // skilltree: no ESC close - must choose an upgrade
                }

                // P key pauses the game
                if (e.code === 'KeyP') {
                    if (gameState === 'playing') {
                        gameState = 'paused';
                    } else if (gameState === 'paused') {
                        gameState = 'playing';
                    }
                }

                if (e.code === 'Enter' || e.code === 'Space') {
                    if (gameState === 'menu') {
                        gameState = 'playing';
                        resetGame();
                    }
                }

                if (e.code === 'KeyR' && gameState === 'gameOver') {
                    gameState = 'playing';
                    resetGame();
                }

                // Toggle debug overlay with B key
                if (e.code === 'KeyB') {
                    showDebugOverlay = !showDebugOverlay;
                }

                // Upgrade panel: select with 1, 2, 3 keys
                if (gameState === 'skilltree' && upgradeSelectionActive) {
                    if (e.code === 'Digit1' && upgradeOptions[0]) {
                        selectUpgrade(upgradeOptions[0]);
                    } else if (e.code === 'Digit2' && upgradeOptions[1]) {
                        selectUpgrade(upgradeOptions[1]);
                    } else if (e.code === 'Digit3' && upgradeOptions[2]) {
                        selectUpgrade(upgradeOptions[2]);
                    }
                }
                
                e.preventDefault();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
        }
        
        function updateInput() {
            input.rotateLeft = keys['ArrowLeft'] || keys['KeyA'];
            input.rotateRight = keys['ArrowRight'] || keys['KeyD'];
            input.thrust = keys['ArrowUp'] || keys['KeyW'];
            input.reverse = keys['ArrowDown'] || keys['KeyS'];
            // Apply touch input
            if (joystickActive) {
                if (joystickMagnitude > JOYSTICK_THRUST_THRESHOLD) {
                    input.thrust = true;
                }
                // Joystick rotation handled directly in player update
            }
            
        }
        
        function setupTouchControls() {
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');

            let joystickTouch = null;
            const baseRect = { x: 30, y: 0, cx: 90, cy: 0 };
            
            joystickZone.addEventListener('touchstart', (e) => {
                if (gameState === 'menu') {
                    gameState = 'playing';
                    resetGame();
                    return;
                }

                if (gameState === 'gameOver') {
                    gameState = 'playing';
                    resetGame();
                    return;
                }

                if (gameState === 'skilltree') {
                    return; // Don't activate joystick during skill tree
                }

                joystickTouch = e.touches[0];
                joystickActive = true;

                // Position joystick centered at touch point
                joystickBase.style.left = (joystickTouch.clientX - 40) + 'px';
                joystickBase.style.top = (joystickTouch.clientY - 40) + 'px';
                joystickBase.style.bottom = 'auto';
                joystickBase.style.transform = 'none';

                // Reset knob to center
                joystickKnob.style.left = '12px';
                joystickKnob.style.top = '12px';
                joystickMagnitude = 0;

                e.preventDefault();
            });
            
            joystickZone.addEventListener('touchmove', (e) => {
                if (joystickActive) {
                    joystickTouch = e.touches[0];
                    updateJoystick(joystickTouch);
                }
                e.preventDefault();
            });
            
            joystickZone.addEventListener('touchend', () => {
                joystickActive = false;
                joystickMagnitude = 0;
                joystickKnob.style.left = '12px';
                joystickKnob.style.top = '12px';

                // Reset joystick to default position (bottom center)
                joystickBase.style.left = '50%';
                joystickBase.style.top = 'auto';
                joystickBase.style.bottom = '140px';
                joystickBase.style.transform = 'translateX(-50%)';
            });
            
            function updateJoystick(touch) {
                const rect = joystickBase.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > JOYSTICK_MAX_DISTANCE) {
                    dx = (dx / dist) * JOYSTICK_MAX_DISTANCE;
                    dy = (dy / dist) * JOYSTICK_MAX_DISTANCE;
                }

                joystickKnob.style.left = (12 + dx) + 'px';
                joystickKnob.style.top = (12 + dy) + 'px';

                joystickMagnitude = Math.min(dist / JOYSTICK_MAX_DISTANCE, 1);
                joystickAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            }

        }

        // ============================================================
        // COORDINATE SYSTEM
        // ============================================================

        // Convert world coordinates to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: worldX - camera.x + CANVAS_WIDTH / 2,
                y: worldY - camera.y + CANVAS_HEIGHT / 2
            };
        }

        // Convert screen coordinates to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: screenX + camera.x - CANVAS_WIDTH / 2,
                y: screenY + camera.y - CANVAS_HEIGHT / 2
            };
        }

        // Check if position is within camera view (with padding)
        function isInView(worldX, worldY, padding = 100) {
            const screen = worldToScreen(worldX, worldY);
            return screen.x >= -padding &&
                   screen.x <= CANVAS_WIDTH + padding &&
                   screen.y >= -padding &&
                   screen.y <= CANVAS_HEIGHT + padding;
        }

        // Check if entity should be rendered based on distance from camera
        function shouldRenderEntity(entity, distanceThreshold) {
            const dx = entity.x - camera.x;
            const dy = entity.y - camera.y;
            const distSq = dx * dx + dy * dy;
            return distSq < distanceThreshold * distanceThreshold;
        }

        // ============================================================
        // SECTOR BOUNDARY SYSTEM
        // ============================================================

        function checkSectorBoundary() {
            if (!player) return;

            let transportX = 0;
            let transportY = 0;

            // Check X boundaries
            if (player.x > camera.x + SECTOR_BOUNDS.maxX) {
                // Player exited right side of center sector
                transportX = -3 * SECTOR_WIDTH;
                player.x += transportX;
            } else if (player.x < camera.x + SECTOR_BOUNDS.minX) {
                // Player exited left side of center sector
                transportX = 3 * SECTOR_WIDTH;
                player.x += transportX;
            }

            // Check Y boundaries
            if (player.y > camera.y + SECTOR_BOUNDS.maxY) {
                // Player exited bottom of center sector
                transportY = -3 * SECTOR_HEIGHT;
                player.y += transportY;
            } else if (player.y < camera.y + SECTOR_BOUNDS.minY) {
                // Player exited top of center sector
                transportY = 3 * SECTOR_HEIGHT;
                player.y += transportY;
            }

            // If transport occurred, transport all entities
            if (transportX !== 0 || transportY !== 0) {
                transportEntities(transportX, transportY);
            }
        }

        function transportEntities(offsetX, offsetY) {
            // Transport all entity types
            const entityPools = [
                enemies,
                bullets,
                enemyBullets,
                particles,
                pickups
            ];

            for (const pool of entityPools) {
                for (const entity of pool) {
                    entity.x += offsetX;
                    entity.y += offsetY;
                }
            }

            // Transport floating texts
            for (const text of floatingTexts) {
                text.x += offsetX;
                text.y += offsetY;
            }

            // Transport nebulas (for parallax consistency)
            for (const nebula of nebulas) {
                nebula.x += offsetX;
                nebula.y += offsetY;
            }


            // Update camera to follow player instantly (no lerp during transport)
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;
        }

        // ============================================================
        // CAMERA UPDATE
        // ============================================================

        function updateCamera() {
            if (!player) return;

            // Camera fixed to player (no smoothing)
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;
        }

        // ============================================================
        // GAME LOOP
        // ============================================================

        function gameLoop(timestamp) {
            // Calculate delta time
            if (lastTime === 0) lastTime = timestamp;
            const rawDt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            // Performance monitoring
            frameTimeAccum += rawDt * 1000;
            frameCount++;
            if (frameCount >= 30) {
                avgFrameTime = frameTimeAccum / frameCount;
                lowPerfMode = avgFrameTime > 40;
                frameTimeAccum = 0;
                frameCount = 0;
            }
            
            // Apply time scale (for slow-mo)
            deltaTime = Math.min(rawDt, 0.1) * timeScale;
            
            // Update time scale
            if (slowmoTimer > 0) {
                slowmoTimer -= rawDt * 1000;
                timeScale = SLOWMO_FACTOR;
            } else {
                timeScale = 1;
            }
            
            // Update based on game state
            if (gameState === 'playing') {
                update();
            }
            
            // Always render
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            updateInput();

            gameTime += deltaTime;
            idleTimer += deltaTime;

            // Update wave alert timer
            if (waveAlertActive) {
                waveAlertTimer += deltaTime;
                if (waveAlertTimer >= WAVE_ALERT_DURATION) {
                    waveAlertActive = false;
                }
            }

            // Rebuild spatial grid for collision detection optimization
            spatialGrid.clear();
            for (const e of enemies) {
                const config = ENEMY_TYPES[e.type];
                spatialGrid.insert(e, config.radius + 100);
            }

            // Update performance monitor
            perfMonitor.update(deltaTime);

            // Update player FIRST (so camera can follow in same frame)
            updatePlayer();

            // Update camera immediately after player moves (prevents jitter)
            updateCamera();

            // Check sector boundaries AFTER both are updated
            checkSectorBoundary();

            // Arena closing animation + boundary enforcement
            if (arenaActive) {
                if (arenaCurrentRadius > ARENA_RADIUS) {
                    arenaCurrentRadius -= ARENA_CLOSE_SPEED * deltaTime;
                    if (arenaCurrentRadius < ARENA_RADIUS) {
                        arenaCurrentRadius = ARENA_RADIUS;
                    }
                } else if (bossIncoming) {
                    // Arena finished closing — materialize the boss
                    materializeBoss();
                }
                enforceArenaBoundary();
            }

            // Update spawn system (paused during arena)
            if (!arenaSpawnPaused) {
                updateSpawnSystem();
            }

            // Update other entities
            updateBullets();
            updateDrones();
            updateEnemies();
            updateEnemyBullets();
            updateParticles();
            updateFloatingTexts();
            updatePickups();
            updateWeapons();

            // Update boss
            updateBoss(deltaTime);

            // Check collisions
            checkCollisions();
            
            // Update effects
            updateEffects();

            // Survival time bonus
            score += deltaTime;
            
            // Check milestones
            checkMilestones();

            // Check boss spawn
            checkBossSpawn();

            // Update high score
            if (score > highScore) {
                highScore = Math.floor(score);
                isNewHighScore = true;
            }
        }

        // ============================================================
        // SHIELD ARC STATE MACHINE
        // ============================================================

        function updateShieldArcState(deltaTime) {
            if (!player) return;

            const shieldPercent = player.shield / PLAYER_MAX_SHIELD;
            const isRegenerating = player.shieldRegenTimer >= SHIELD_REGEN_DELAY &&
                                   player.shield < PLAYER_MAX_SHIELD;
            const isLow = shieldPercent <= SHIELD_ARC_LOW_THRESHOLD && shieldPercent > 0;

            // Detect shield damage (shield decreased)
            if (player.shield < player.shieldArcLastValue) {
                // Instant visibility on damage
                player.shieldArcTargetOpacity = SHIELD_ARC_HIT_OPACITY;
                player.shieldArcOpacity = SHIELD_ARC_HIT_OPACITY;
                player.shieldArcFlashTimer = SHIELD_ARC_FLASH_DURATION;
                player.shieldArcFlashColor = '#FFFFFF';
                player.shieldArcIdleTimer = 0;
            }
            player.shieldArcLastValue = player.shield;

            // Update flash timer
            if (player.shieldArcFlashTimer > 0) {
                player.shieldArcFlashTimer -= deltaTime;
                if (player.shieldArcFlashTimer <= 0) {
                    player.shieldArcFlashColor = null;
                }
            }

            // Determine target opacity based on state (priority order)
            if (isLow) {
                // LOW: Always visible with warning
                player.shieldArcTargetOpacity = SHIELD_ARC_HIT_OPACITY;
                player.shieldArcIdleTimer = 0;
            } else if (player.shieldArcFlashTimer > 0) {
                // HIT: Keep visible during flash
                player.shieldArcTargetOpacity = SHIELD_ARC_HIT_OPACITY;
            } else if (isRegenerating) {
                // REGEN: Semi-visible
                player.shieldArcTargetOpacity = SHIELD_ARC_REGEN_OPACITY;
                player.shieldArcIdleTimer = 0;
            } else if (shieldPercent >= 1.0) {
                // FULL: Fade to idle after delay
                player.shieldArcIdleTimer += deltaTime;
                if (player.shieldArcIdleTimer >= SHIELD_ARC_FADE_DELAY) {
                    player.shieldArcTargetOpacity = SHIELD_ARC_IDLE_OPACITY;
                }
            } else {
                // IDLE: Fade after inactivity
                player.shieldArcIdleTimer += deltaTime;
                if (player.shieldArcIdleTimer >= SHIELD_ARC_FADE_DELAY) {
                    player.shieldArcTargetOpacity = SHIELD_ARC_IDLE_OPACITY;
                }
            }

            // Animate opacity with lerp (fast on hit, slow otherwise)
            const opacitySpeed = player.shieldArcFlashTimer > 0 ? 20 : 3;
            player.shieldArcOpacity += (player.shieldArcTargetOpacity - player.shieldArcOpacity) *
                                       opacitySpeed * deltaTime;

            // Update pulse phase for regen/low animation
            player.shieldArcPulsePhase += deltaTime * 5;
        }

        // ============================================================
        // PLAYER
        // ============================================================

        function updatePlayer() {
            if (!player) return;
            
            // Rotation
            let targetRotation = 0;
            if (input.rotateLeft) targetRotation -= ROTATION_SPEED;
            if (input.rotateRight) targetRotation += ROTATION_SPEED;
            
            // Touch joystick rotation - almost instant rotation towards joystick direction
            if (joystickActive && joystickMagnitude > JOYSTICK_DEADZONE) {
                const angleDiff = normalizeAngle(joystickAngle - player.angle);
                if (Math.abs(angleDiff) > JOYSTICK_ROTATION_THRESHOLD) {
                    // Near-instant rotation: lerp 90% of the way each frame
                    player.angle = player.angle + angleDiff * 0.1;
                    targetRotation = 0; // Bypass normal rotation system
                }
            }
            
            player.angle += targetRotation * deltaTime;
            
            // Thrust
            const rad = player.angle * Math.PI / 180;
            let accel = 0;
            
            if (input.thrust) {
                accel = THRUST_ACCEL;
                player.thrusterScale = Math.min(1, player.thrusterScale + deltaTime / 0.08);
                idleTimer = 0;
            } else if (input.reverse) {
                accel = -REVERSE_ACCEL;
                idleTimer = 0;
            }
            
            if (!input.thrust) {
                player.thrusterScale = Math.max(0, player.thrusterScale - deltaTime / 0.12);
            }
            
            player.vx += Math.cos(rad) * accel * deltaTime / PLAYER_MASS;
            player.vy += Math.sin(rad) * accel * deltaTime / PLAYER_MASS;
            
            // Apply drag
            const dragMult = Math.exp(-DRAG_FACTOR * deltaTime);
            player.vx *= dragMult;
            player.vy *= dragMult;
            
            // Clamp speed
            const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (speed > MAX_SPEED) {
                player.vx = (player.vx / speed) * MAX_SPEED;
                player.vy = (player.vy / speed) * MAX_SPEED;
            }
            
            // Position update
            player.x += player.vx * deltaTime;
            player.y += player.vy * deltaTime;

            // Invulnerability
            player.invulnerable = Math.max(0, player.invulnerable - deltaTime);

            // Shield regeneration
            player.shieldFlashTimer = Math.max(0, player.shieldFlashTimer - deltaTime);
            player.shieldRegenTimer += deltaTime;
            if (player.shieldRegenTimer >= SHIELD_REGEN_DELAY && player.shield < PLAYER_MAX_SHIELD) {
                player.shield = Math.min(PLAYER_MAX_SHIELD, player.shield + SHIELD_REGEN_RATE * deltaTime);
            }

            // Update shield arc visibility state
            updateShieldArcState(deltaTime);

            // Auto-fire laser (only when enemy is in aim cone)
            player.fireTimer -= deltaTime;
            if (player.fireTimer <= 0 && hasEnemyInAimCone()) {
                fireBullet();
                player.fireTimer = getWeaponStats().fireRate;
            }

            // Auto-fire rockets (independent system, 360º detection)
            if (!player.rocketTimer) player.rocketTimer = 0;
            player.rocketTimer -= deltaTime;
            const stats = getWeaponStats();
            if (stats.hasRockets && player.rocketTimer <= 0) {
                const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, 600);
                // Include boss as target for rockets
                if (currentBoss) {
                    const bdx = currentBoss.x - player.x;
                    const bdy = currentBoss.y - player.y;
                    if (bdx * bdx + bdy * bdy < 600 * 600) {
                        nearbyEnemies.push(currentBoss);
                    }
                }
                // Check if boss projectiles or homing missiles are in range
                let hasBossTargets = false;
                if (currentBoss) {
                    for (const bp of bossProjectiles) {
                        const dx = bp.x - player.x;
                        const dy = bp.y - player.y;
                        if (dx * dx + dy * dy < 600 * 600) { hasBossTargets = true; break; }
                    }
                    if (!hasBossTargets) {
                        for (const hm of bossHomingMissiles) {
                            if (hm.hp <= 0) continue;
                            const dx = hm.x - player.x;
                            const dy = hm.y - player.y;
                            if (dx * dx + dy * dy < 600 * 600) { hasBossTargets = true; break; }
                        }
                    }
                }
                if (nearbyEnemies.length > 0 || hasBossTargets) {
                    fireRocket(nearbyEnemies, stats);
                    // Cooldown fijo de 1.0s (la habilidad ahora aumenta la ráfaga, no la cadencia)
                    player.rocketTimer = 1.0;
                }
            }

            // Auto-fire lightning (independent system, 360º detection)
            if (!player.lightningTimer) player.lightningTimer = 0;
            player.lightningTimer -= deltaTime;
            if (stats.hasLightning && player.lightningTimer <= 0) {
                const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, stats.lightningRange);
                // Include boss as target for lightning
                if (currentBoss) {
                    const bdx = currentBoss.x - player.x;
                    const bdy = currentBoss.y - player.y;
                    if (bdx * bdx + bdy * bdy < stats.lightningRange * stats.lightningRange) {
                        nearbyEnemies.push(currentBoss);
                    }
                }
                if (nearbyEnemies.length > 0) {
                    fireLightning(nearbyEnemies, stats);
                    player.lightningTimer = stats.lightningCadence;
                }
            }

            // Idle bob
            if (idleTimer > 2) {
                player.bobTimer += deltaTime;
                player.bobOffset = Math.sin(player.bobTimer * 5.2) * 2;
            } else {
                player.bobOffset *= 0.9;
            }
            
            // Spawn thruster particles at fixed interval
            if (player.thrusterScale > 0.3) {
                player.thrusterParticleTimer -= deltaTime;
                if (player.thrusterParticleTimer <= 0) {
                    spawnThrusterParticle();
                    player.thrusterParticleTimer = THRUSTER_PARTICLE_INTERVAL;
                }
            } else {
                player.thrusterParticleTimer = 0;
            }
        }
        
        // Helper function to get computed weapon stats from skill tree
        function getWeaponStats() {
            let damage = 8; // Base damage
            let fireRate = AUTO_FIRE_INTERVAL;
            let pierce = false;
            let spreadCount = 0;
            let hasRockets = false;
            let rocketCount = 1;
            let rocketDamage = 8;
            let hasLaser = false;

            // Laser Cannon branch
            if (unlockedSkills.includes('laser_cannon')) {
                hasLaser = true;
                damage += 4; // Laser cannon adds +4 damage
            }
            if (unlockedSkills.includes('rapid_fire')) {
                fireRate -= 0.1; // Faster fire rate
            }
            if (unlockedSkills.includes('piercing_lens')) {
                pierce = true;
                damage += 4;
            }
            if (unlockedSkills.includes('beam_splitter')) {
                spreadCount = 3;
            }
            fireRate = Math.max(0.1, fireRate); // Minimum fire rate

            // Missile Launcher branch
            let rocketBurstCount = 3; // Misiles por ráfaga (3 normal, 6 con habilidad)
            let rocketExplosionDamage = 12;
            let rocketExplosionRadius = 80;
            let rocketRicochet = false;

            if (unlockedSkills.includes('missile_launcher')) {
                hasRockets = true;
            }
            if (unlockedSkills.includes('homing_guidance')) {
                rocketBurstCount = 6; // Ráfaga doble de misiles
            }
            if (unlockedSkills.includes('armor_piercing')) {
                rocketDamage += 12;
                rocketExplosionDamage += 8;
            }
            if (unlockedSkills.includes('cluster_payload')) {
                rocketRicochet = true; // Spawns mini rockets on impact
            }

            // Lightning Ray branch
            let hasLightning = false;
            let lightningBounces = 6;
            let lightningCadence = 1.2;
            let lightningRange = 225;
            let lightningChainRange = 350;
            let lightningDamage = 16;

            if (unlockedSkills.includes('lightning_ray')) {
                hasLightning = true;
            }
            if (unlockedSkills.includes('chain_amplifier')) {
                lightningBounces = 12;
            }
            if (unlockedSkills.includes('rapid_discharge')) {
                lightningCadence = 0.8;
            }
            if (unlockedSkills.includes('extended_arc')) {
                lightningRange = 650;
                lightningChainRange = 500;
            }

            // Garlic Aura branch
            let hasAura = false;
            let auraRadius = AURA_BASE_RADIUS;
            let auraDamage = AURA_BASE_DAMAGE;
            let auraTickRate = AURA_BASE_TICK_RATE;

            if (unlockedSkills.includes('plasma_field')) {
                hasAura = true;
            }
            if (unlockedSkills.includes('field_expansion')) {
                auraRadius *= 1.5;
            }
            if (unlockedSkills.includes('field_intensity')) {
                auraDamage += 8;
            }
            if (unlockedSkills.includes('field_pulse')) {
                auraTickRate *= 0.67;
            }

            // Alien Drone branch
            let hasDrones = false;
            let droneCount = 1;
            let droneLifetime = 1.5; // Base lifetime in seconds
            let droneHasExplosion = false;

            if (unlockedSkills.includes('alien_drone')) {
                hasDrones = true;
            }
            if (unlockedSkills.includes('drone_duo')) {
                droneCount = 2;
            }
            if (unlockedSkills.includes('drone_duration')) {
                droneLifetime = 3; // Extended lifetime
            }
            if (unlockedSkills.includes('drone_explosion')) {
                droneHasExplosion = true;
            }

            return { damage, fireRate, pierce, spreadCount, hasRockets, rocketCount, rocketDamage, hasLaser, rocketBurstCount, rocketExplosionDamage, rocketExplosionRadius, rocketRicochet, hasLightning, lightningBounces, lightningCadence, lightningRange, lightningChainRange, lightningDamage, hasAura, auraRadius, auraDamage, auraTickRate, hasDrones, droneCount, droneLifetime, droneHasExplosion };
        }

        function hasEnemyInAimCone() {
            const playerRad = player.angle * Math.PI / 180;
            const aimCone = AUTO_AIM_CONE_DEGREES * Math.PI / 180;

            for (const enemy of enemies) {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > AUTO_AIM_MAX_DISTANCE) continue;

                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);

                if (angleDiff <= aimCone) {
                    return true;
                }
            }

            // Also check boss
            if (currentBoss) {
                const dx = currentBoss.x - player.x;
                const dy = currentBoss.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist <= AUTO_AIM_MAX_DISTANCE) {
                    const angleToEnemy = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                    if (angleDiff <= aimCone) return true;
                }
            }
            // Also check boss projectiles
            for (const bp of bossProjectiles) {
                const dx = bp.x - player.x;
                const dy = bp.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > AUTO_AIM_MAX_DISTANCE) continue;
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                if (angleDiff <= aimCone) return true;
            }
            // Also check homing missiles
            for (const hm of bossHomingMissiles) {
                if (hm.hp <= 0) continue;
                const dx = hm.x - player.x;
                const dy = hm.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > AUTO_AIM_MAX_DISTANCE) continue;
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                if (angleDiff <= aimCone) return true;
            }
            // Also check trail nodes
            for (const tn of bossTrailNodes) {
                if (!tn.active || tn.hp <= 0) continue;
                const dx = tn.x - player.x;
                const dy = tn.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > AUTO_AIM_MAX_DISTANCE) continue;
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                if (angleDiff <= aimCone) return true;
            }
            return false;
        }

        function fireBullet() {
            const playerRad = player.angle * Math.PI / 180;
            const noseOffset = PLAYER_SIZE / 2 - PLAYER_PIVOT_OFFSET;
            const noseX = player.x + Math.cos(playerRad) * noseOffset;
            const noseY = player.y + Math.sin(playerRad) * noseOffset;
            
            // Get computed stats from skill tree
            const stats = getWeaponStats();
            const bulletSpeed = BULLET_SPEED;
            
            // Auto-aim: find enemy within frontal cone and predict intercept point
            let targetRad = playerRad;
            let closestDist = Infinity;
            let closestEnemy = null;
            const aimCone = AUTO_AIM_CONE_DEGREES * Math.PI / 180;

            for (const enemy of enemies) {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);

                if (angleDiff <= aimCone && dist < closestDist && dist <= AUTO_AIM_MAX_DISTANCE) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            }

            // Also consider boss as auto-aim target
            if (currentBoss) {
                const dx = currentBoss.x - player.x;
                const dy = currentBoss.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                if (angleDiff <= aimCone && dist < closestDist && dist <= AUTO_AIM_MAX_DISTANCE) {
                    closestDist = dist;
                    closestEnemy = currentBoss;
                }
            }

            // Also consider boss projectiles as auto-aim targets
            for (const bp of bossProjectiles) {
                const dx = bp.x - player.x;
                const dy = bp.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                if (angleDiff <= aimCone && dist < closestDist && dist <= AUTO_AIM_MAX_DISTANCE) {
                    closestDist = dist;
                    closestEnemy = bp;
                }
            }
            // Also consider trail nodes as auto-aim targets
            for (const tn of bossTrailNodes) {
                if (!tn.active || tn.hp <= 0) continue;
                const dx = tn.x - player.x;
                const dy = tn.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                if (angleDiff <= aimCone && dist < closestDist && dist <= AUTO_AIM_MAX_DISTANCE) {
                    closestDist = dist;
                    closestEnemy = tn;
                }
            }
            // Homing missiles get targeting priority (immediate threat)
            // Use separate search — closest missile in cone overrides other targets
            let closestMissileDist = Infinity;
            let closestMissile = null;
            for (const hm of bossHomingMissiles) {
                if (hm.hp <= 0) continue;
                const dx = hm.x - player.x;
                const dy = hm.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);
                if (angleDiff <= aimCone && dist < closestMissileDist && dist <= AUTO_AIM_MAX_DISTANCE) {
                    closestMissileDist = dist;
                    closestMissile = hm;
                }
            }
            if (closestMissile) {
                closestEnemy = closestMissile;
                closestDist = closestMissileDist;
            }

            // Calculate intercept point (lead the target)
            if (closestEnemy) {
                const evx = closestEnemy.vx || 0;
                const evy = closestEnemy.vy || 0;

                // Iterative approximation for intercept point (2 iterations for accuracy)
                let predictedX = closestEnemy.x;
                let predictedY = closestEnemy.y;

                for (let i = 0; i < 2; i++) {
                    const dx = predictedX - noseX;
                    const dy = predictedY - noseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const timeToTarget = dist / bulletSpeed;

                    predictedX = closestEnemy.x + evx * timeToTarget;
                    predictedY = closestEnemy.y + evy * timeToTarget;
                }

                targetRad = Math.atan2(predictedY - noseY, predictedX - noseX);
            }
            
            // Fire main weapon (LASER or BEAM if pierce unlocked)
            if (stats.pierce) {
                // Pierce/Beam shot - replaces normal laser
                const bullet = pools.bullet.acquire();
                bullet.x = noseX;
                bullet.y = noseY;
                bullet.vx = Math.cos(targetRad) * (bulletSpeed * 1.2);
                bullet.vy = Math.sin(targetRad) * (bulletSpeed * 1.2);
                bullet.life = BULLET_LIFETIME * 1.5;
                bullet.damage = stats.damage;
                bullet.type = 'beam';
                bullet.color = COLORS.BULLET;
                bullet.piercing = true;
                bullet.hitEnemies = new Set();
                bullets.push(bullet);
            } else {
                // Normal laser shot
                const bullet = pools.bullet.acquire();
                bullet.x = noseX;
                bullet.y = noseY;
                bullet.vx = Math.cos(targetRad) * bulletSpeed;
                bullet.vy = Math.sin(targetRad) * bulletSpeed;
                bullet.life = BULLET_LIFETIME;
                bullet.damage = stats.damage;
                bullet.type = 'laser';
                bullet.color = SKILL_TREE['laser_cannon'].color;
                bullet.piercing = false;
                bullets.push(bullet);
            }

            // Fire SPREAD if unlocked (additional bullets in cone, excluding center)
            if (stats.spreadCount > 0) {
                const spreadAngle = 8 + (stats.spreadCount - 3) * 3; // degrees (reduced angle)
                const mainColor = SKILL_TREE['laser_cannon'].color;

                for (let i = 0; i < stats.spreadCount; i++) {
                    // Skip the middle bullet (already fired by main weapon)
                    const middleIndex = (stats.spreadCount - 1) / 2;
                    if (i === middleIndex) continue;

                    const offset = ((i / (stats.spreadCount - 1)) - 0.5) * 2 * (spreadAngle * Math.PI / 180);
                    const angle = targetRad + offset;
                    const spreadBullet = pools.bullet.acquire();
                    spreadBullet.x = noseX;
                    spreadBullet.y = noseY;
                    spreadBullet.vx = Math.cos(angle) * bulletSpeed;
                    spreadBullet.vy = Math.sin(angle) * bulletSpeed;
                    spreadBullet.life = BULLET_LIFETIME;
                    spreadBullet.damage = stats.damage;
                    spreadBullet.type = 'laser';
                    spreadBullet.color = mainColor;
                    spreadBullet.piercing = stats.pierce;

                    // Add hitEnemies array if piercing
                    if (stats.pierce) {
                        spreadBullet.hitEnemies = new Set();
                    }

                    bullets.push(spreadBullet);
                }
            }
        }

        // Fire rockets in burst (360º enemy detection)
        function fireRocket(nearbyEnemies, stats) {
            // Find closest enemy to aim at
            let closestEnemy = null;
            let closestDist = Infinity;
            for (const e of nearbyEnemies) {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = e;
                }
            }
            // Also consider boss projectiles for rocket targeting
            for (const bp of bossProjectiles) {
                const dx = bp.x - player.x;
                const dy = bp.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist && dist <= 600) {
                    closestDist = dist;
                    closestEnemy = bp;
                }
            }
            // Also consider trail nodes for rocket targeting
            for (const tn of bossTrailNodes) {
                if (!tn.active || tn.hp <= 0) continue;
                const dx = tn.x - player.x;
                const dy = tn.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist && dist <= 600) {
                    closestDist = dist;
                    closestEnemy = tn;
                }
            }
            // Homing missiles get targeting priority for rockets
            let closestRocketMissileDist = Infinity;
            let closestRocketMissile = null;
            for (const hm of bossHomingMissiles) {
                if (hm.hp <= 0) continue;
                const dx = hm.x - player.x;
                const dy = hm.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestRocketMissileDist && dist <= 600) {
                    closestRocketMissileDist = dist;
                    closestRocketMissile = hm;
                }
            }
            if (closestRocketMissile) {
                closestEnemy = closestRocketMissile;
                closestDist = closestRocketMissileDist;
            }

            if (!closestEnemy) return;

            // Disparar ráfaga de misiles con delays
            const burstCount = stats.rocketBurstCount; // 3 normal, 6 con habilidad
            const delayBetweenRockets = 50; // ms entre cada misil de la ráfaga
            const angleSpread = 0.4; // Dispersión angular total de la ráfaga (radianes)

            for (let i = 0; i < burstCount; i++) {
                setTimeout(() => {
                    // Recalcular posición del enemigo para cada misil (puede haberse movido)
                    const currentDx = closestEnemy.x - player.x;
                    const currentDy = closestEnemy.y - player.y;
                    const currentDist = Math.sqrt(currentDx * currentDx + currentDy * currentDy);

                    // Predict enemy position based on velocity
                    const rocketSpeed = 600;
                    const timeToTarget = currentDist / rocketSpeed;
                    const predictedX = closestEnemy.x + (closestEnemy.vx || 0) * timeToTarget * 0.5;
                    const predictedY = closestEnemy.y + (closestEnemy.vy || 0) * timeToTarget * 0.5;

                    // Ángulo base hacia el objetivo
                    const baseAngle = Math.atan2(predictedY - player.y, predictedX - player.x);

                    // Calcular offset angular para efecto de ráfaga
                    // Distribuye los misiles en un abanico
                    const angleOffset = (i / (burstCount - 1) - 0.5) * angleSpread + (Math.random() - 0.5) * 0.1;
                    const angleToTarget = baseAngle + (burstCount > 1 ? angleOffset : 0);

                    const rocket = pools.bullet.acquire();
                    rocket.x = player.x;
                    rocket.y = player.y;

                    // === COMPORTAMIENTO DE MISIL REALISTA ===
                    // Fase 1: Impulso inicial
                    const initialSpeed = 1000;
                    const boostDuration = 0.3;

                    // Fase 2: Navegación (girando)
                    const cruiseSpeed = 150;

                    // Fase 3: Aproximación final
                    const finalSpeed = 1200;
                    const angleThreshold = 10.2;

                    // Configuración del misil
                    rocket.currentSpeed = initialSpeed;
                    rocket.targetSpeed = initialSpeed;
                    rocket.initialSpeed = initialSpeed;
                    rocket.cruiseSpeed = cruiseSpeed;
                    rocket.finalSpeed = finalSpeed;
                    rocket.boostTimer = boostDuration;
                    rocket.angleThreshold = angleThreshold;
                    rocket.targetAngle = angleToTarget;
                    rocket.hasCompletedBoostPhase = false;

                    // Spawn perpendicular al objetivo con variación por misil
                    const spawnAngle = angleToTarget - Math.PI;
                    rocket.vx = Math.cos(spawnAngle) * initialSpeed;
                    rocket.vy = Math.sin(spawnAngle) * initialSpeed;

                    // Propiedades estándar
                    rocket.life = 2;
                    rocket.damage = stats.rocketDamage;
                    rocket.explosionDamage = stats.rocketExplosionDamage;
                    rocket.explosionRadius = stats.rocketExplosionRadius;
                    rocket.hasRicochet = stats.rocketRicochet;
                    rocket.type = 'rocket';
                    rocket.color = COLORS.PLAYER;
                    rocket.piercing = false;
                    rocket.turnRate = 300;
                    rocket.trail = [];
                    bullets.push(rocket);
                }, i * delayBetweenRockets);
            }
        }

        function fireLightning(nearbyEnemies, stats) {
            // Find closest enemy to start the chain
            let closestEnemy = null;
            let closestDist = Infinity;

            for (const e of nearbyEnemies) {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = e;
                }
            }
            // Also consider boss projectiles for lightning targeting
            for (const bp of bossProjectiles) {
                const dx = bp.x - player.x;
                const dy = bp.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist && dist <= stats.lightningRange) {
                    closestDist = dist;
                    closestEnemy = bp;
                }
            }
            // Also consider homing missiles for lightning initial target
            for (const hm of bossHomingMissiles) {
                const dx = hm.x - player.x;
                const dy = hm.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist && dist <= stats.lightningRange) {
                    closestDist = dist;
                    closestEnemy = hm;
                }
            }
            // Also consider trail nodes for lightning initial target
            for (const tn of bossTrailNodes) {
                if (!tn.active || tn.hp <= 0) continue;
                const dx = tn.x - player.x;
                const dy = tn.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist && dist <= stats.lightningRange) {
                    closestDist = dist;
                    closestEnemy = tn;
                }
            }

            if (!closestEnemy) return;

            // Build the lightning chain - collect all targets first, then apply damage
            const chainPoints = [{ x: player.x, y: player.y }];
            const chainTargets = [];
            const hitEnemies = new Set();
            let currentTarget = closestEnemy;
            let bounceCount = 0;

            // Phase 1: Build the chain (find all targets)
            while (currentTarget && bounceCount < stats.lightningBounces) {
                chainPoints.push({ x: currentTarget.x, y: currentTarget.y });
                chainTargets.push(currentTarget);
                hitEnemies.add(currentTarget);
                bounceCount++;

                // Find next closest enemy within chain range from current target
                const lastHitX = currentTarget.x;
                const lastHitY = currentTarget.y;

                let nextTarget = null;
                let nextDist = Infinity;

                for (const candidate of enemies) {
                    if (hitEnemies.has(candidate)) continue;
                    if (candidate.hp <= 0) continue;

                    const dx = candidate.x - lastHitX;
                    const dy = candidate.y - lastHitY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= stats.lightningChainRange && dist < nextDist) {
                        nextDist = dist;
                        nextTarget = candidate;
                    }
                }

                // Also consider boss as chain target
                if (currentBoss && !hitEnemies.has(currentBoss) && currentBoss.hp > 0) {
                    const dx = currentBoss.x - lastHitX;
                    const dy = currentBoss.y - lastHitY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= stats.lightningChainRange && dist < nextDist) {
                        nextDist = dist;
                        nextTarget = currentBoss;
                    }
                }
                // Also consider boss projectiles as chain targets
                for (const bp of bossProjectiles) {
                    if (hitEnemies.has(bp)) continue;
                    if (bp.hp <= 0) continue;
                    const dx = bp.x - lastHitX;
                    const dy = bp.y - lastHitY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= stats.lightningChainRange && dist < nextDist) {
                        nextDist = dist;
                        nextTarget = bp;
                    }
                }
                // Also consider homing missiles as chain targets
                for (const hm of bossHomingMissiles) {
                    if (hitEnemies.has(hm)) continue;
                    if (hm.hp <= 0) continue;
                    const dx = hm.x - lastHitX;
                    const dy = hm.y - lastHitY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= stats.lightningChainRange && dist < nextDist) {
                        nextDist = dist;
                        nextTarget = hm;
                    }
                }
                // Also consider trail nodes as chain targets
                for (const tn of bossTrailNodes) {
                    if (!tn.active || tn.hp <= 0) continue;
                    if (hitEnemies.has(tn)) continue;
                    const dx = tn.x - lastHitX;
                    const dy = tn.y - lastHitY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= stats.lightningChainRange && dist < nextDist) {
                        nextDist = dist;
                        nextTarget = tn;
                    }
                }

                currentTarget = nextTarget;
            }

            // Phase 2: Apply damage to all targets and kill dead enemies
            const enemiesToKill = [];
            for (const target of chainTargets) {
                if (target === currentBoss) {
                    // Boss target — use damageBoss
                    damageBoss(stats.lightningDamage);
                    spawnRing(target.x, target.y, SKILL_TREE['lightning_ray'].color);
                } else if (bossProjectiles.includes(target)) {
                    // Boss projectile target
                    target.hp -= stats.lightningDamage;
                    spawnRing(target.x, target.y, SKILL_TREE['lightning_ray'].color);
                    if (target.hp <= 0) {
                        const idx = bossProjectiles.indexOf(target);
                        if (idx !== -1) bossProjectiles.splice(idx, 1);
                    }
                } else if (bossHomingMissiles.includes(target)) {
                    // Homing missile target
                    target.hp -= stats.lightningDamage;
                    spawnRing(target.x, target.y, SKILL_TREE['lightning_ray'].color);
                } else if (bossTrailNodes.includes(target)) {
                    // Trail node target
                    target.hp -= stats.lightningDamage;
                    spawnRing(target.x, target.y, SKILL_TREE['lightning_ray'].color);
                    if (target.hp <= 0) {
                        const idx = bossTrailNodes.indexOf(target);
                        if (idx !== -1) destroyTrailNode(idx);
                    }
                } else {
                    const config = ENEMY_TYPES[target.type];
                    target.hp -= stats.lightningDamage;

                    // Visual feedback
                    spawnFloatingText(target.x, target.y - config.radius,
                        stats.lightningDamage.toString(), SKILL_TREE['lightning_ray'].color);
                    spawnRing(target.x, target.y, SKILL_TREE['lightning_ray'].color);

                    if (target.hp <= 0) {
                        enemiesToKill.push(target);
                    }
                }
            }

            // Phase 3: Kill dead enemies (after chain is complete)
            for (const target of enemiesToKill) {
                const enemyIndex = enemies.indexOf(target);
                if (enemyIndex !== -1) {
                    killEnemy(target, enemyIndex);
                }
            }

            // Lightning also damages boss projectiles near chain points
            if (currentBoss && bossProjectiles.length > 0) {
                for (let cp = 1; cp < chainPoints.length; cp++) {
                    const pt = chainPoints[cp];
                    for (let bi = bossProjectiles.length - 1; bi >= 0; bi--) {
                        const bp = bossProjectiles[bi];
                        const dx = bp.x - pt.x;
                        const dy = bp.y - pt.y;
                        if (dx * dx + dy * dy < 60 * 60) {
                            bp.hp -= stats.lightningDamage;
                            spawnRing(bp.x, bp.y, SKILL_TREE['lightning_ray'].color, 15);
                            if (bp.hp <= 0) {
                                bossProjectiles.splice(bi, 1);
                            }
                        }
                    }
                }
            }

            // Lightning also damages homing missiles near chain points
            if (currentBoss && bossHomingMissiles.length > 0) {
                for (let cp = 1; cp < chainPoints.length; cp++) {
                    const pt = chainPoints[cp];
                    for (let mi = bossHomingMissiles.length - 1; mi >= 0; mi--) {
                        const m = bossHomingMissiles[mi];
                        const dx = m.x - pt.x;
                        const dy = m.y - pt.y;
                        if (dx * dx + dy * dy < 60 * 60) {
                            m.hp -= stats.lightningDamage;
                            spawnRing(m.x, m.y, SKILL_TREE['lightning_ray'].color, 15);
                        }
                    }
                }
            }

            // Lightning also damages trail nodes near chain points
            if (currentBoss && bossTrailNodes.length > 0) {
                for (let cp = 1; cp < chainPoints.length; cp++) {
                    const pt = chainPoints[cp];
                    for (let ni = bossTrailNodes.length - 1; ni >= 0; ni--) {
                        const node = bossTrailNodes[ni];
                        if (!node.active || node.hp <= 0) continue;
                        const dx = node.x - pt.x;
                        const dy = node.y - pt.y;
                        if (dx * dx + dy * dy < 60 * 60) {
                            node.hp -= stats.lightningDamage;
                            spawnRing(node.x, node.y, SKILL_TREE['lightning_ray'].color, 15);
                            if (node.hp <= 0) {
                                destroyTrailNode(ni);
                            }
                        }
                    }
                }
            }

            // Create lightning visual effect with pre-computed zigzag
            if (chainPoints.length > 1) {
                // Generate zigzag path between each pair of points
                const zigzagPoints = [];
                for (let i = 0; i < chainPoints.length - 1; i++) {
                    const start = chainPoints[i];
                    const end = chainPoints[i + 1];

                    // Add start point
                    if (i === 0) zigzagPoints.push({ x: start.x, y: start.y });

                    // Calculate distance and direction
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Number of zigzag segments based on distance
                    const segments = Math.max(3, Math.floor(dist / 30));
                    const perpX = -dy / dist;
                    const perpY = dx / dist;

                    // Generate zigzag points
                    for (let s = 1; s < segments; s++) {
                        const t = s / segments;
                        const baseX = start.x + dx * t;
                        const baseY = start.y + dy * t;

                        // Alternating zigzag with random offset (narrower)
                        const zigzagAmount = (Math.random() * 12 + 6) * (s % 2 === 0 ? 1 : -1);
                        zigzagPoints.push({
                            x: baseX + perpX * zigzagAmount,
                            y: baseY + perpY * zigzagAmount
                        });
                    }

                    // Add end point
                    zigzagPoints.push({ x: end.x, y: end.y });
                }

                lightningEffects.push({
                    points: zigzagPoints,
                    life: 0.2,
                    maxLife: 0.2,
                    color: SKILL_TREE['lightning_ray'].color
                });
            }
        }

        function spawnAlienDrone(x, y) {
            const stats = getWeaponStats();
            if (!stats.hasDrones) return;

            for (let i = 0; i < stats.droneCount; i++) {
                const drone = pools.drone.acquire();

                // Spawn at enemy death position with slight offset for multiple drones
                const angleOffset = stats.droneCount > 1 ? (i / stats.droneCount) * Math.PI * 2 : 0;
                drone.x = x + Math.cos(angleOffset) * 10;
                drone.y = y + Math.sin(angleOffset) * 10;

                // Initial velocity pointing outward briefly
                drone.vx = Math.cos(angleOffset) * 100;
                drone.vy = Math.sin(angleOffset) * 100;
                drone.angle = angleOffset * 180 / Math.PI;

                drone.life = stats.droneLifetime;
                drone.damage = DRONE_BASE_DAMAGE;
                drone.hasExplosion = stats.droneHasExplosion;
                drone.trail = [];
                drone.color = COLORS.PLAYER;

                drones.push(drone);
            }
        }

        function spawnThrusterParticle() {
            const rad = (player.angle + 180) * Math.PI / 180;
            const spread = (Math.random() - 0.5) * 0.1;
            const tailOffset = 20 + PLAYER_PIVOT_OFFSET;

            const p = pools.particle.acquire();
            p.x = player.x + Math.cos(rad) * tailOffset;
            p.y = player.y + Math.sin(rad) * tailOffset;
            p.vx = Math.cos(rad + spread) * (400 + Math.random() * 5);
            p.vy = Math.sin(rad + spread) * (400 + Math.random() * 5);
            p.life = 0.2 + Math.random() * 0.2;
            p.maxLife = 0.6;
            p.size = 12 + Math.random() * 15;
            p.color = COLORS.PLAYER;
            p.type = 'thruster';
            p.rotation = Math.random() * Math.PI * 2;
            p.rotationSpeed = (Math.random() - 0.5) * 2;

            particles.push(p);
        }
        
        // ============================================================
        // BULLETS
        // ============================================================
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                
                // Rocket and mini-rocket homing behavior
                if (b.type === 'rocket' || b.type === 'mini_rocket') {
                    // Find nearest enemy using spatial grid
                    let nearestDist = Infinity;
                    let nearestEnemy = null;
                    const nearbyEnemies = spatialGrid.queryRadius(b.x, b.y, 600);
                    for (const e of nearbyEnemies) {
                        const dx = e.x - b.x;
                        const dy = e.y - b.y;
                        const distSq = dx * dx + dy * dy;
                        if (distSq < nearestDist * nearestDist) {
                            nearestDist = Math.sqrt(distSq);
                            nearestEnemy = e;
                        }
                    }
                    // Also consider boss for rocket homing
                    if (currentBoss) {
                        const dx = currentBoss.x - b.x;
                        const dy = currentBoss.y - b.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist && dist < 600) {
                            nearestDist = dist;
                            nearestEnemy = currentBoss;
                        }
                    }
                    // Also consider boss projectiles for rocket homing
                    for (const bp of bossProjectiles) {
                        const dx = bp.x - b.x;
                        const dy = bp.y - b.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist && dist < 600) {
                            nearestDist = dist;
                            nearestEnemy = bp;
                        }
                    }
                    // Also consider trail nodes for rocket homing
                    for (const tn of bossTrailNodes) {
                        if (!tn.active || tn.hp <= 0) continue;
                        const dx = tn.x - b.x;
                        const dy = tn.y - b.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist && dist < 600) {
                            nearestDist = dist;
                            nearestEnemy = tn;
                        }
                    }
                    // Homing missiles get targeting priority for rockets
                    let closestHomingMissile = null;
                    let closestHomingDist = Infinity;
                    for (const hm of bossHomingMissiles) {
                        if (hm.hp <= 0) continue;
                        const dx = hm.x - b.x;
                        const dy = hm.y - b.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < closestHomingDist && dist < 600) {
                            closestHomingDist = dist;
                            closestHomingMissile = hm;
                        }
                    }
                    if (closestHomingMissile) {
                        nearestDist = closestHomingDist;
                        nearestEnemy = closestHomingMissile;
                    }

                    if (nearestEnemy) {
                        // Predict enemy position based on velocity
                        const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                        const timeToTarget = nearestDist / Math.max(speed, 100);
                        const predictedX = nearestEnemy.x + (nearestEnemy.vx || 0) * timeToTarget * 0.7;
                        const predictedY = nearestEnemy.y + (nearestEnemy.vy || 0) * timeToTarget * 0.7;

                        const dx = predictedX - b.x;
                        const dy = predictedY - b.y;
                        const targetAngle = Math.atan2(dy, dx);
                        const currentAngle = Math.atan2(b.vy, b.vx);
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                        // === LÓGICA DE MISIL CON 3 FASES (SIN REINICIAR EN NUEVOS OBJETIVOS) ===
                        
                        // Actualizar timer del impulso inicial (SOLO la primera vez)
                        if (b.boostTimer > 0) {
                            b.boostTimer -= deltaTime;
                            if (b.boostTimer <= 0) {
                                // 👈 Cambiar a velocidad de navegación (fase 2) - SOLO UNA VEZ
                                b.currentSpeed = b.cruiseSpeed;
                                b.hasCompletedBoostPhase = true; // 👈 MARCAR QUE COMPLETÓ FASE DE FRENADO
                            }
                        }
                        
                        // SOLO aplicar lógica de aceleración si está fuera del boost inicial
                        // Esto evita que se reinicie el frenado con nuevos objetivos
                        if (b.hasCompletedBoostPhase) {
                            const angleToTargetRad = Math.abs(angleDiff);
                            
                            // Fase 3: Aceleración final si apunta al objetivo
                            if (angleToTargetRad < b.angleThreshold) {
                                b.targetSpeed = b.finalSpeed; // 👈 VELOCIDAD FINAL
                            } else {
                                b.targetSpeed = b.cruiseSpeed; // 👈 VELOCIDAD DE NAVEGACIÓN
                            }
                            
                            // Transición suave de velocidad
                            const speedTransitionRate = 5.0; // 👈 VELOCIDAD DE TRANSICIÓN (más rápido = más abrupto)
                            if (Math.abs(b.currentSpeed - b.targetSpeed) > 1) {
                                const speedChange = (b.targetSpeed - b.currentSpeed) * speedTransitionRate * deltaTime;
                                b.currentSpeed += speedChange;
                            }
                        }
                        
                        // Aplicar giro
                        const maxTurn = (b.turnRate * Math.PI / 180) * deltaTime;
                        const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                        const newAngle = currentAngle + turn;
                        
                        // Aplicar velocidad actual
                        b.vx = Math.cos(newAngle) * b.currentSpeed;
                        b.vy = Math.sin(newAngle) * b.currentSpeed;
                    }

                    // Store trail positions for line rendering
                    if (!b.trail) b.trail = [];
                    const isMini = b.type === 'mini_rocket';
                    const maxTrailLength = isMini ? 25 : 50;
                    b.trail.unshift({ x: b.x, y: b.y });
                    if (b.trail.length > maxTrailLength) {
                        b.trail.pop();
                    }
                }

                // Piercing laser particles (beam or laser with piercing)
                if ((b.type === 'beam' || (b.type === 'laser' && b.piercing))) {
                    const totalEntities = bullets.length + enemies.length;
                    const beamTrailChance = totalEntities > 100 ? 0.3 : 0.6;
                    if (Math.random() < beamTrailChance) {
                        const angle = Math.atan2(b.vy, b.vx);
                        const perpAngle = angle + Math.PI / 2;
                        const offset = (Math.random() - 0.5) * 8;
                        const p = pools.particle.acquire();
                        p.x = b.x + Math.cos(perpAngle) * offset;
                        p.y = b.y + Math.sin(perpAngle) * offset;
                        p.vx = (Math.random() - 0.5) * 20 - Math.cos(angle) * 30;
                        p.vy = (Math.random() - 0.5) * 20 - Math.sin(angle) * 30;
                        p.life = 0.15;
                        p.maxLife = 0.15;
                        p.size = 2 + Math.random() * 2;
                        p.color = b.color || COLORS.BULLET;
                        p.type = 'piercing_trail';
                        particles.push(p);
                    }
                }

                // Store previous position for swept collision detection
                b.prevX = b.x;
                b.prevY = b.y;

                b.x += b.vx * deltaTime;
                b.y += b.vy * deltaTime;
                b.life -= deltaTime;

                // Remove bullets that are too far from camera or expired
                // Allow bullets to travel across adjacent sectors
                const distFromCamera = Math.sqrt(
                    Math.pow(b.x - camera.x, 2) +
                    Math.pow(b.y - camera.y, 2)
                );
                const maxDistance = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 3; // 5760px

                if (b.life <= 0 || distFromCamera > maxDistance) {
                    if (b.life <= 0) explodePlayerRocket(b);
                    pools.bullet.release(b);
                    fastRemove(bullets, i);
                }
            }
        }

        // ============================================================
        // ALIEN DRONES
        // ============================================================

        function updateDrones() {
            const droneColor = COLORS.PLAYER;

            for (let i = drones.length - 1; i >= 0; i--) {
                const d = drones[i];

                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;

                for (const e of enemies) {
                    const dx = e.x - d.x;
                    const dy = e.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = e;
                    }
                }
                // Also consider boss for drone targeting
                if (currentBoss) {
                    const dx = currentBoss.x - d.x;
                    const dy = currentBoss.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = currentBoss;
                    }
                }
                // Also consider boss projectiles for drone targeting
                for (const bp of bossProjectiles) {
                    const dx = bp.x - d.x;
                    const dy = bp.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = bp;
                    }
                }
                // Also consider homing missiles for drone targeting
                for (const hm of bossHomingMissiles) {
                    const dx = hm.x - d.x;
                    const dy = hm.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = hm;
                    }
                }
                // Also consider trail nodes for drone targeting
                for (const tn of bossTrailNodes) {
                    if (!tn.active || tn.hp <= 0) continue;
                    const dx = tn.x - d.x;
                    const dy = tn.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = tn;
                    }
                }

                // Homing behavior towards nearest enemy
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - d.x;
                    const dy = nearestEnemy.y - d.y;
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(d.vy, d.vx);

                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    const maxTurn = (DRONE_TURN_RATE * Math.PI / 180) * deltaTime;
                    const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                    const newAngle = currentAngle + turn;

                    d.vx = Math.cos(newAngle) * DRONE_SPEED;
                    d.vy = Math.sin(newAngle) * DRONE_SPEED;
                    d.angle = newAngle * 180 / Math.PI;
                }

                // Store trail for visual effect
                d.trail.unshift({ x: d.x, y: d.y });
                if (d.trail.length > 8) d.trail.pop();

                // Update position
                d.x += d.vx * deltaTime;
                d.y += d.vy * deltaTime;
                d.life -= deltaTime;

                // Check collision with enemies
                let hitEnemy = null;
                let hitBoss = false;
                for (const e of enemies) {
                    const config = ENEMY_TYPES[e.type];
                    const dx = e.x - d.x;
                    const dy = e.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < config.radius + DRONE_SIZE) {
                        hitEnemy = e;
                        break;
                    }
                }
                // Check trail node collision for drones
                let hitTrailNode = null;
                let hitTrailNodeIdx = -1;
                if (!hitEnemy) {
                    for (let ni = 0; ni < bossTrailNodes.length; ni++) {
                        const tn = bossTrailNodes[ni];
                        if (!tn.active || tn.hp <= 0) continue;
                        const dx = tn.x - d.x;
                        const dy = tn.y - d.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < tn.radius + DRONE_SIZE) {
                            hitTrailNode = tn;
                            hitTrailNodeIdx = ni;
                            break;
                        }
                    }
                }
                // Check boss collision for drones
                if (!hitEnemy && !hitTrailNode && currentBoss) {
                    const dx = currentBoss.x - d.x;
                    const dy = currentBoss.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < currentBoss.size * 0.85 + DRONE_SIZE) {
                        hitBoss = true;
                    }
                }

                if (hitEnemy || hitBoss || hitTrailNode) {
                    if (hitTrailNode) {
                        hitTrailNode.hp -= d.damage;
                        spawnRing(hitTrailNode.x, hitTrailNode.y, droneColor);
                        if (hitTrailNode.hp <= 0) {
                            destroyTrailNode(hitTrailNodeIdx);
                        }
                    } else if (hitBoss) {
                        damageBoss(d.damage);
                        spawnRing(currentBoss.x, currentBoss.y, droneColor);
                    } else {
                        const config = ENEMY_TYPES[hitEnemy.type];

                        // Apply direct damage
                        hitEnemy.hp -= d.damage;
                        spawnFloatingText(hitEnemy.x, hitEnemy.y - config.radius, d.damage.toString(), droneColor);
                        spawnRing(hitEnemy.x, hitEnemy.y, droneColor);

                        // Check if enemy dies from direct hit
                        if (hitEnemy.hp <= 0) {
                            const enemyIndex = enemies.indexOf(hitEnemy);
                            if (enemyIndex !== -1) killEnemy(hitEnemy, enemyIndex);
                        }
                    }

                    // Explosion AoE damage
                    if (d.hasExplosion) {
                        spawnRing(d.x, d.y, droneColor, 30);

                        // Find all enemies in explosion radius
                        for (const e of enemies) {
                            if (e === hitEnemy) continue; // Already damaged
                            const edx = e.x - d.x;
                            const edy = e.y - d.y;
                            const eDist = Math.sqrt(edx * edx + edy * edy);

                            if (eDist < DRONE_EXPLOSION_RADIUS) {
                                const eConfig = ENEMY_TYPES[e.type];
                                e.hp -= DRONE_EXPLOSION_DAMAGE;
                                spawnFloatingText(e.x, e.y - eConfig.radius, DRONE_EXPLOSION_DAMAGE.toString(), droneColor);

                                if (e.hp <= 0) {
                                    const idx = enemies.indexOf(e);
                                    if (idx !== -1) killEnemy(e, idx);
                                }
                            }
                        }
                        // Boss AoE damage from drone explosion
                        if (currentBoss && !hitBoss) {
                            const bdx = currentBoss.x - d.x;
                            const bdy = currentBoss.y - d.y;
                            if (bdx * bdx + bdy * bdy < DRONE_EXPLOSION_RADIUS * DRONE_EXPLOSION_RADIUS) {
                                damageBoss(DRONE_EXPLOSION_DAMAGE);
                            }
                        }
                    } else {
                        // Small impact effect
                        spawnRing(d.x, d.y, droneColor);
                    }

                    // Remove drone after impact
                    pools.drone.release(d);
                    fastRemove(drones, i);
                    continue;
                }

                // Remove expired drones or too far from camera
                const distFromCamera = Math.sqrt(
                    Math.pow(d.x - camera.x, 2) +
                    Math.pow(d.y - camera.y, 2)
                );

                if (d.life <= 0 || distFromCamera > CULLING_DISTANCES.drones) {
                    pools.drone.release(d);
                    fastRemove(drones, i);
                }
            }
        }

        // ============================================================
        // ENEMIES
        // ============================================================
        // ARENA SYSTEM (Boss Fights)
        // ============================================================

        function activateArena(centerX, centerY) {
            arenaActive = true;
            arenaCenter = { x: centerX, y: centerY };
            arenaCurrentRadius = ARENA_START_RADIUS;
            arenaSpawnPaused = true;

            // Clear all enemies WITHOUT giving XP/score (but show death explosion)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const config = ENEMY_TYPES[e.type];
                spawnRing(e.x, e.y, config.color, 40);
                pools.enemy.release(e);
            }
            enemies.length = 0;

            // Clear enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                pools.enemyBullet.release(enemyBullets[i]);
            }
            enemyBullets.length = 0;

            spawnFloatingText(player.x, player.y - 50, 'ARENA ACTIVATED', '#00CCFF');
            spawnFloatingText(player.x, player.y, 'BOSS FIGHT', '#00CCFF');
        }

        function deactivateArena() {
            arenaActive = false;
            arenaSpawnPaused = false;
            spawnFloatingText(player.x, player.y - 50, 'ARENA CLEARED', '#39FF14');
        }

        function enforceArenaBoundary() {
            if (!player || !arenaActive) return;

            const dx = player.x - arenaCenter.x;
            const dy = player.y - arenaCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = arenaCurrentRadius - 30;

            if (dist > maxDist) {
                // Push player back to boundary
                const nx = dx / dist;
                const ny = dy / dist;
                player.x = arenaCenter.x + nx * maxDist;
                player.y = arenaCenter.y + ny * maxDist;

                // Bounce velocity inward
                player.vx *= -0.3;
                player.vy *= -0.3;

                // Deal damage to player
                if (player.invulnerable <= 0) {
                    damagePlayer();
                }
            }
        }

        // ============================================================
        // BOSS FUNCTIONS
        // ============================================================

        function calculateBossHP(bossIndex) {
            const baseHP = BOSS_BASE_HP[bossIndex];
            const levelMultiplier = Math.max(0.5, 1 + (playerLevel - BOSS_SPAWN_LEVELS[bossIndex]) * 0.15);
            const prog = loadProgression();
            const numWeapons = WEAPON_IDS.filter(wid => prog.unlockedWeapons[wid]).length;
            const weaponMultiplier = 1 + (numWeapons * 0.20);
            return Math.max(baseHP, Math.floor(baseHP * levelMultiplier * weaponMultiplier));
        }

        function spawnBoss(bossIndex) {
            if (currentBoss || bossIncoming) return;

            activateArena(player.x, player.y);
            bossIncoming = { bossIndex: bossIndex, timer: 0 };

            triggerFlash('#FF0000', 0.3, 300);
            triggerSlowmo(500);
            spawnFloatingText(player.x, player.y - 60, '\u26A0 BOSS INCOMING \u26A0', BOSS_COLORS[bossIndex]);
        }

        function materializeBoss() {
            if (!bossIncoming) return;
            const bossIndex = bossIncoming.bossIndex;
            bossIncoming = null;

            const calculatedHP = calculateBossHP(bossIndex);
            currentBoss = {
                type: BOSS_TYPES[bossIndex],
                index: bossIndex,
                name: BOSS_NAMES[bossIndex],
                color: BOSS_COLORS[bossIndex],
                x: arenaCenter.x,
                y: arenaCenter.y,
                hp: calculatedHP,
                maxHp: calculatedHP,
                phase: 1,
                rotation: 0,
                patternTimer: 0,
                currentPattern: null,
                oscillationTimer: 0,
                size: 80 + bossIndex * 15,
                weaponUnlock: BOSS_WEAPON_UNLOCK[bossIndex],
                combatStartTime: gameTime,
                sides: bossIndex % 2 === 0 ? 8 : 6,
                flashTimer: 0
            };
            bossPhase = 1;
            bossPatternTimer = 0;
            bossDefeated = false;
            bossHealthBarDisplayHP = calculatedHP;

            triggerFlash('#FFFFFF', 0.5, 400);
            triggerShake(10, 600);
            triggerSlowmo(400);
            spawnFloatingText(arenaCenter.x, arenaCenter.y - 80, currentBoss.name, currentBoss.color);

            // Reset pattern state
            bossPatternIndex = 0;
            bossPatternCooldown = 2.5;
            bossPatternActive = false;
            bossPatternState = null;

            // Initialize Orbital Guardian spheres
            if (currentBoss.type === 'orbitalGuardian') {
                initBossSpheres();
            }

            // Initialize Missile Titan state — starts with missiles immediately
            if (currentBoss.type === 'missileTitan') {
                bossHomingMissiles = [];
                bossMTCannonTimer = 0;
                currentBoss.cannonCount = 8;
                currentBoss.missileChargeTimer = 0;
                // Override: first pattern is homing missile, fires at 0.5s
                bossPatternCooldown = 0.5;
                bossPatternIndex = 1; // will pick index 1 (homingMissile) from sequence
            }

            // Initialize Lightning Nexus state
            if (currentBoss.type === 'lightningNexus') {
                bossLightningStrikes = [];
                bossTrailNodes = [];
                bossTrailRays = [];
                bossTrailTimer = 1.5; // first trail node spawns 1.5s after boss appears
                currentBoss.arcOffsets = []; // random zigzag offsets for vertex arcs
                for (let i = 0; i < 8; i++) {
                    currentBoss.arcOffsets.push(Math.random() * 20 - 10);
                }
                bossPatternCooldown = 1.5;
            }

            // Spawn ring burst at boss position
            for (let i = 0; i < 12; i++) {
                spawnRing(arenaCenter.x + (Math.random() - 0.5) * 60, arenaCenter.y + (Math.random() - 0.5) * 60, currentBoss.color, 50);
            }
        }

        function checkBossSpawn() {
            if (currentBoss || bossIncoming) return;
            for (let i = 0; i < BOSS_SPAWN_LEVELS.length; i++) {
                if (playerLevel >= BOSS_SPAWN_LEVELS[i] && !bossesDefeatedThisRun.includes(i)) {
                    spawnBoss(i);
                    break;
                }
            }
        }

        function updateBoss(dt) {
            if (!currentBoss) return;

            const boss = currentBoss;

            // Boss stays fixed at arena center
            boss.x = arenaCenter.x;
            boss.y = arenaCenter.y;

            // Rotation (degrees)
            if (boss.phaseSpinRemaining && boss.phaseSpinRemaining > 0) {
                const spinSpeed = 720; // degrees per second (720° in 1s)
                const spinThisFrame = spinSpeed * dt;
                boss.rotation += spinThisFrame;
                boss.phaseSpinRemaining -= spinThisFrame;
                if (boss.phaseSpinRemaining <= 0) boss.phaseSpinRemaining = 0;
            } else {
                boss.rotation += 60 * dt;
            }

            // Flash timer decay
            if (boss.flashTimer > 0) {
                boss.flashTimer -= dt;
            }

            // Orbital Guardian spheres
            updateBossSpheres(dt);

            // Missile Titan homing missiles
            updateHomingMissiles(dt);

            // Missile charge visual timer
            if (boss.missileChargeTimer !== undefined && boss.missileChargeTimer > 0) {
                boss.missileChargeTimer -= dt;
            }

            // Lightning Nexus systems
            updateLightningStrikes(dt);
            updateTrailNodes(dt);

            // Boss attack patterns
            updateBossPatterns(dt);

            // Update boss projectiles
            updateBossProjectiles(dt);

            // Phase transition check
            if (boss.hp <= boss.maxHp * 0.5 && boss.phase === 1) {
                triggerPhaseTransition();
            }

            // Death check
            if (boss.hp <= 0) {
                onBossDefeated();
            }
        }

        function triggerPhaseTransition() {
            if (!currentBoss) return;
            currentBoss.phase = 2;
            bossPhase = 2;

            if (currentBoss.type === 'orbitalGuardian') {
                // White flash (0.3s)
                triggerFlash('#FFFFFF', 0.7, 300);
                triggerSlowmo(500);
                triggerShake(12, 800);

                // 720° spin over 1s (stored as target, applied in updateBoss)
                currentBoss.phaseSpinRemaining = 720;

                // Rage RingWave - burst of projectiles
                const count = 32;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i;
                    spawnBossProjectile(currentBoss.x, currentBoss.y, angle, BOSS_PROJ_SPEED * 0.8, {
                        color: '#FFFFFF',
                        radius: 6
                    });
                }

                // Reset pattern to start phase 2 sequence fresh
                bossPatternIndex = 0;
                bossPatternActive = false;
                bossPatternCooldown = 1.5;
                bossPatternState = null;

                spawnFloatingText(currentBoss.x, currentBoss.y - currentBoss.size, 'PHASE 2', '#FF4444');
                spawnFloatingText(currentBoss.x, currentBoss.y, 'ENRAGED', '#FF4444');

                // Ring burst
                for (let i = 0; i < 8; i++) {
                    spawnRing(currentBoss.x + (Math.random() - 0.5) * 40, currentBoss.y + (Math.random() - 0.5) * 40, '#FFFFFF', 80);
                }
            } else if (currentBoss.type === 'missileTitan') {
                // Strong screen shake + shockwave
                triggerFlash('#FFD93D', 0.8, 500);
                triggerSlowmo(600);
                triggerShake(20, 1200);

                // 720° rage spin
                currentBoss.phaseSpinRemaining = 720;

                // Shockwave: expanding ring of projectiles
                const count = 28;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i;
                    spawnBossProjectile(currentBoss.x, currentBoss.y, angle, BOSS_PROJ_SPEED * 1.2, {
                        color: '#FFD93D',
                        radius: 10,
                        hp: 2
                    });
                }

                // Ring burst visuals
                for (let i = 0; i < 12; i++) {
                    spawnRing(currentBoss.x + (Math.random() - 0.5) * 60, currentBoss.y + (Math.random() - 0.5) * 60, '#FFD93D', 100);
                }

                // Reset pattern sequence
                bossPatternIndex = 0;
                bossPatternActive = false;
                bossPatternCooldown = 1.0;
                bossPatternState = null;

                spawnFloatingText(currentBoss.x, currentBoss.y - currentBoss.size, 'PHASE 2', '#FF4444');
                spawnFloatingText(currentBoss.x, currentBoss.y, 'FULL ARSENAL', '#FFD93D');
            } else if (currentBoss.type === 'lightningNexus') {
                // Purple flash + electric shockwave
                triggerFlash('#9F7AEA', 0.8, 500);
                triggerSlowmo(600);
                triggerShake(18, 1000);

                // 720° rage spin
                currentBoss.phaseSpinRemaining = 720;

                // Electric shockwave: 24 projectiles in ring
                const count = 24;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i;
                    spawnBossProjectile(currentBoss.x, currentBoss.y, angle, BOSS_PROJ_SPEED * 1.1, {
                        color: '#00FFFF',
                        radius: 8,
                        hp: 2
                    });
                }

                // Ring burst visuals
                for (let i = 0; i < 10; i++) {
                    spawnRing(currentBoss.x + (Math.random() - 0.5) * 60, currentBoss.y + (Math.random() - 0.5) * 60, '#9F7AEA', 90);
                }

                // Reset pattern sequence
                bossPatternIndex = 0;
                bossPatternActive = false;
                bossPatternCooldown = 1.0;
                bossPatternState = null;
                bossLightningStrikes = [];
                bossTrailNodes = [];
                bossTrailRays = [];
                bossTrailTimer = 1.0; // restart faster in P2

                spawnFloatingText(currentBoss.x, currentBoss.y - currentBoss.size, 'PHASE 2', '#FF4444');
                spawnFloatingText(currentBoss.x, currentBoss.y, 'OVERCHARGED', '#00FFFF');
            } else {
                triggerFlash(currentBoss.color, 0.4, 400);
                triggerSlowmo(300);
                triggerShake(8, 500);
                spawnFloatingText(currentBoss.x, currentBoss.y - currentBoss.size, 'PHASE 2', currentBoss.color);
                spawnFloatingText(currentBoss.x, currentBoss.y, 'ENRAGED', currentBoss.color);
            }
        }

        function damageBoss(amount) {
            if (!currentBoss) return;
            currentBoss.hp -= amount;
            if (currentBoss.hp < 0) currentBoss.hp = 0;
            currentBoss.flashTimer = 0.1;

            spawnFloatingText(currentBoss.x, currentBoss.y - currentBoss.size, amount.toString(), '#FFFFFF');
        }

        function onBossDefeated() {
            if (!currentBoss) return;

            const boss = currentBoss;
            bossesDefeatedThisRun.push(boss.index);
            bossDefeated = true;

            // Save weapon unlock to progression
            const prog = loadProgression();
            prog.unlockedWeapons[boss.weaponUnlock] = true;
            if (!prog.bossDefeats[boss.type]) {
                prog.bossDefeats[boss.type] = 0;
            }
            prog.bossDefeats[boss.type]++;
            prog.stats.totalBossDefeats++;
            saveProgression(prog);

            // Visual effects
            triggerFlash('#FFFFFF', 0.6, 500);
            triggerSlowmo(800);
            triggerShake(15, 800);
            spawnFloatingText(boss.x, boss.y - 80, 'BOSS DEFEATED', '#FFD700');
            spawnFloatingText(boss.x, boss.y, boss.name + ' DESTROYED', '#FFD700');
            spawnFloatingText(boss.x, boss.y - 40, boss.weaponUnlock.replace(/_/g, ' ').toUpperCase() + ' UNLOCKED!', boss.color);

            // Particle explosion
            for (let i = 0; i < 40; i++) {
                spawnRing(boss.x + (Math.random() - 0.5) * boss.size, boss.y + (Math.random() - 0.5) * boss.size, boss.color, 60);
            }

            // XP reward: grant enough XP for 2 levels
            const xpReward = xpToNextLevel * 2;
            collectXP(xpReward);

            // Clear boss projectiles, pattern state, spheres, missiles, and lightning
            bossProjectiles.length = 0;
            bossPatternActive = false;
            bossPatternState = null;
            bossSpheres = [];
            bossHomingMissiles = [];
            bossLightningStrikes = [];
            bossTrailNodes = [];
            bossTrailRays = [];

            // Deactivate arena
            deactivateArena();
            currentBoss = null;
        }

        function renderBoss() {
            if (!currentBoss) return;

            const boss = currentBoss;

            if (boss.type === 'missileTitan') {
                renderMissileTitan();
                return;
            }

            if (boss.type === 'lightningNexus') {
                renderLightningNexus();
                return;
            }

            ctx.save();
            ctx.translate(boss.x, boss.y);
            ctx.rotate(boss.rotation * Math.PI / 180);

            const sides = boss.sides;
            const size = boss.size;

            // Outer glow ring
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const px = Math.cos(angle) * (size + 10);
                const py = Math.sin(angle) * (size + 10);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.strokeStyle = boss.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3 + Math.sin(gameTime * 4) * 0.15;
            setGlow(ctx, boss.color, 20);
            ctx.stroke();
            clearGlow(ctx);
            ctx.globalAlpha = 1;

            // Main body polygon
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const px = Math.cos(angle) * size;
                const py = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            // Fill with gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const baseColor = boss.color;
            gradient.addColorStop(0, baseColor);
            gradient.addColorStop(0.5, baseColor + '88');
            gradient.addColorStop(1, baseColor + '22');
            ctx.fillStyle = gradient;
            ctx.globalAlpha = boss.phase === 2 ? 0.7 : 0.5;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Border
            ctx.strokeStyle = boss.color;
            ctx.lineWidth = boss.phase === 2 ? 3 : 2;
            ctx.stroke();

            // Flash white on damage
            if (boss.flashTimer > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, ' + Math.min(boss.flashTimer / 0.1, 0.6) + ')';
                ctx.fill();
            }

            // Pulsating center core
            const coreSize = 12 + Math.sin(gameTime * 6) * 4;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFFFF';
            ctx.globalAlpha = 0.6 + Math.sin(gameTime * 8) * 0.3;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Inner ring
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.strokeStyle = boss.color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Phase 2: extra visual (inner polygon spinning opposite)
            if (boss.phase === 2) {
                ctx.save();
                ctx.rotate(-boss.rotation * 2 * Math.PI / 180);
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (Math.PI * 2 / sides) * i;
                    const px = Math.cos(angle) * (size * 0.55);
                    const py = Math.sin(angle) * (size * 0.55);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = boss.color;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            ctx.restore();
        }

        function renderMissileTitan() {
            const boss = currentBoss;
            const sides = boss.sides; // 6 (hexagon)
            const size = boss.size;

            ctx.save();
            ctx.translate(boss.x, boss.y);
            ctx.rotate(boss.rotation * Math.PI / 180);

            // Outer glow ring — gold
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const px = Math.cos(angle) * (size + 14);
                const py = Math.sin(angle) * (size + 14);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.strokeStyle = '#FFD93D';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3 + Math.sin(gameTime * 3) * 0.15;
            setGlow(ctx, '#FFD93D', 20);
            ctx.stroke();
            clearGlow(ctx);
            ctx.globalAlpha = 1;

            // Main body — metallic grey hexagon
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const px = Math.cos(angle) * size;
                const py = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            // Metallic gradient: grey center, darker edges
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            bodyGrad.addColorStop(0, '#A0A0A0');
            bodyGrad.addColorStop(0.4, '#808080');
            bodyGrad.addColorStop(0.8, '#505050');
            bodyGrad.addColorStop(1, '#303030');
            ctx.fillStyle = bodyGrad;
            ctx.globalAlpha = boss.phase === 2 ? 0.85 : 0.7;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Gold border
            ctx.strokeStyle = '#FFD93D';
            ctx.lineWidth = boss.phase === 2 ? 3.5 : 2.5;
            ctx.stroke();

            // Gold accent lines (inner hexagonal pattern)
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const px = Math.cos(angle) * (size * 0.6);
                const py = Math.sin(angle) * (size * 0.6);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.strokeStyle = '#FFD93D';
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.35;
            ctx.stroke();
            ctx.globalAlpha = 1;

            // 8 vertex accent dots on the perimeter
            const cannonCount = 8;
            for (let i = 0; i < cannonCount; i++) {
                const cAngle = (Math.PI * 2 / cannonCount) * i;
                const cx = Math.cos(cAngle) * size;
                const cy = Math.sin(cAngle) * size;

                // Small gold dot at each vertex
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD93D';
                ctx.globalAlpha = 0.6 + Math.sin(gameTime * 4 + i * 0.8) * 0.3;
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Flash white on damage
            if (boss.flashTimer > 0) {
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                    const px = Math.cos(angle) * size;
                    const py = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 255, 255, ' + Math.min(boss.flashTimer / 0.1, 0.6) + ')';
                ctx.fill();
            }

            // Center core — pulsating gold
            const coreSize = 14 + Math.sin(gameTime * 5) * 5;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);
            coreGrad.addColorStop(0, '#FFFFFF');
            coreGrad.addColorStop(0.5, '#FFD93D');
            coreGrad.addColorStop(1, '#FF880044');
            ctx.fillStyle = coreGrad;
            ctx.globalAlpha = 0.7 + Math.sin(gameTime * 7) * 0.2;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Missile reload lines (flash before missile launch)
            if (boss.missileChargeTimer > 0) {
                const chargeAlpha = Math.min(boss.missileChargeTimer / 0.4, 1.0);
                const pulseRate = 20;
                const pulse = 0.5 + Math.sin(gameTime * pulseRate) * 0.5;

                for (let i = 0; i < 6; i++) {
                    const lineAngle = (Math.PI * 2 / 6) * i;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(lineAngle) * (size * 0.3), Math.sin(lineAngle) * (size * 0.3));
                    ctx.lineTo(Math.cos(lineAngle) * (size * 0.9), Math.sin(lineAngle) * (size * 0.9));
                    ctx.strokeStyle = '#FF4400';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = chargeAlpha * pulse;
                    setGlow(ctx, '#FF4400', 8);
                    ctx.stroke();
                    clearGlow(ctx);
                }
                ctx.globalAlpha = 1;
            }

            // Phase 2: inner hexagon spinning opposite + extra glow
            if (boss.phase === 2) {
                ctx.save();
                ctx.rotate(-boss.rotation * 2 * Math.PI / 180);
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (Math.PI * 2 / sides) * i;
                    const px = Math.cos(angle) * (size * 0.45);
                    const py = Math.sin(angle) * (size * 0.45);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = '#FFD93D';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            ctx.restore();
        }

        function renderBossHealthBar() {
            if (!currentBoss) return;

            const boss = currentBoss;
            const barWidth = 400;
            const barHeight = 16;
            const barX = (CANVAS_WIDTH - barWidth) / 2;
            const barY = 90;

            // Smooth HP interpolation
            const hpDiff = boss.hp - bossHealthBarDisplayHP;
            bossHealthBarDisplayHP += hpDiff * 0.1;
            if (Math.abs(hpDiff) < 1) bossHealthBarDisplayHP = boss.hp;

            const hpRatio = Math.max(0, bossHealthBarDisplayHP / boss.maxHp);

            // Boss name
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = 'bold 14px "Segoe UI", sans-serif';
            ctx.fillStyle = boss.color;
            setGlow(ctx, boss.color, 10);
            ctx.fillText(boss.name, CANVAS_WIDTH / 2, barY - 8);
            clearGlow(ctx);

            // Phase indicator
            ctx.font = '10px "Segoe UI", sans-serif';
            ctx.fillStyle = boss.phase === 2 ? '#FF4444' : '#AAAAAA';
            ctx.fillText('PHASE ' + boss.phase, CANVAS_WIDTH / 2, barY + barHeight + 16);

            // Bar background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.roundRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4, 4);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4, 4);
            ctx.stroke();

            // HP fill with gradient
            if (hpRatio > 0) {
                const fillWidth = barWidth * hpRatio;
                const hpGradient = ctx.createLinearGradient(barX, 0, barX + fillWidth, 0);

                if (boss.phase === 1) {
                    hpGradient.addColorStop(0, '#39FF14');
                    hpGradient.addColorStop(1, '#FFD93D');
                } else {
                    hpGradient.addColorStop(0, '#FF4444');
                    hpGradient.addColorStop(1, '#FF8800');
                }

                ctx.fillStyle = hpGradient;
                ctx.beginPath();
                ctx.roundRect(barX, barY, fillWidth, barHeight, 3);
                ctx.fill();

                // Shine on top
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, fillWidth, barHeight / 2, [3, 3, 0, 0]);
                ctx.fill();
            }

            // HP text
            ctx.font = 'bold 10px "Segoe UI", sans-serif';
            ctx.fillStyle = '#FFFFFF';
            ctx.globalAlpha = 0.8;
            ctx.fillText(Math.ceil(bossHealthBarDisplayHP) + ' / ' + boss.maxHp, CANVAS_WIDTH / 2, barY + barHeight - 3);
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        // --- Boss Projectile System ---

        function spawnBossProjectile(x, y, angle, speed, options) {
            options = options || {};
            const s = speed || BOSS_PROJ_SPEED;
            bossProjectiles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * s,
                vy: Math.sin(angle) * s,
                hp: options.hp || BOSS_PROJ_HP,
                damage: options.damage || BOSS_PROJ_DAMAGE,
                radius: options.radius || BOSS_PROJ_RADIUS,
                life: options.life || BOSS_PROJ_LIFETIME,
                color: options.color || (currentBoss ? currentBoss.color : '#FF0000'),
                type: options.type || 'normal',
                trail: []
            });
        }

        function updateBossProjectiles(dt) {
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const bp = bossProjectiles[i];

                // Store trail position
                bp.trail.push({ x: bp.x, y: bp.y });
                if (bp.trail.length > 4) bp.trail.shift();

                bp.x += bp.vx * dt;
                bp.y += bp.vy * dt;
                bp.life -= dt;

                // Remove if expired, destroyed, or outside arena
                let remove = bp.life <= 0 || bp.hp <= 0;
                if (!remove && arenaActive) {
                    const dx = bp.x - arenaCenter.x;
                    const dy = bp.y - arenaCenter.y;
                    if (dx * dx + dy * dy > (ARENA_RADIUS + 100) * (ARENA_RADIUS + 100)) {
                        remove = true;
                    }
                }
                if (remove) {
                    bossProjectiles.splice(i, 1);
                }
            }
        }

        function renderBossProjectiles() {
            for (let i = 0; i < bossProjectiles.length; i++) {
                const bp = bossProjectiles[i];

                // Trail
                for (let t = 0; t < bp.trail.length; t++) {
                    const alpha = (t + 1) / (bp.trail.length + 1) * 0.4;
                    const trailRadius = bp.radius * (t + 1) / (bp.trail.length + 1);
                    ctx.beginPath();
                    ctx.arc(bp.trail[t].x, bp.trail[t].y, trailRadius, 0, Math.PI * 2);
                    ctx.fillStyle = bp.color;
                    ctx.globalAlpha = alpha;
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Glow
                setGlow(ctx, bp.color, 12);

                if (bp.type === 'diamond') {
                    // Diamond shape
                    ctx.save();
                    ctx.translate(bp.x, bp.y);
                    ctx.rotate(Math.atan2(bp.vy, bp.vx));
                    ctx.beginPath();
                    ctx.moveTo(bp.radius * 1.4, 0);
                    ctx.lineTo(0, bp.radius * 0.7);
                    ctx.lineTo(-bp.radius * 0.8, 0);
                    ctx.lineTo(0, -bp.radius * 0.7);
                    ctx.closePath();
                    ctx.fillStyle = bp.color;
                    ctx.globalAlpha = 0.9;
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(bp.radius * 0.6, 0);
                    ctx.lineTo(0, bp.radius * 0.3);
                    ctx.lineTo(-bp.radius * 0.3, 0);
                    ctx.lineTo(0, -bp.radius * 0.3);
                    ctx.closePath();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.globalAlpha = 0.7;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                } else {
                    // Main circle
                    ctx.beginPath();
                    ctx.arc(bp.x, bp.y, bp.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bp.color;
                    ctx.globalAlpha = 0.9;
                    ctx.fill();

                    // Bright center
                    ctx.beginPath();
                    ctx.arc(bp.x, bp.y, bp.radius * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.globalAlpha = 0.8;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                clearGlow(ctx);
            }
        }

        // --- Boss Attack Patterns ---

        let bossPatternState = null;

        function bossPattern_SpiralOutward(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            state.elapsed += dt;
            state.fireTimer += dt;

            const fireInterval = 0.15;
            if (state.fireTimer >= fireInterval) {
                state.fireTimer -= fireInterval;
                const speed = currentBoss.phase === 2 ? BOSS_PROJ_SPEED * 1.4 : BOSS_PROJ_SPEED;
                spawnBossProjectile(currentBoss.x, currentBoss.y, state.angle, speed);
                state.angle += 20 * Math.PI / 180;
            }

            return state.elapsed >= 3;
        }

        function bossPattern_CornerBarrage(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            state.elapsed += dt;
            state.fireTimer += dt;

            const maxBursts = state.maxBursts || 8;
            const isDouble = state.double || false;
            const fireInterval = isDouble ? 0.35 : 0.5;
            if (state.fireTimer >= fireInterval && state.bursts < maxBursts) {
                state.fireTimer -= fireInterval;
                state.bursts++;
                const boss = currentBoss;
                const sides = boss.sides;
                const speed = boss.phase === 2 ? BOSS_PROJ_SPEED * 1.4 : BOSS_PROJ_SPEED;
                for (let i = 0; i < sides; i++) {
                    const vertexAngle = (Math.PI * 2 / sides) * i + boss.rotation * Math.PI / 180;
                    const spawnX = boss.x + Math.cos(vertexAngle) * boss.size;
                    const spawnY = boss.y + Math.sin(vertexAngle) * boss.size;
                    spawnBossProjectile(spawnX, spawnY, vertexAngle, speed);
                    if (isDouble) {
                        // Second projectile slightly offset angle
                        spawnBossProjectile(spawnX, spawnY, vertexAngle + 10 * Math.PI / 180, speed * 0.85);
                    }
                }
            }

            return state.bursts >= maxBursts;
        }

        function bossPattern_RingWave(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            if (!state.fired) {
                state.fired = true;
                const count = 24;
                const speed = currentBoss.phase === 2 ? BOSS_PROJ_SPEED * 1.4 : BOSS_PROJ_SPEED;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i;
                    spawnBossProjectile(currentBoss.x, currentBoss.y, angle, speed);
                }
            }
            state.elapsed += dt;
            return state.elapsed >= 0.5;
        }

        function bossPattern_TargetedBurst(dt) {
            if (!currentBoss || !player) return true;
            const state = bossPatternState;
            state.elapsed += dt;
            state.fireTimer += dt;

            const fireInterval = 0.8;
            if (state.fireTimer >= fireInterval && state.bursts < 3) {
                state.fireTimer -= fireInterval;
                state.bursts++;
                const boss = currentBoss;
                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const baseAngle = Math.atan2(dy, dx);
                const spreadAngle = 15 * Math.PI / 180;
                const speed = boss.phase === 2 ? BOSS_PROJ_SPEED * 1.4 : BOSS_PROJ_SPEED;
                for (let j = -2; j <= 2; j++) {
                    spawnBossProjectile(boss.x, boss.y, baseAngle + spreadAngle * j, speed);
                }
            }

            return state.bursts >= 3;
        }

        // Pattern selection and scheduling
        const BOSS_PATTERNS = [bossPattern_SpiralOutward, bossPattern_CornerBarrage, bossPattern_RingWave, bossPattern_TargetedBurst];
        let bossPatternIndex = 0;
        let bossPatternCooldown = 2.5;
        let bossPatternActive = false;

        function updateBossPatterns(dt) {
            if (!currentBoss) return;

            if (bossPatternActive) {
                const done = currentBoss.currentPattern(dt);
                if (done) {
                    bossPatternActive = false;
                    // Set cooldown based on boss type and phase
                    if (currentBoss.type === 'orbitalGuardian') {
                        const seq = currentBoss.phase === 2 ? OG_PHASE2_SEQUENCE : OG_PHASE1_SEQUENCE;
                        const prevIndex = (bossPatternIndex - 1 + seq.length) % seq.length;
                        bossPatternCooldown = seq[prevIndex].pause;
                    } else if (currentBoss.type === 'missileTitan') {
                        const seq = currentBoss.phase === 2 ? MT_PHASE2_SEQUENCE : MT_PHASE1_SEQUENCE;
                        const prevIndex = (bossPatternIndex - 1 + seq.length) % seq.length;
                        bossPatternCooldown = seq[prevIndex].pause;
                    } else if (currentBoss.type === 'lightningNexus') {
                        const seq = currentBoss.phase === 2 ? LN_PHASE2_SEQUENCE : LN_PHASE1_SEQUENCE;
                        const prevIndex = (bossPatternIndex - 1 + seq.length) % seq.length;
                        bossPatternCooldown = seq[prevIndex].pause;
                    } else {
                        bossPatternCooldown = currentBoss.phase === 2 ? 1.5 : 2.5;
                    }
                    bossPatternState = null;
                }
            } else {
                bossPatternCooldown -= dt;
                if (bossPatternCooldown <= 0) {
                    bossPatternActive = true;
                    if (currentBoss.type === 'orbitalGuardian') {
                        const seq = currentBoss.phase === 2 ? OG_PHASE2_SEQUENCE : OG_PHASE1_SEQUENCE;
                        const entry = seq[bossPatternIndex % seq.length];
                        currentBoss.currentPattern = getOGPattern(entry.pattern);
                        // For cornerBarrageDouble, use modified init state
                        if (entry.pattern === 'cornerBarrageDouble') {
                            bossPatternState = { elapsed: 0, fireTimer: 0, angle: 0, bursts: 0, fired: false, maxBursts: 8, double: true };
                        } else {
                            bossPatternState = { elapsed: 0, fireTimer: 0, angle: 0, bursts: 0, fired: false };
                        }
                    } else if (currentBoss.type === 'missileTitan') {
                        const seq = currentBoss.phase === 2 ? MT_PHASE2_SEQUENCE : MT_PHASE1_SEQUENCE;
                        const entry = seq[bossPatternIndex % seq.length];
                        currentBoss.currentPattern = getMTPattern(entry.pattern);
                        bossPatternState = getMTPatternState(entry.pattern);
                    } else if (currentBoss.type === 'lightningNexus') {
                        const seq = currentBoss.phase === 2 ? LN_PHASE2_SEQUENCE : LN_PHASE1_SEQUENCE;
                        const entry = seq[bossPatternIndex % seq.length];
                        currentBoss.currentPattern = getLNPattern(entry.pattern);
                        bossPatternState = getLNPatternState(entry);
                    } else {
                        currentBoss.currentPattern = BOSS_PATTERNS[bossPatternIndex % BOSS_PATTERNS.length];
                        bossPatternState = { elapsed: 0, fireTimer: 0, angle: 0, bursts: 0, fired: false };
                    }
                    bossPatternIndex++;
                }
            }
        }

        // --- Orbital Guardian: Sphere System ---

        function initBossSpheres() {
            bossSpheres = [];
            const sphereColor = '#00DFFF';
            const R = 166;
            // Inner ring: 3 spheres, orbit 280px, clockwise
            for (let i = 0; i < 3; i++) {
                bossSpheres.push({
                    ring: 0,
                    angle: (Math.PI * 2 / 3) * i,
                    orbitRadius: 280,
                    speed: 0.4,
                    radius: R,
                    color: sphereColor,
                    x: 0, y: 0
                });
            }
            // Middle ring: 3 spheres, orbit 660px, counter-clockwise
            for (let i = 0; i < 3; i++) {
                bossSpheres.push({
                    ring: 1,
                    angle: (Math.PI * 2 / 3) * i + Math.PI / 3,
                    orbitRadius: 660,
                    speed: -0.25,
                    radius: R,
                    color: sphereColor,
                    x: 0, y: 0
                });
            }
            // Outer ring: 3 spheres, orbit 1020px, clockwise
            for (let i = 0; i < 3; i++) {
                bossSpheres.push({
                    ring: 2,
                    angle: (Math.PI * 2 / 3) * i,
                    orbitRadius: 1020,
                    speed: 0.175,
                    radius: R,
                    color: sphereColor,
                    x: 0, y: 0
                });
            }
        }

        function updateBossSpheres(dt) {
            if (!currentBoss || currentBoss.type !== 'orbitalGuardian') return;

            const speedMult = currentBoss.phase === 2 ? 1.5 : 1;

            for (let i = 0; i < bossSpheres.length; i++) {
                const s = bossSpheres[i];
                s.angle += s.speed * speedMult * dt;
                s.x = currentBoss.x + Math.cos(s.angle) * s.orbitRadius;
                s.y = currentBoss.y + Math.sin(s.angle) * s.orbitRadius;
            }
        }

        function renderBossSpheres() {
            if (!currentBoss || currentBoss.type !== 'orbitalGuardian') return;

            const boss = currentBoss;

            // Orbit path rings (smooth visible circles)
            for (const ringRadius of [280, 660, 1020]) {
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, ringRadius, 0, Math.PI * 2);
                ctx.strokeStyle = boss.color;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.15;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Energy lines connecting spheres to boss
            for (let i = 0; i < bossSpheres.length; i++) {
                const s = bossSpheres[i];
                ctx.beginPath();
                ctx.moveTo(boss.x, boss.y);
                ctx.lineTo(s.x, s.y);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.15 + Math.sin(gameTime * 6 + i) * 0.08;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Spheres — outline with inner radial fade
            for (let i = 0; i < bossSpheres.length; i++) {
                const s = bossSpheres[i];

                // Inner radial fade fill
                const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius);
                grad.addColorStop(0, 'rgba(0, 223, 255, 0.12)');
                grad.addColorStop(0.6, 'rgba(0, 223, 255, 0.05)');
                grad.addColorStop(1, 'rgba(0, 223, 255, 0)');
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();

                // Outline ring
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        // --- Orbital Guardian: Shield Projection Barrage ---

        function bossPattern_ShieldProjectionBarrage(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            state.elapsed += dt;
            state.fireTimer += dt;

            const totalWaves = currentBoss.phase === 2 ? 4 : 3;
            const fireInterval = 0.6;

            if (state.fireTimer >= fireInterval && state.bursts < totalWaves) {
                state.fireTimer -= fireInterval;
                const waveIndex = state.bursts;
                state.bursts++;

                const count = 16;
                const rotationOffset = waveIndex * 22.5 * Math.PI / 180;
                const speed = 280;

                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + rotationOffset;
                    spawnBossProjectile(currentBoss.x, currentBoss.y, angle, speed, {
                        hp: 5,
                        radius: 10,
                        type: 'diamond',
                        color: currentBoss.color
                    });
                }
            }

            return state.bursts >= totalWaves && state.elapsed >= totalWaves * fireInterval + 0.3;
        }

        // --- Orbital Guardian: Attack Sequences ---

        const OG_PHASE1_SEQUENCE = [
            { pattern: 'spiralOutward', pause: 3 },
            { pattern: 'shieldBarrage', pause: 3 },
            { pattern: 'cornerBarrage', pause: 3 }
        ];
        const OG_PHASE2_SEQUENCE = [
            { pattern: 'cornerBarrageDouble', pause: 1.5 },
            { pattern: 'shieldBarrage', pause: 1.5 },
            { pattern: 'ringWave', pause: 1.5 }
        ];

        function getOGPattern(name) {
            switch (name) {
                case 'spiralOutward': return bossPattern_SpiralOutward;
                case 'shieldBarrage': return bossPattern_ShieldProjectionBarrage;
                case 'cornerBarrage': return bossPattern_CornerBarrage;
                case 'cornerBarrageDouble': return bossPattern_CornerBarrage;
                case 'ringWave': return bossPattern_RingWave;
                default: return bossPattern_SpiralOutward;
            }
        }

        // --- Missile Titan: Homing Missile System ---

        function spawnHomingMissile(x, y) {
            if (!currentBoss || !player) return;
            // Spawn facing AWAY from player in a random 180° arc
            const toPlayerAngle = Math.atan2(player.y - y, player.x - x);
            const awayAngle = toPlayerAngle + Math.PI; // opposite direction
            const angle = awayAngle + (Math.random() - 0.5) * Math.PI; // ±90° spread
            bossHomingMissiles.push({
                x: x,
                y: y,
                angle: angle,
                speed: 900,
                radius: 20,
                hp: 500,
                maxHp: 500,
                damage: 18,
                life: 10,
                trail: [],
                trailTimer: 0,
                straightTimer: 0.5
            });
            // Missile charge visual
            if (currentBoss) currentBoss.missileChargeTimer = 0;
            // Thruster burst at launch
            for (let i = 0; i < 6; i++) {
                const a = angle + Math.PI + (Math.random() - 0.5) * 1.2;
                const sp = 150 + Math.random() * 100;
                const colors = ['#FF4400', '#FF6600', '#FFD93D'];
                const p = pools.particle.acquire();
                p.x = x; p.y = y;
                p.vx = Math.cos(a) * sp; p.vy = Math.sin(a) * sp;
                p.life = 0.2 + Math.random() * 0.2; p.maxLife = 0.5;
                p.size = 10 + Math.random() * 8;
                p.color = colors[Math.floor(Math.random() * colors.length)];
                p.type = 'thruster';
                p.rotation = Math.random() * Math.PI * 2;
                p.rotationSpeed = (Math.random() - 0.5) * 2;
                particles.push(p);
            }
        }

        function explodeHomingMissile(m) {
            // 12 projectiles in a circle
            for (let j = 0; j < 12; j++) {
                const expAngle = (Math.PI * 2 / 12) * j;
                spawnBossProjectile(m.x, m.y, expAngle, BOSS_PROJ_SPEED * 0.9, {
                    color: '#FF6600',
                    radius: 6,
                    hp: 2,
                    life: 4
                });
            }
            // Single expanding ring (like enemy death / player missile impact)
            spawnRing(m.x, m.y, '#FF6600', 60);
            triggerShake(6, 200);
        }

        function updateHomingMissiles(dt) {
            if (!currentBoss || currentBoss.type !== 'missileTitan') return;

            const maxTurnRateSlow = 120 * Math.PI / 180; // 120 deg/s at min speed
            const maxTurnRateFast = 25 * Math.PI / 180;  // 25 deg/s at max speed
            const minSpeed = 250;
            const maxSpeed = 900;
            const accel = 400;  // speed gained per second when straight
            const decel = 1200; // speed lost per second when turning hard

            for (let i = bossHomingMissiles.length - 1; i >= 0; i--) {
                const m = bossHomingMissiles[i];

                // Turn rate scales down with speed: slow = agile, fast = stiff
                const speedFactor = (m.speed - minSpeed) / (maxSpeed - minSpeed);
                const currentTurnRate = maxTurnRateSlow + (maxTurnRateFast - maxTurnRateSlow) * speedFactor;

                // Fly straight for initial period, then steer toward player
                let turnFactor = 0; // 0 = straight, 1 = max turn
                if (m.straightTimer > 0) {
                    m.straightTimer -= dt;
                } else if (player) {
                    const dx = player.x - m.x;
                    const dy = player.y - m.y;
                    const desiredAngle = Math.atan2(dy, dx);
                    let angleDiff = desiredAngle - m.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    // How hard are we turning (0-1)
                    turnFactor = Math.min(1, Math.abs(angleDiff) / (Math.PI * 0.5));
                    // Clamp turn rate (reduced at high speed)
                    const maxTurn = currentTurnRate * dt;
                    if (angleDiff > maxTurn) angleDiff = maxTurn;
                    else if (angleDiff < -maxTurn) angleDiff = -maxTurn;
                    m.angle += angleDiff;
                }

                // Speed: decelerate when turning, accelerate when straight
                const targetSpeed = maxSpeed - (maxSpeed - minSpeed) * turnFactor;
                if (m.speed < targetSpeed) {
                    m.speed = Math.min(targetSpeed, m.speed + accel * dt);
                } else {
                    m.speed = Math.max(targetSpeed, m.speed - decel * dt);
                }

                // Move in direction of rotation
                m.x += Math.cos(m.angle) * m.speed * dt;
                m.y += Math.sin(m.angle) * m.speed * dt;
                m.life -= dt;

                // Thruster triangle trail particles (like player thruster)
                m.trailTimer += dt;
                if (m.trailTimer >= 0.04) {
                    m.trailTimer -= 0.04;
                    const trailAngle = m.angle + Math.PI + (Math.random() - 0.5) * 0.3;
                    const trailSpeed = 200 + Math.random() * 80;
                    const colors = ['#FF4400', '#FF6600', '#FF8800', '#FFD93D'];
                    const p = pools.particle.acquire();
                    p.x = m.x - Math.cos(m.angle) * 15;
                    p.y = m.y - Math.sin(m.angle) * 15;
                    p.vx = Math.cos(trailAngle) * trailSpeed;
                    p.vy = Math.sin(trailAngle) * trailSpeed;
                    p.life = 0.15 + Math.random() * 0.15;
                    p.maxLife = 0.5;
                    p.size = 8 + Math.random() * 10;
                    p.color = colors[Math.floor(Math.random() * colors.length)];
                    p.type = 'thruster';
                    p.rotation = Math.random() * Math.PI * 2;
                    p.rotationSpeed = (Math.random() - 0.5) * 2;
                    particles.push(p);
                }

                // Trail positions for rendering (fading line like player rockets)
                m.trail.push({ x: m.x, y: m.y });
                if (m.trail.length > 16) m.trail.shift();

                // Remove if expired or outside arena
                let remove = m.life <= 0 || m.hp <= 0;
                if (!remove && arenaActive) {
                    const adx = m.x - arenaCenter.x;
                    const ady = m.y - arenaCenter.y;
                    if (adx * adx + ady * ady > (ARENA_RADIUS + 200) * (ARENA_RADIUS + 200)) {
                        remove = true;
                    }
                }

                if (remove) {
                    explodeHomingMissile(m);
                    bossHomingMissiles.splice(i, 1);
                }
            }
        }

        function renderHomingMissiles() {
            if (!currentBoss || currentBoss.type !== 'missileTitan') return;

            for (let i = 0; i < bossHomingMissiles.length; i++) {
                const m = bossHomingMissiles[i];

                // Fading line trail (like player rockets)
                if (m.trail.length > 1) {
                    for (let t = 0; t < m.trail.length - 1; t++) {
                        const alpha = 1 - (t / m.trail.length);
                        const width = 3 * (1 - t / m.trail.length);
                        ctx.strokeStyle = 'rgba(255, 102, 0, ' + (alpha * 0.6) + ')';
                        ctx.lineWidth = width;
                        ctx.beginPath();
                        ctx.moveTo(m.trail[t].x, m.trail[t].y);
                        ctx.lineTo(m.trail[t + 1].x, m.trail[t + 1].y);
                        ctx.stroke();
                    }
                }

                // Missile body
                ctx.save();
                ctx.translate(m.x, m.y);
                ctx.rotate(m.angle);

                // Main body (compact shape, same nose)
                setGlow(ctx, '#FF4400', 15);
                ctx.beginPath();
                ctx.moveTo(m.radius * 1.5, 0);            // nose (unchanged)
                ctx.lineTo(m.radius * 0.4, -m.radius * 0.45); // top wing
                ctx.lineTo(-m.radius * 0.25, -m.radius * 0.3); // top back
                ctx.lineTo(-m.radius * 0.15, 0);           // tail center
                ctx.lineTo(-m.radius * 0.25, m.radius * 0.3);  // bottom back
                ctx.lineTo(m.radius * 0.4, m.radius * 0.45);  // bottom wing
                ctx.closePath();

                // Solid fill with subtle metallic tone
                ctx.fillStyle = '#808080';
                ctx.fill();

                // Outline
                ctx.strokeStyle = '#FFD93D';
                ctx.lineWidth = 2;
                ctx.stroke();
                clearGlow(ctx);

                ctx.restore();
            }
        }

        // --- Missile Titan: Attack Patterns ---

        function bossPattern_HomingMissileBarrage(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            state.elapsed += dt;
            state.fireTimer += dt;

            const missileCount = currentBoss.phase === 2 ? 3 : 1;
            const burstInterval = 0.25;

            if (!state.fired) {
                state.fired = true;
                state.missilesLaunched = 0;
                // Charge-up visual
                if (currentBoss) currentBoss.missileChargeTimer = 0.5;
            }

            // Fire missiles one by one in burst after 0.5s charge
            if (state.elapsed >= 0.5 && state.missilesLaunched < missileCount) {
                if (state.fireTimer >= burstInterval) {
                    state.fireTimer -= burstInterval;
                    state.missilesLaunched++;
                    const boss = currentBoss;
                    // Spawn from a random point on boss perimeter
                    const spawnAngle = Math.random() * Math.PI * 2;
                    const sx = boss.x + Math.cos(spawnAngle) * (boss.size + 30);
                    const sy = boss.y + Math.sin(spawnAngle) * (boss.size + 30);
                    spawnHomingMissile(sx, sy);
                    triggerShake(4, 150);
                    // Small thruster burst per missile
                    for (let i = 0; i < 4; i++) {
                        const a = Math.random() * Math.PI * 2;
                        const sp = 80 + Math.random() * 60;
                        const colors = ['#FF4400', '#FF6600', '#FFD93D'];
                        const p = pools.particle.acquire();
                        p.x = sx; p.y = sy;
                        p.vx = Math.cos(a) * sp; p.vy = Math.sin(a) * sp;
                        p.life = 0.2; p.maxLife = 0.4;
                        p.size = 8 + Math.random() * 6;
                        p.color = colors[Math.floor(Math.random() * colors.length)];
                        p.type = 'thruster';
                        p.rotation = Math.random() * Math.PI * 2;
                        p.rotationSpeed = (Math.random() - 0.5) * 2;
                        particles.push(p);
                    }
                }
            }

            const totalDuration = 0.5 + missileCount * burstInterval + 0.3;
            return state.elapsed >= totalDuration;
        }

        function bossPattern_BarrageCannon(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            state.elapsed += dt;
            state.fireTimer += dt;

            const boss = currentBoss;
            const cannonCount = boss.phase === 2 ? 8 : 4;
            const burstCount = 3;
            const burstInterval = 0.2;
            const duration = boss.phase === 2 ? 3.5 : 2.5;
            const totalBursts = Math.floor(duration / burstInterval);

            if (state.fireTimer >= burstInterval && state.bursts < totalBursts) {
                state.fireTimer -= burstInterval;
                state.bursts++;

                const speed = boss.phase === 2 ? BOSS_PROJ_SPEED * 1.3 : BOSS_PROJ_SPEED;

                for (let c = 0; c < cannonCount; c++) {
                    const cannonAngle = (Math.PI * 2 / cannonCount) * c + boss.rotation * Math.PI / 180;
                    const sx = boss.x + Math.cos(cannonAngle) * boss.size;
                    const sy = boss.y + Math.sin(cannonAngle) * boss.size;

                    // Aim generally toward player with some spread from cannon position
                    const toPlayerAngle = Math.atan2(player.y - sy, player.x - sx);
                    const spread = 8 * Math.PI / 180;

                    for (let b = 0; b < burstCount; b++) {
                        const bulletAngle = toPlayerAngle + (b - 1) * spread;
                        spawnBossProjectile(sx, sy, bulletAngle, speed, {
                            radius: 6,
                            hp: 2,
                            color: '#FFD93D'
                        });
                    }
                }
            }

            return state.elapsed >= duration + 0.3;
        }

        // --- Missile Titan: Attack Sequences ---

        const MT_PHASE1_SEQUENCE = [
            { pattern: 'cornerBarrage4', pause: 2 },
            { pattern: 'homingMissile', pause: 1.5 },
            { pattern: 'barrageCannon', pause: 2 },
            { pattern: 'homingMissile', pause: 1.5 },
            { pattern: 'ringWave', pause: 2 }
        ];
        const MT_PHASE2_SEQUENCE = [
            { pattern: 'cornerBarrage8Fast', pause: 1 },
            { pattern: 'homingMissile', pause: 1 },
            { pattern: 'barrageCannon', pause: 1 },
            { pattern: 'homingMissile', pause: 1 },
            { pattern: 'ringWaveCornerCombo', pause: 1.5 }
        ];

        function getMTPattern(name) {
            switch (name) {
                case 'cornerBarrage4': return bossPattern_CornerBarrage;
                case 'cornerBarrage8Fast': return bossPattern_CornerBarrage;
                case 'homingMissile': return bossPattern_HomingMissileBarrage;
                case 'barrageCannon': return bossPattern_BarrageCannon;
                case 'ringWave': return bossPattern_RingWave;
                case 'ringWaveCornerCombo': return bossPattern_RingWaveCornerCombo;
                default: return bossPattern_SpiralOutward;
            }
        }

        function getMTPatternState(name) {
            const base = { elapsed: 0, fireTimer: 0, angle: 0, bursts: 0, fired: false, launched: false };
            switch (name) {
                case 'cornerBarrage4':
                    return { ...base, maxBursts: 4, double: false };
                case 'cornerBarrage8Fast':
                    return { ...base, maxBursts: 8, double: true };
                case 'ringWaveCornerCombo':
                    return { ...base, comboPhase: 0 };
                default:
                    return base;
            }
        }

        // Combined RingWave + CornerBarrage for phase 2 combo
        function bossPattern_RingWaveCornerCombo(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            state.elapsed += dt;

            // Fire ring wave immediately
            if (!state.ringFired) {
                state.ringFired = true;
                const count = 24;
                const speed = BOSS_PROJ_SPEED * 1.4;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i;
                    spawnBossProjectile(currentBoss.x, currentBoss.y, angle, speed);
                }
            }

            // Fire corner barrage 0.3s later
            if (state.elapsed >= 0.3) {
                state.fireTimer += dt;
                const fireInterval = 0.35;
                if (state.fireTimer >= fireInterval && state.bursts < 6) {
                    state.fireTimer -= fireInterval;
                    state.bursts++;
                    const boss = currentBoss;
                    const sides = boss.sides;
                    const speed = BOSS_PROJ_SPEED * 1.4;
                    for (let i = 0; i < sides; i++) {
                        const vertexAngle = (Math.PI * 2 / sides) * i + boss.rotation * Math.PI / 180;
                        const spawnX = boss.x + Math.cos(vertexAngle) * boss.size;
                        const spawnY = boss.y + Math.sin(vertexAngle) * boss.size;
                        spawnBossProjectile(spawnX, spawnY, vertexAngle, speed);
                    }
                }
            }

            return state.elapsed >= 2.5;
        }

        // --- Lightning Nexus: Grid Lightning Strike System ---

        // Compute line-circle intersection: line at given angle through arena center + perpendicular offset
        function computeLineEndpoints(angle, offset) {
            const cx = arenaCenter.x;
            const cy = arenaCenter.y;
            const R = ARENA_RADIUS;

            // Line direction vector
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);

            // Perpendicular offset from center
            const perpX = -dirY;
            const perpY = dirX;

            // Point on line closest to center
            const px = cx + perpX * offset;
            const py = cy + perpY * offset;

            // Half-length of chord: sqrt(R^2 - offset^2)
            const offsetSq = offset * offset;
            if (offsetSq >= R * R) return null;
            const halfChord = Math.sqrt(R * R - offsetSq);

            return {
                startX: px - dirX * halfChord,
                startY: py - dirY * halfChord,
                endX: px + dirX * halfChord,
                endY: py + dirY * halfChord
            };
        }

        // Generate N evenly spaced offsets across the arena diameter
        function computeEvenOffsets(count) {
            const offsets = [];
            for (let i = 0; i < count; i++) {
                offsets.push(ARENA_RADIUS * ((i + 1) / (count + 1) * 2 - 1));
            }
            return offsets;
        }

        function initLightningLines(patternType) {
            bossLightningStrikes = [];
            const lineDefs = []; // { angle, offset }

            if (patternType === 'gridVH') {
                // 3 vertical + 3 horizontal
                const offsets3 = computeEvenOffsets(3);
                for (const d of offsets3) lineDefs.push({ angle: Math.PI / 2, offset: d });
                for (const d of offsets3) lineDefs.push({ angle: 0, offset: d });
            } else if (patternType === 'singleDiagonal') {
                // X cross: both diagonals through center
                lineDefs.push({ angle: Math.PI / 4, offset: 0 });
                lineDefs.push({ angle: 3 * Math.PI / 4, offset: 0 });
            } else if (patternType === 'gridDiag3') {
                const offsets3 = computeEvenOffsets(3);
                for (const d of offsets3) lineDefs.push({ angle: Math.PI / 4, offset: d });
                for (const d of offsets3) lineDefs.push({ angle: 3 * Math.PI / 4, offset: d });
            } else if (patternType === 'vertical5') {
                const offsets5 = computeEvenOffsets(5);
                for (const d of offsets5) lineDefs.push({ angle: Math.PI / 2, offset: d });
            } else if (patternType === 'horizontal5') {
                const offsets5 = computeEvenOffsets(5);
                for (const d of offsets5) lineDefs.push({ angle: 0, offset: d });
            } else if (patternType === 'gridDiag5') {
                const offsets5 = computeEvenOffsets(5);
                for (const d of offsets5) lineDefs.push({ angle: Math.PI / 4, offset: d });
                for (const d of offsets5) lineDefs.push({ angle: 3 * Math.PI / 4, offset: d });
            }

            for (const def of lineDefs) {
                const ep = computeLineEndpoints(def.angle, def.offset);
                if (!ep) continue;
                const strike = {
                    startX: ep.startX,
                    startY: ep.startY,
                    endX: ep.endX,
                    endY: ep.endY,
                    phase: 'telegraph',
                    timer: 0,
                    zigzag: []
                };
                for (let j = 0; j < 12; j++) {
                    strike.zigzag.push((Math.random() - 0.5) * 30);
                }
                bossLightningStrikes.push(strike);
            }
        }

        function updateLightningStrikes(dt) {
            if (!currentBoss || currentBoss.type !== 'lightningNexus') return;
            if (bossLightningStrikes.length === 0) return;

            let allDone = true;
            for (const s of bossLightningStrikes) {
                s.timer += dt;

                if (s.phase === 'telegraph') {
                    if (s.timer >= 1.5) {
                        s.phase = 'fire';
                        s.timer = 0;
                        triggerShake(6, 200);
                        for (let j = 0; j < s.zigzag.length; j++) {
                            s.zigzag[j] = (Math.random() - 0.5) * 40;
                        }
                    }
                    allDone = false;
                } else if (s.phase === 'fire') {
                    if (Math.random() < 0.5) {
                        for (let j = 0; j < s.zigzag.length; j++) {
                            s.zigzag[j] = (Math.random() - 0.5) * 40;
                        }
                    }
                    if (s.timer >= 0.5) {
                        s.phase = 'cooldown';
                        s.timer = 0;
                    }
                    allDone = false;
                } else if (s.phase === 'cooldown') {
                    if (s.timer < 1.0) {
                        allDone = false;
                    }
                }
            }

            if (allDone) {
                bossLightningStrikes = [];
            }
        }

        function checkLightningStrikeCollisions() {
            if (!currentBoss || currentBoss.type !== 'lightningNexus') return;
            if (player.invulnerable > 0) return;

            for (const s of bossLightningStrikes) {
                if (s.phase !== 'fire') continue;

                // Line-vs-circle collision using stored endpoints
                const dx = s.endX - s.startX;
                const dy = s.endY - s.startY;
                const lenSq = dx * dx + dy * dy;
                let t = ((player.x - s.startX) * dx + (player.y - s.startY) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const closestX = s.startX + t * dx;
                const closestY = s.startY + t * dy;
                const distX = player.x - closestX;
                const distY = player.y - closestY;
                const dist = Math.sqrt(distX * distX + distY * distY);

                if (dist < 12.5 + PLAYER_COLLISION_RADIUS) {
                    damagePlayer();
                    triggerShake(8, 200);
                    triggerFlash('#9F7AEA', 0.3, 150);
                    spawnRing(player.x, player.y, '#9F7AEA', 30);
                    break;
                }
            }
        }

        function renderLightningStrikes() {
            if (!currentBoss || currentBoss.type !== 'lightningNexus') return;
            if (bossLightningStrikes.length === 0) return;

            for (const s of bossLightningStrikes) {
                if (s.phase === 'telegraph') {
                    const blink = Math.sin(s.timer * 12) > 0 ? 0.4 : 0.15;
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(s.startX, s.startY);
                    ctx.lineTo(s.endX, s.endY);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = blink;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                } else if (s.phase === 'fire') {
                    ctx.save();
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    const dx = s.endX - s.startX;
                    const dy = s.endY - s.startY;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const perpX = -dy / len;
                    const perpY = dx / len;
                    const segments = s.zigzag.length;

                    // 3 layers on the same zigzag path (like player lightning)
                    for (let layer = 2; layer >= 0; layer--) {
                        ctx.beginPath();
                        ctx.moveTo(s.startX, s.startY);
                        for (let i = 1; i < segments; i++) {
                            const t = i / segments;
                            const bx = s.startX + dx * t;
                            const by = s.startY + dy * t;
                            ctx.lineTo(bx + perpX * s.zigzag[i], by + perpY * s.zigzag[i]);
                        }
                        ctx.lineTo(s.endX, s.endY);

                        if (layer === 0) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.lineWidth = 2;
                        } else if (layer === 1) {
                            ctx.strokeStyle = 'rgba(159, 122, 234, 0.7)';
                            ctx.lineWidth = 5;
                        } else {
                            ctx.strokeStyle = 'rgba(99, 179, 237, 0.4)';
                            ctx.lineWidth = 10;
                        }
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            }
        }

        // Lightning Lines pattern function — fires lightning + projectiles simultaneously
        function bossPattern_LightningLines(dt) {
            if (!currentBoss) return true;
            const state = bossPatternState;
            state.elapsed += dt;
            state.fireTimer += dt;

            if (!state.initialized) {
                state.initialized = true;
                initLightningLines(state.lineType);
            }

            // Simultaneous projectile fire during the pattern
            const boss = currentBoss;
            const projType = state.projType || 'spiral';
            const isP2 = boss.phase === 2;
            const speed = isP2 ? BOSS_PROJ_SPEED * 1.4 : BOSS_PROJ_SPEED;

            if (projType === 'spiral') {
                // Continuous spiral fire throughout the pattern
                const interval = isP2 ? 0.08 : 0.12;
                if (state.fireTimer >= interval) {
                    state.fireTimer -= interval;
                    if (!state.spiralAngle) state.spiralAngle = 0;
                    spawnBossProjectile(boss.x, boss.y, state.spiralAngle, speed);
                    if (isP2) {
                        // Double spiral in P2
                        spawnBossProjectile(boss.x, boss.y, state.spiralAngle + Math.PI, speed);
                    }
                    state.spiralAngle += 15 * Math.PI / 180;
                }
            } else if (projType === 'burst') {
                // Repeated ring bursts
                const interval = isP2 ? 0.7 : 1.0;
                const count = isP2 ? 32 : 20;
                if (state.fireTimer >= interval && state.bursts < (isP2 ? 4 : 3)) {
                    state.fireTimer -= interval;
                    state.bursts++;
                    const offset = state.bursts * (Math.PI / count);
                    for (let i = 0; i < count; i++) {
                        const angle = (Math.PI * 2 / count) * i + offset;
                        spawnBossProjectile(boss.x, boss.y, angle, speed);
                    }
                }
            } else if (projType === 'corner') {
                // Corner barrage from vertices
                const interval = isP2 ? 0.25 : 0.4;
                const maxBursts = isP2 ? 10 : 6;
                if (state.fireTimer >= interval && state.bursts < maxBursts) {
                    state.fireTimer -= interval;
                    state.bursts++;
                    const sides = boss.sides;
                    for (let i = 0; i < sides; i++) {
                        const vAngle = (Math.PI * 2 / sides) * i + boss.rotation * Math.PI / 180;
                        const sx = boss.x + Math.cos(vAngle) * boss.size;
                        const sy = boss.y + Math.sin(vAngle) * boss.size;
                        spawnBossProjectile(sx, sy, vAngle, speed);
                        if (isP2) {
                            spawnBossProjectile(sx, sy, vAngle + 12 * Math.PI / 180, speed * 0.85);
                            spawnBossProjectile(sx, sy, vAngle - 12 * Math.PI / 180, speed * 0.85);
                        }
                    }
                }
            }

            // Total duration: 1.5 (telegraph) + 0.5 (fire) + 1.0 (cooldown) = 3.0s
            return state.elapsed >= 3.0;
        }

        // --- Lightning Nexus: Chasing Electric Trail ---

        function spawnTrailNode() {
            if (!currentBoss || !player) return;
            const isP2 = currentBoss.phase === 2;
            bossTrailNodes.push({
                x: player.x,
                y: player.y,
                radius: 0,
                maxRadius: 48,
                growing: true,
                growTimer: 0,
                maxGrowTime: isP2 ? 1.0 : 1.5,
                active: false,
                hp: 1066,
                maxHp: 1066
            });
        }

        function destroyTrailNode(nodeIndex) {
            const node = bossTrailNodes[nodeIndex];
            if (!node) return;

            // Find incoming ray (ends at this node) and outgoing ray (starts from this node)
            let incomingIdx = -1;
            let outgoingIdx = -1;
            for (let i = 0; i < bossTrailRays.length; i++) {
                const r = bossTrailRays[i];
                if (r.endX === node.x && r.endY === node.y) incomingIdx = i;
                if (r.startX === node.x && r.startY === node.y) outgoingIdx = i;
            }

            // Merge rays: outgoing ray's start becomes incoming ray's start
            if (incomingIdx !== -1 && outgoingIdx !== -1) {
                bossTrailRays[outgoingIdx].startX = bossTrailRays[incomingIdx].startX;
                bossTrailRays[outgoingIdx].startY = bossTrailRays[incomingIdx].startY;
                bossTrailRays.splice(incomingIdx, 1);
            } else if (incomingIdx !== -1) {
                // Last node in chain — just remove incoming ray
                bossTrailRays.splice(incomingIdx, 1);
            } else if (outgoingIdx !== -1) {
                // First node — reconnect outgoing to boss
                bossTrailRays[outgoingIdx].startX = currentBoss ? currentBoss.x : bossTrailRays[outgoingIdx].startX;
                bossTrailRays[outgoingIdx].startY = currentBoss ? currentBoss.y : bossTrailRays[outgoingIdx].startY;
            }

            // Death shockwave — 12 projectiles from node edges
            const bossColor = currentBoss ? currentBoss.color : '#9F7AEA';
            for (let j = 0; j < 12; j++) {
                const expAngle = (Math.PI * 2 / 12) * j;
                const edgeX = node.x + Math.cos(expAngle) * node.radius;
                const edgeY = node.y + Math.sin(expAngle) * node.radius;
                spawnBossProjectile(edgeX, edgeY, expAngle, BOSS_PROJ_SPEED * 0.9, {
                    color: bossColor,
                    radius: 6,
                    hp: 2,
                    life: 4
                });
            }
            spawnRing(node.x, node.y, bossColor, 40);
            spawnRing(node.x, node.y, bossColor, 60);
            triggerShake(6, 200);

            bossTrailNodes.splice(nodeIndex, 1);
        }

        function updateTrailNodes(dt) {
            if (!currentBoss || currentBoss.type !== 'lightningNexus') return;
            const isP2 = currentBoss.phase === 2;

            // Spawn new nodes on timer
            bossTrailTimer -= dt;
            if (bossTrailTimer <= 0) {
                spawnTrailNode();
                bossTrailTimer = isP2 ? 2.0 : 3.0;
            }

            // Update growing nodes
            for (const node of bossTrailNodes) {
                if (!node.growing) continue;
                node.growTimer += dt;
                node.radius = node.maxRadius * Math.min(1, node.growTimer / node.maxGrowTime);

                // Growth complete — activate and create connecting ray
                if (node.growTimer >= node.maxGrowTime) {
                    node.growing = false;
                    node.active = true;

                    // Find previous active node for ray connection
                    let prevX = currentBoss.x;
                    let prevY = currentBoss.y;
                    const activeNodes = bossTrailNodes.filter(n => n.active && n !== node);
                    if (activeNodes.length > 0) {
                        const prev = activeNodes[activeNodes.length - 1];
                        prevX = prev.x;
                        prevY = prev.y;
                    }

                    bossTrailRays.push({
                        startX: prevX,
                        startY: prevY,
                        endX: node.x,
                        endY: node.y
                    });
                }
            }

            // Cap at 10 nodes — remove oldest node + its incoming ray, reconnect next ray
            while (bossTrailNodes.length > 10) {
                bossTrailNodes.shift();
                if (bossTrailRays.length > 0) bossTrailRays.shift();
                // Reconnect the next ray's start to the boss (since its previous start node was removed)
                if (bossTrailRays.length > 0) {
                    bossTrailRays[0].startX = currentBoss.x;
                    bossTrailRays[0].startY = currentBoss.y;
                }
            }
        }

        function checkTrailCollisions() {
            if (!currentBoss || currentBoss.type !== 'lightningNexus') return;
            if (player.invulnerable > 0) return;
            if (player._bossDmgCooldown > 0) return;

            // Check circle borders (ring collision)
            for (const node of bossTrailNodes) {
                if (!node.active) continue; // only damage when fully grown
                const dx = player.x - node.x;
                const dy = player.y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const ringDist = Math.abs(dist - node.radius);
                if (ringDist < 15 + PLAYER_COLLISION_RADIUS) {
                    player._bossDmgCooldown = 0.12;
                    damagePlayer();
                    triggerShake(6, 150);
                    triggerFlash('#9F7AEA', 0.3, 150);
                    spawnRing(player.x, player.y, '#00FFFF', 25);
                    return;
                }
            }

            // Check rays (line segment collision)
            for (const ray of bossTrailRays) {
                const dx = ray.endX - ray.startX;
                const dy = ray.endY - ray.startY;
                const lenSq = dx * dx + dy * dy;
                if (lenSq === 0) continue;
                let t = ((player.x - ray.startX) * dx + (player.y - ray.startY) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const closestX = ray.startX + t * dx;
                const closestY = ray.startY + t * dy;
                const distX = player.x - closestX;
                const distY = player.y - closestY;
                const dist = Math.sqrt(distX * distX + distY * distY);

                if (dist < 12.5 + PLAYER_COLLISION_RADIUS) {
                    player._bossDmgCooldown = 0.12;
                    damagePlayer();
                    triggerShake(6, 150);
                    triggerFlash('#9F7AEA', 0.3, 150);
                    spawnRing(player.x, player.y, '#9F7AEA', 25);
                    return;
                }
            }
        }

        function renderTrailNodes() {
            if (!currentBoss || currentBoss.type !== 'lightningNexus') return;

            // Render rays (lightning bolts between nodes)
            for (const ray of bossTrailRays) {
                const dx = ray.endX - ray.startX;
                const dy = ray.endY - ray.startY;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len < 1) continue;
                const perpX = -dy / len;
                const perpY = dx / len;
                const segments = Math.max(8, Math.floor(len / 40));

                // Single zigzag path, regenerated each frame
                const zigzag = [];
                for (let i = 0; i <= segments; i++) {
                    zigzag.push(i === 0 || i === segments ? 0 : (Math.random() - 0.5) * 25);
                }

                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // 3 layers on the same zigzag (like player lightning)
                for (let layer = 2; layer >= 0; layer--) {
                    ctx.beginPath();
                    for (let i = 0; i <= segments; i++) {
                        const frac = i / segments;
                        const x = ray.startX + dx * frac + perpX * zigzag[i];
                        const y = ray.startY + dy * frac + perpY * zigzag[i];
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }

                    if (layer === 0) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.lineWidth = 1.5;
                    } else if (layer === 1) {
                        ctx.strokeStyle = 'rgba(159, 122, 234, 0.6)';
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = 'rgba(99, 179, 237, 0.35)';
                        ctx.lineWidth = 6;
                    }
                    ctx.stroke();
                }

                ctx.restore();
            }

            // Render nodes (electrified circles)
            for (const node of bossTrailNodes) {
                if (node.radius < 2) continue;

                ctx.save();
                ctx.translate(node.x, node.y);

                if (node.growing) {
                    // Growing: pulsing electric circle with crackling border
                    const pulse = 0.6 + 0.4 * Math.sin(gameTime * 12);
                    const blink = Math.sin(gameTime * 20) > 0 ? 1.0 : 0.5;

                    // Outer electric glow
                    setGlow(ctx, '#00FFFF', 12);
                    ctx.beginPath();
                    ctx.arc(0, 0, node.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.4 * blink * pulse})`;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    clearGlow(ctx);

                    // Inner purple ring
                    ctx.beginPath();
                    ctx.arc(0, 0, node.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(159, 122, 234, ${0.6 * pulse})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Electric crackle sparks along circumference
                    const sparkCount = 6;
                    for (let i = 0; i < sparkCount; i++) {
                        const angle = (Math.PI * 2 / sparkCount) * i + gameTime * 3;
                        const sx = Math.cos(angle) * node.radius;
                        const sy = Math.sin(angle) * node.radius;
                        const jx = (Math.random() - 0.5) * 12;
                        const jy = (Math.random() - 0.5) * 12;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(sx + jx, sy + jy);
                        ctx.strokeStyle = `rgba(0, 255, 255, ${0.8 * blink})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                } else {
                    // Active: solid electric circle — flickers when damaged
                    const hpRatio = node.hp / node.maxHp;
                    const damaged = hpRatio < 1;
                    const flicker = damaged ? (Math.sin(gameTime * 25) > 0 ? 1.0 : 0.4) : 1.0;
                    const baseAlpha = damaged ? (0.3 + 0.5 * hpRatio) : 0.5;

                    setGlow(ctx, damaged ? '#FF4444' : '#9F7AEA', 8);
                    ctx.beginPath();
                    ctx.arc(0, 0, node.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${damaged ? '255, 68, 68' : '159, 122, 234'}, ${baseAlpha * flicker})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    clearGlow(ctx);

                    // Subtle cyan inner ring
                    ctx.beginPath();
                    ctx.arc(0, 0, node.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.2 * flicker})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Faint fill
                    ctx.beginPath();
                    ctx.arc(0, 0, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${damaged ? '255, 68, 68' : '159, 122, 234'}, 0.05)`;
                    ctx.fill();

                    // Damage sparks when low HP
                    if (hpRatio < 0.4) {
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const sx = Math.cos(angle) * node.radius;
                            const sy = Math.sin(angle) * node.radius;
                            ctx.beginPath();
                            ctx.moveTo(sx, sy);
                            ctx.lineTo(sx + (Math.random() - 0.5) * 16, sy + (Math.random() - 0.5) * 16);
                            ctx.strokeStyle = `rgba(255, 68, 68, ${0.8 * flicker})`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }

                ctx.restore();
            }
        }

        // --- Lightning Nexus: Custom Renderer ---

        function renderLightningNexus() {
            const boss = currentBoss;
            const sides = 8; // octagon
            const size = boss.size;

            ctx.save();
            ctx.translate(boss.x, boss.y);
            ctx.rotate(boss.rotation * Math.PI / 180);

            // Pulsating aura
            const auraPulse = Math.sin(gameTime * 5) * 0.15 + 0.25;
            ctx.beginPath();
            ctx.arc(0, 0, size + 25 + Math.sin(gameTime * 3) * 8, 0, Math.PI * 2);
            ctx.fillStyle = '#9F7AEA';
            ctx.globalAlpha = auraPulse * (boss.phase === 2 ? 1.4 : 1);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Outer glow ring
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const px = Math.cos(angle) * (size + 10);
                const py = Math.sin(angle) * (size + 10);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.strokeStyle = '#9F7AEA';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.4 + Math.sin(gameTime * 4) * 0.2;
            setGlow(ctx, '#9F7AEA', 20);
            ctx.stroke();
            clearGlow(ctx);
            ctx.globalAlpha = 1;

            // Main body octagon
            const vertices = [];
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
                const px = Math.cos(angle) * size;
                const py = Math.sin(angle) * size;
                vertices.push({ x: px, y: py });
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            // Fill with purple gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            gradient.addColorStop(0, '#9F7AEA');
            gradient.addColorStop(0.5, '#9F7AEA88');
            gradient.addColorStop(1, '#9F7AEA22');
            ctx.fillStyle = gradient;
            ctx.globalAlpha = boss.phase === 2 ? 0.7 : 0.5;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Border
            ctx.strokeStyle = '#9F7AEA';
            ctx.lineWidth = boss.phase === 2 ? 3 : 2;
            ctx.stroke();

            // Flash white on damage
            if (boss.flashTimer > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, ' + Math.min(boss.flashTimer / 0.1, 0.6) + ')';
                ctx.fill();
            }

            // Electric arcs between vertices — single zigzag, 3 layers
            const arcCount = sides;
            for (let i = 0; i < arcCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % sides];
                const arcDx = v2.x - v1.x;
                const arcDy = v2.y - v1.y;
                const arcLen = Math.sqrt(arcDx * arcDx + arcDy * arcDy);
                if (arcLen < 1) continue;
                const arcPerpX = -arcDy / arcLen;
                const arcPerpY = arcDx / arcLen;

                // Generate single zigzag path
                const segCount = 5;
                const zigzag = [];
                for (let s = 0; s <= segCount; s++) {
                    zigzag.push(s === 0 || s === segCount ? 0 : (Math.random() - 0.5) * 14);
                }

                const isP2 = boss.phase === 2;
                for (let layer = 2; layer >= 0; layer--) {
                    ctx.beginPath();
                    for (let s = 0; s <= segCount; s++) {
                        const t = s / segCount;
                        const bx = v1.x + arcDx * t + arcPerpX * zigzag[s];
                        const by = v1.y + arcDy * t + arcPerpY * zigzag[s];
                        if (s === 0) ctx.moveTo(bx, by); else ctx.lineTo(bx, by);
                    }

                    if (layer === 0) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${isP2 ? 0.8 : 0.5})`;
                        ctx.lineWidth = 1;
                    } else if (layer === 1) {
                        ctx.strokeStyle = `rgba(0, 255, 255, ${isP2 ? 0.6 : 0.35})`;
                        ctx.lineWidth = 2;
                    } else {
                        ctx.strokeStyle = `rgba(159, 122, 234, ${isP2 ? 0.3 : 0.15})`;
                        ctx.lineWidth = 4;
                    }
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                }
            }

            // Pulsating center core
            const coreSize = 14 + Math.sin(gameTime * 6) * 5;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFFFF';
            ctx.globalAlpha = 0.7 + Math.sin(gameTime * 8) * 0.3;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Inner electric ring
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.3 + Math.sin(gameTime * 7) * 0.15;
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Phase 2: inner octagon spinning opposite + constant spark particles
            if (boss.phase === 2) {
                ctx.save();
                ctx.rotate(-boss.rotation * 2 * Math.PI / 180);
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (Math.PI * 2 / sides) * i;
                    const px = Math.cos(angle) * (size * 0.55);
                    const py = Math.sin(angle) * (size * 0.55);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            ctx.restore();

            // Phase 2 constant spark particles (outside translate/rotate context)
            if (boss.phase === 2 && Math.random() < 0.4) {
                const sparkAngle = Math.random() * Math.PI * 2;
                const sparkDist = boss.size + Math.random() * 30;
                const sx = boss.x + Math.cos(sparkAngle) * sparkDist;
                const sy = boss.y + Math.sin(sparkAngle) * sparkDist;
                const p = pools.particle.acquire();
                p.x = sx; p.y = sy;
                p.vx = (Math.random() - 0.5) * 80;
                p.vy = (Math.random() - 0.5) * 80;
                p.life = 0.25; p.maxLife = 0.25;
                p.size = 3 + Math.random() * 4;
                p.color = Math.random() < 0.5 ? '#9F7AEA' : '#00FFFF';
                p.type = 'spark';
                particles.push(p);
            }
        }

        // --- Lightning Nexus: Attack Sequences ---

        const LN_PHASE1_SEQUENCE = [
            { pattern: 'gridVH', proj: 'spiral', pause: 2 },
            { pattern: 'singleDiagonal', proj: 'corner', pause: 2 },
            { pattern: 'gridDiag3', proj: 'burst', pause: 2 }
        ];
        const LN_PHASE2_SEQUENCE = [
            { pattern: 'vertical5', proj: 'corner', pause: 1 },
            { pattern: 'horizontal5', proj: 'burst', pause: 1 },
            { pattern: 'gridDiag5', proj: 'spiral', pause: 1 }
        ];

        function getLNPattern(name) {
            return bossPattern_LightningLines;
        }

        function getLNPatternState(entry) {
            return {
                elapsed: 0, fireTimer: 0, angle: 0, bursts: 0, fired: false,
                initialized: false, lineType: entry.pattern, projType: entry.proj
            };
        }

        // ============================================================

        function updateSpawnSystem() {
            // Decay spawn interval over time
            if (gameTime - lastSpawnDecayTime > SPAWN_DECAY_INTERVAL) {
                spawnInterval *= (1 - SPAWN_DECAY_RATE);
                spawnInterval = Math.max(MIN_SPAWN_INTERVAL, spawnInterval);
                lastSpawnDecayTime = gameTime;
                waveNumber++;
            }

            // Spawn enemies
            spawnTimer -= deltaTime;
            // Scale max enemies with wave number (+5 enemies per wave)
            const baseMaxEnemies = lowPerfMode ? MAX_ENEMIES_LOW_PERF : MAX_ENEMIES;
            const maxEnemies = baseMaxEnemies + (waveNumber * 5);

            if (spawnTimer <= 0 && enemies.length < maxEnemies) {
                spawnEnemy();
                spawnTimer = spawnInterval + Math.random() * (spawnInterval * 0.5);
            }

            // Wave system - starts aggressively from level 2
            if (playerLevel >= 2) {
                waveTimer -= deltaTime;
                if (waveTimer <= 0) {
                    // Spawn 1-3 waves simultaneously at higher levels
                    const simultaneousWaves = playerLevel >= 5 ? (Math.random() < 0.4 ? 2 : 1) : 1;
                    for (let w = 0; w < simultaneousWaves; w++) {
                        spawnWave();
                    }
                    // Faster waves as level increases (minimum 1.2 seconds between waves)
                    const levelSpeedBonus = Math.min((playerLevel - 2) * 0.25, 1.8);
                    waveTimer = Math.max(1.2, WAVE_INTERVAL_BASE - levelSpeedBonus) + Math.random() * WAVE_INTERVAL_VARIANCE;
                }
            }
        }

        function getWaveSubtitle(pattern) {
            const subtitles = {
                'arc': 'ARC FORMATION',
                'side': 'FLANK ATTACK',
                'pincer': 'PINCER INCOMING',
                'circle': 'SURROUNDED',
                'line': 'LINE ASSAULT',
                'cluster': 'CLUSTER SWARM',
                'spiral': 'SPIRAL CONVERGENCE',
                'corners': 'CORNER AMBUSH',
                'rush': 'ENEMY RUSH',
                'scatter': 'SCATTER ASSAULT',
                'v_formation': 'V-FORMATION'
            };
            return subtitles[pattern] || 'HOSTILES INCOMING';
        }

        function spawnWave() {
            if (!player) return;

            // Pick a random pattern different from the last one
            let pattern;
            do {
                pattern = WAVE_PATTERNS[Math.floor(Math.random() * WAVE_PATTERNS.length)];
            } while (pattern === lastWavePattern && WAVE_PATTERNS.length > 1);
            lastWavePattern = pattern;

            // Trigger wave alert
            waveAlertActive = true;
            waveAlertTimer = 0;
            waveAlertNumber = waveNumber;
            waveAlertSubtitle = getWaveSubtitle(pattern);

            // Scale wave size with level (more enemies at higher levels)
            const baseCount = 15 + Math.floor(playerLevel * 4);
            const count = Math.min(baseCount, 60); // Cap at 60 per wave

            // Scale enemy HP based on player level (+25% per level)
            const config = ENEMY_TYPES['SCOUT'];
            const hpMultiplier = 1 + (playerLevel - 1) * 0.25;
            const scaledHp = Math.ceil(config.hp * hpMultiplier);

            const spawnPositions = [];

            switch (pattern) {
                case 'arc': {
                    // Arc around player (original pattern but smaller)
                    const centerAngle = Math.random() * 360;
                    const arcDegrees = 90 + Math.random() * 60; // 90-150 degree arc
                    for (let i = 0; i < count; i++) {
                        const angle = (centerAngle - arcDegrees/2 + (arcDegrees / (count - 1)) * i) * Math.PI / 180;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 100;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'side': {
                    // All from one side in a wall
                    const side = Math.floor(Math.random() * 4); // 0=left, 1=right, 2=top, 3=bottom
                    for (let i = 0; i < count; i++) {
                        let x, y;
                        const spread = (i - count/2) * 25;
                        if (side === 0) { // Left
                            x = player.x - WAVE_SPAWN_DISTANCE;
                            y = player.y + spread;
                        } else if (side === 1) { // Right
                            x = player.x + WAVE_SPAWN_DISTANCE;
                            y = player.y + spread;
                        } else if (side === 2) { // Top
                            x = player.x + spread;
                            y = player.y - WAVE_SPAWN_DISTANCE;
                        } else { // Bottom
                            x = player.x + spread;
                            y = player.y + WAVE_SPAWN_DISTANCE;
                        }
                        spawnPositions.push({ x, y });
                    }
                    break;
                }
                case 'pincer': {
                    // From two opposite sides
                    const horizontal = Math.random() > 0.5;
                    const halfCount = Math.floor(count / 2);
                    for (let i = 0; i < halfCount; i++) {
                        const spread = (i - halfCount/2) * 30;
                        if (horizontal) {
                            spawnPositions.push({ x: player.x - WAVE_SPAWN_DISTANCE, y: player.y + spread });
                            spawnPositions.push({ x: player.x + WAVE_SPAWN_DISTANCE, y: player.y + spread });
                        } else {
                            spawnPositions.push({ x: player.x + spread, y: player.y - WAVE_SPAWN_DISTANCE });
                            spawnPositions.push({ x: player.x + spread, y: player.y + WAVE_SPAWN_DISTANCE });
                        }
                    }
                    break;
                }
                case 'circle': {
                    // Hexagonal staggered pattern (3 inner, 3 outer)
                    // Replaces the unfair "full circle" trap with escape routes
                    const baseAngle = Math.random() * Math.PI * 2;
                    // Screen half-width is 960, so 1100 ensures they are off-screen
                    const innerDist = 1100; 
                    const outerDist = 1500;

                    for (let i = 0; i < count; i++) {
                        // Distribute among 6 clusters
                        const clusterIdx = i % 6;
                        
                        // Even indices (0, 2, 4) are inner (closest)
                        // Odd indices (1, 3, 5) are outer (furthest, filling gaps)
                        const isInner = clusterIdx % 2 === 0;
                        
                        // 6 points of hexagon: 0, 60, 120, 180, 240, 300 degrees
                        const angleStep = Math.PI / 3; 
                        const clusterAngle = baseAngle + (clusterIdx * angleStep);

                        // Random spread within the cluster
                        const spreadAngle = (Math.random() - 0.5) * 0.4; // ~20 degree spread
                        const finalAngle = clusterAngle + spreadAngle;

                        const baseDist = isInner ? innerDist : outerDist;
                        const distVariation = Math.random() * 150; // Depth variation
                        const dist = baseDist + distVariation;

                        spawnPositions.push({
                            x: player.x + Math.cos(finalAngle) * dist,
                            y: player.y + Math.sin(finalAngle) * dist
                        });
                    }
                    break;
                }
                case 'line': {
                    // Diagonal line sweeping towards player
                    const angle = Math.random() * 360 * Math.PI / 180;
                    const perpAngle = angle + Math.PI / 2;
                    for (let i = 0; i < count; i++) {
                        const offset = (i - count/2) * 35;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * WAVE_SPAWN_DISTANCE + Math.cos(perpAngle) * offset,
                            y: player.y + Math.sin(angle) * WAVE_SPAWN_DISTANCE + Math.sin(perpAngle) * offset
                        });
                    }
                    break;
                }
                case 'cluster': {
                    // Tight cluster from one direction
                    const angle = Math.random() * 360 * Math.PI / 180;
                    for (let i = 0; i < count; i++) {
                        const offsetAngle = angle + (Math.random() - 0.5) * 0.5;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 150;
                        spawnPositions.push({
                            x: player.x + Math.cos(offsetAngle) * dist,
                            y: player.y + Math.sin(offsetAngle) * dist
                        });
                    }
                    break;
                }
                case 'spiral': {
                    // Spiral pattern
                    const startAngle = Math.random() * 360;
                    for (let i = 0; i < count; i++) {
                        const angle = (startAngle + i * 25) * Math.PI / 180;
                        const dist = WAVE_SPAWN_DISTANCE + i * 15;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'corners': {
                    // From all 4 corners
                    const perCorner = Math.floor(count / 4);
                    const corners = [
                        { dx: -1, dy: -1 },
                        { dx: 1, dy: -1 },
                        { dx: -1, dy: 1 },
                        { dx: 1, dy: 1 }
                    ];
                    for (const corner of corners) {
                        for (let i = 0; i < perCorner; i++) {
                            const spreadX = (Math.random() - 0.5) * 200;
                            const spreadY = (Math.random() - 0.5) * 200;
                            spawnPositions.push({
                                x: player.x + corner.dx * WAVE_SPAWN_DISTANCE * 0.7 + spreadX,
                                y: player.y + corner.dy * WAVE_SPAWN_DISTANCE * 0.7 + spreadY
                            });
                        }
                    }
                    break;
                }
                case 'rush': {
                    // Dense column rushing from one direction
                    const rushAngle = Math.random() * 360 * Math.PI / 180;
                    const perpAngle = rushAngle + Math.PI / 2;
                    const rows = 4;
                    const perRow = Math.ceil(count / rows);
                    for (let row = 0; row < rows; row++) {
                        for (let i = 0; i < perRow; i++) {
                            const offset = (i - perRow/2) * 20;
                            const rowDist = row * 40;
                            spawnPositions.push({
                                x: player.x + Math.cos(rushAngle) * (WAVE_SPAWN_DISTANCE + rowDist) + Math.cos(perpAngle) * offset,
                                y: player.y + Math.sin(rushAngle) * (WAVE_SPAWN_DISTANCE + rowDist) + Math.sin(perpAngle) * offset
                            });
                        }
                    }
                    break;
                }
                case 'scatter': {
                    // Random positions all around (chaotic)
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 300 - 150;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'v_formation': {
                    // V-shape formation flying towards player
                    const vAngle = Math.random() * 360 * Math.PI / 180;
                    const halfCount = Math.floor(count / 2);
                    for (let i = 0; i < halfCount; i++) {
                        const offset = i * 30;
                        const depth = i * 25;
                        // Left wing of V
                        spawnPositions.push({
                            x: player.x + Math.cos(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.cos(vAngle + Math.PI/2) * offset,
                            y: player.y + Math.sin(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.sin(vAngle + Math.PI/2) * offset
                        });
                        // Right wing of V
                        spawnPositions.push({
                            x: player.x + Math.cos(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.cos(vAngle - Math.PI/2) * offset,
                            y: player.y + Math.sin(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.sin(vAngle - Math.PI/2) * offset
                        });
                    }
                    break;
                }
            }

            // Spawn all enemies in the wave
            for (const pos of spawnPositions) {
                const angleToPlayer = Math.atan2(player.y - pos.y, player.x - pos.x);

                const enemy = pools.enemy.acquire();
                enemy.x = pos.x;
                enemy.y = pos.y;
                enemy.vx = Math.cos(angleToPlayer) * config.speed * 0.5;
                enemy.vy = Math.sin(angleToPlayer) * config.speed * 0.5;
                enemy.angle = angleToPlayer * 180 / Math.PI;
                enemy.type = 'SCOUT';
                enemy.hp = scaledHp;
                enemy.maxHp = scaledHp;
                enemy.fireTimer = 0;
                enemy.burstCooldown = 0;
                enemy.spawnTime = gameTime;
                enemy.offScreenTime = 0;
                enemies.push(enemy);
            }
        }
        
        function spawnEnemy() {
            if (!player) return; // Safety check

            // Determine enemy type based on wave/score
            let type = 'SCOUT';
            const r = Math.random();

            if (score > 5000 && r < 0.08) {
                type = 'TANK';
            } else if (waveNumber >= 10 && r < 0.20) {
                type = 'KAMIKAZE';
            }

            // Spawn position relative to PLAYER (not canvas bounds)
            const side = Math.floor(Math.random() * 4);
            let x, y;
            const offset = ENEMY_SPAWN_OFFSET_MIN + Math.random() * ENEMY_SPAWN_OFFSET_RANGE;
            const spawnDistance = CANVAS_WIDTH / 2 + offset;

            switch (side) {
                case 0: // Left
                    x = player.x - spawnDistance;
                    y = player.y + (Math.random() - 0.5) * CANVAS_HEIGHT;
                    break;
                case 1: // Right
                    x = player.x + spawnDistance;
                    y = player.y + (Math.random() - 0.5) * CANVAS_HEIGHT;
                    break;
                case 2: // Top
                    x = player.x + (Math.random() - 0.5) * CANVAS_WIDTH;
                    y = player.y - spawnDistance;
                    break;
                case 3: // Bottom
                    x = player.x + (Math.random() - 0.5) * CANVAS_WIDTH;
                    y = player.y + spawnDistance;
                    break;
            }

            const config = ENEMY_TYPES[type];
            const angleToPlayer = Math.atan2(player.y - y, player.x - x);
            
            // Scale enemy HP based on player level (+40% per level)
            const hpMultiplier = 1 + (playerLevel - 1) * 0.40;
            const scaledHp = Math.ceil(config.hp * hpMultiplier);

            const enemy = pools.enemy.acquire();
            enemy.x = x;
            enemy.y = y;
            enemy.vx = Math.cos(angleToPlayer) * config.speed * 0.5;
            enemy.vy = Math.sin(angleToPlayer) * config.speed * 0.5;
            enemy.angle = angleToPlayer * 180 / Math.PI;
            enemy.type = type;
            enemy.hp = scaledHp;
            enemy.maxHp = scaledHp;
            enemy.fireTimer = config.fireRate || 0;
            enemy.burstCooldown = 0;
            enemy.spawnTime = gameTime;
            enemy.offScreenTime = 0;
            enemies.push(enemy);
        }
        
        function updateEnemies() {
            if (!player) return; // Safety check

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const config = ENEMY_TYPES[e.type];
                // Speed scaling removed - constant speed
                const speed = config.speed;

                // Seek player with limited turn rate
                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                const angleDiff = normalizeAngle(targetAngle - e.angle);
                
                const maxTurn = config.turnRate * deltaTime;
                if (Math.abs(angleDiff) > maxTurn) {
                    e.angle += Math.sign(angleDiff) * maxTurn;
                } else {
                    e.angle = targetAngle;
                }
                
                // Apply velocity toward facing direction
                const rad = e.angle * Math.PI / 180;
                const targetVx = Math.cos(rad) * speed;
                const targetVy = Math.sin(rad) * speed;
                
                // Smooth acceleration
                e.vx += (targetVx - e.vx) * deltaTime * 2;
                e.vy += (targetVy - e.vy) * deltaTime * 2;
                
                // Tank burst
                if (e.type === 'TANK') {
                    e.burstCooldown -= deltaTime;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    if (e.burstCooldown <= 0 && distToPlayer < 200) {
                        e.vx = Math.cos(rad) * 280;
                        e.vy = Math.sin(rad) * 280;
                        e.burstCooldown = 6;
                    }
                }
                
                // Spinner fires
                if (e.type === 'SPINNER') {
                    e.fireTimer -= deltaTime;
                    if (e.fireTimer <= 0) {
                        fireSpinnerBullets(e);
                        e.fireTimer = config.fireRate;
                    }
                }
                
                // Separation from other enemies (using spatial grid)
                const nearbyEnemies = spatialGrid.queryRadius(e.x, e.y, config.radius * 4);
                for (const other of nearbyEnemies) {
                    if (other === e) continue; // Skip self

                    const sepDx = e.x - other.x;
                    const sepDy = e.y - other.y;
                    const sepDistSq = sepDx * sepDx + sepDy * sepDy;
                    const minDist = config.radius + ENEMY_TYPES[other.type].radius + ENEMY_SEPARATION_PADDING;
                    const minDistSq = minDist * minDist;

                    if (sepDistSq < minDistSq && sepDistSq > 0) {
                        const sepDist = Math.sqrt(sepDistSq);
                        const push = (minDist - sepDist) * 0.5;
                        const pushX = (sepDx / sepDist) * push;
                        const pushY = (sepDy / sepDist) * push;
                        e.vx += pushX;
                        e.vy += pushY;
                        other.vx -= pushX;
                        other.vy -= pushY;
                    }
                }
                
                // Update position
                e.x += e.vx * deltaTime;
                e.y += e.vy * deltaTime;

                // Transport enemy if too far from player (wrap around world)
                const relX = e.x - player.x;
                const relY = e.y - player.y;

                // If enemy is beyond 1.5 sectors away, transport to opposite side
                if (relX > SECTOR_WIDTH * 1.5) {
                    e.x -= 3 * SECTOR_WIDTH;
                } else if (relX < -SECTOR_WIDTH * 1.5) {
                    e.x += 3 * SECTOR_WIDTH;
                }

                if (relY > SECTOR_HEIGHT * 1.5) {
                    e.y -= 3 * SECTOR_HEIGHT;
                } else if (relY < -SECTOR_HEIGHT * 1.5) {
                    e.y += 3 * SECTOR_HEIGHT;
                }

                // Spinner self-destruct
                if (e.type === 'SPINNER' && gameTime - e.spawnTime > 20) {
                    pools.enemy.release(e);
                    fastRemove(enemies, i);
                    spawnRing(e.x, e.y, config.color, 40);
                }
            }
        }
        
        function fireSpinnerBullets(enemy) {
            const bulletCount = 6;
            for (let i = 0; i < bulletCount; i++) {
                const angle = (360 / bulletCount) * i + enemy.angle;
                const rad = angle * Math.PI / 180;
                const bullet = pools.enemyBullet.acquire();
                bullet.x = enemy.x;
                bullet.y = enemy.y;
                bullet.vx = Math.cos(rad) * 260;
                bullet.vy = Math.sin(rad) * 260;
                bullet.life = 2;
                enemyBullets.push(bullet);
            }
        }
        
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.x += b.vx * deltaTime;
                b.y += b.vy * deltaTime;
                b.life -= deltaTime;

                // Remove enemy bullets that are too far from camera or expired
                // Allow bullets to travel across adjacent sectors
                const distFromCamera = Math.sqrt(
                    Math.pow(b.x - camera.x, 2) +
                    Math.pow(b.y - camera.y, 2)
                );
                const maxDistance = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 3; // 5760px

                if (b.life <= 0 || distFromCamera > maxDistance) {
                    pools.enemyBullet.release(b);
                    fastRemove(enemyBullets, i);
                }
            }
        }
        
        function killEnemy(enemy, index) {
            const config = ENEMY_TYPES[enemy.type];

            // Increment kill counter
            totalKills++;

            // Add score
            score += config.points;

            // Spawn explosion ring
            spawnRing(enemy.x, enemy.y, config.color, 40);
            
            // Direct XP gain
            const xpValue = enemy.type === 'TANK' ? 3 : (enemy.type === 'SPINNER' ? 2 : 1);
            collectXP(xpValue);
            
            // Tank splits into scouts
            if (enemy.type === 'TANK') {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const scout = pools.enemy.acquire();
                    scout.x = enemy.x + Math.cos(angle) * 30;
                    scout.y = enemy.y + Math.sin(angle) * 30;
                    scout.vx = Math.cos(angle) * 60;
                    scout.vy = Math.sin(angle) * 60;
                    scout.angle = angle * 180 / Math.PI;
                    scout.type = 'SCOUT';
                    scout.hp = 1;
                    scout.maxHp = 1;
                    scout.fireTimer = 0;
                    scout.burstCooldown = 0;
                    scout.spawnTime = gameTime;
                    scout.offScreenTime = 0;
                    enemies.push(scout);
                }
            }
            
            // Maybe spawn pickup
            if (Math.random() < 0.01) {
                spawnPickup(enemy.x, enemy.y);
            }

            // Spawn alien drones if skill unlocked
            spawnAlienDrone(enemy.x, enemy.y);

            pools.enemy.release(enemy);
            fastRemove(enemies, index);
        }

        // ============================================================
        // PICKUPS
        // ============================================================
        
        function spawnPickup(x, y) {
            // Always try to spawn a pickup, but the type determines if we actually do it
            const rand = Math.random();
            let type = null;

            // 20% Health
            // 80% Nothing

            if (rand < 0.20) {
                type = 'health';
            } else {
                return; // 80% chance of no pickup
            }
            
            const pickup = pools.pickup.acquire();
            pickup.x = x;
            pickup.y = y;
            pickup.type = type;
            pickup.life = 10;
            pickup.bobTimer = Math.random() * Math.PI * 2;
            pickups.push(pickup);
        }
        
        function updatePickups() {
            if (!player) return; // Safety check

            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                p.life -= deltaTime;
                p.bobTimer += deltaTime;

                if (p.life <= 0) {
                    pools.pickup.release(p);
                    fastRemove(pickups, i);
                    continue;
                }

                // Transport pickup if too far from player (wrap around world)
                const relX = p.x - player.x;
                const relY = p.y - player.y;

                if (relX > SECTOR_WIDTH * 1.5) {
                    p.x -= 3 * SECTOR_WIDTH;
                } else if (relX < -SECTOR_WIDTH * 1.5) {
                    p.x += 3 * SECTOR_WIDTH;
                }

                if (relY > SECTOR_HEIGHT * 1.5) {
                    p.y -= 3 * SECTOR_HEIGHT;
                } else if (relY < -SECTOR_HEIGHT * 1.5) {
                    p.y += 3 * SECTOR_HEIGHT;
                }

                // Check collision with player
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Magnet effect - attract pickups within range with acceleration
                if (dist < PICKUP_MAGNET_RADIUS && dist > 0) {
                    // Lerp factor increases as pickup gets closer (faster pull when near)
                    const pullStrength = 1 - (dist / PICKUP_MAGNET_RADIUS);
                    const lerpFactor = 8 * pullStrength * pullStrength * deltaTime;
                    p.x += dx * lerpFactor;
                    p.y += dy * lerpFactor;
                }
                
                if (dist < PLAYER_COLLISION_RADIUS + 15) {
                    if (p.type === 'health') {
                        if (player.hp < PLAYER_MAX_HP) {
                            player.hp++;
                            spawnFloatingText(p.x, p.y, '+1 Hull', COLORS.POWERUP);
                        } else {
                            score += 50;
                            spawnFloatingText(p.x, p.y, '+50', COLORS.GOLD);
                        }
                    } else {
                        score += 20;
                        spawnFloatingText(p.x, p.y, '+20', COLORS.GOLD);
                    }

                    // Pickup effect
                    for (let j = 0; j < 8; j++) {
                        const angle = (Math.PI * 2 / 8) * j;
                        particles.push({
                            x: p.x,
                            y: p.y,
                            vx: Math.cos(angle) * 80,
                            vy: Math.sin(angle) * 80,
                            life: 0.4,
                            maxLife: 0.4,
                            size: 4,
                            color: p.type === 'health' ? COLORS.POWERUP : COLORS.GOLD,
                            type: 'pickup'
                        });
                    }

                    pools.pickup.release(p);
                    fastRemove(pickups, i);
                }
            }
        }

        // ============================================================
        // XP & LEVEL SYSTEM
        // ============================================================

        function collectXP(amount) {
            playerXP += amount;

            let levelsGained = 0;
            while (playerXP >= xpToNextLevel) {
                playerXP -= xpToNextLevel;
                playerLevel++;
                xpToNextLevel = Math.floor(XP_PER_LEVEL_BASE * Math.pow(XP_PER_LEVEL_GROWTH, playerLevel - 1));
                skillPoints++;
                levelsGained++;
            }

            // Only trigger effects and open skill tree once if leveled up
            if (levelsGained > 0) {
                levelUp(levelsGained);
            }
        }

        function levelUp(levelsGained = 1) {
            // Only show upgrade panel if there are still skills to unlock
            if (!allSkillsUnlocked()) {
                showUpgradePanel();
            }

            // Effects (more intense if multiple levels)
            const intensity = Math.min(levelsGained, 3);
            triggerFlash(COLORS.XP, 0.2 + intensity * 0.1, 200);
            triggerSlowmo(100 * intensity);

            // Show floating text for multiple levels
            if (levelsGained > 1 && player) {
                spawnFloatingText(player.x, player.y - 40, 'LEVEL UP x' + levelsGained + '!', COLORS.XP);
            }
        }
        
        // Check if a skill can be unlocked
        function canUnlockSkill(skillId) {
            if (unlockedSkills.includes(skillId)) return false;
            if (skillPoints < SKILL_TREE[skillId].cost) return false;

            // Block weapons not permanently unlocked
            if (WEAPON_IDS.includes(skillId) && !currentRunUnlockedWeapons.includes(skillId)) return false;
            // Block upgrades whose parent weapon is not permanently unlocked
            for (const wid of WEAPON_IDS) {
                if (WEAPON_UPGRADES[wid] && WEAPON_UPGRADES[wid].includes(skillId) && !currentRunUnlockedWeapons.includes(wid)) return false;
            }

            const skill = SKILL_TREE[skillId];
            for (const prereq of skill.prereqs) {
                if (!unlockedSkills.includes(prereq)) return false;
            }
            return true;
        }
        
        // Get list of available (unlockable) skills
        function getAvailableSkills() {
            const available = [];
            for (const skillId of Object.keys(SKILL_TREE)) {
                if (canUnlockSkill(skillId)) {
                    available.push(skillId);
                }
            }
            return available;
        }
        
        // Check if all skills have been unlocked
        function allSkillsUnlocked() {
            // Count total unlockable skills (excluding the base 'arsenal' and 'laser_cannon' skills)
            const totalSkills = Object.keys(SKILL_TREE).filter(skillId => 
                skillId !== 'arsenal' && skillId !== 'laser_cannon'
            ).length;
            const unlockedCount = unlockedSkills.filter(skillId => 
                skillId !== 'arsenal' && skillId !== 'laser_cannon'
            ).length;
            return unlockedCount >= totalSkills;
        }
        
        // Generate 3 random upgrade options from available skills
        function generateUpgradeOptions() {
            const available = getAvailableSkills();
            if (available.length <= 3) return [...available];
            const shuffled = [...available].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 3);
        }

        // Draw a skill icon on a canvas context
        function drawSkillIcon(ctx, icon, cx, cy, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            if (icon === 'arsenal') {
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'laser') {
                ctx.beginPath();
                ctx.moveTo(cx + 10, cy);
                ctx.lineTo(cx - 6, cy - 7);
                ctx.lineTo(cx - 3, cy);
                ctx.lineTo(cx - 6, cy + 7);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'rocket') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - 10);
                ctx.lineTo(cx + 5, cy + 8);
                ctx.lineTo(cx, cy + 5);
                ctx.lineTo(cx - 5, cy + 8);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'orbital') {
                ctx.beginPath();
                ctx.arc(cx, cy, 9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'lightning') {
                ctx.beginPath();
                ctx.moveTo(cx + 2, cy - 9);
                ctx.lineTo(cx - 3, cy);
                ctx.lineTo(cx + 1, cy);
                ctx.lineTo(cx - 2, cy + 9);
                ctx.lineTo(cx + 4, cy - 2);
                ctx.lineTo(cx, cy - 2);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'rate') {
                ctx.beginPath();
                ctx.moveTo(cx - 5, cy - 5);
                ctx.lineTo(cx + 2, cy);
                ctx.lineTo(cx - 5, cy + 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + 1, cy - 5);
                ctx.lineTo(cx + 8, cy);
                ctx.lineTo(cx + 1, cy + 5);
                ctx.stroke();
            } else if (icon === 'beam') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillRect(cx - 10, cy - 1, 20, 2);
            } else if (icon === 'spread') {
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy - 7);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy + 7);
                ctx.stroke();
            } else if (icon === 'target') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'cluster') {
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    ctx.beginPath();
                    ctx.arc(cx + Math.cos(angle) * 6, cy + Math.sin(angle) * 6, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (icon === 'damage') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx + 6, cy + 2);
                ctx.lineTo(cx + 2, cy + 2);
                ctx.lineTo(cx + 2, cy + 8);
                ctx.lineTo(cx - 2, cy + 8);
                ctx.lineTo(cx - 2, cy + 2);
                ctx.lineTo(cx - 6, cy + 2);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'regen') {
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 1.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + 5, cy);
                ctx.lineTo(cx + 9, cy - 3);
                ctx.lineTo(cx + 9, cy + 3);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'shockwave') {
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 8, Math.PI * 0.2, Math.PI * 0.8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 8, Math.PI * 1.2, Math.PI * 1.8);
                ctx.stroke();
            } else if (icon === 'absorb') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillRect(cx - 4, cy - 1, 8, 2);
                ctx.fillRect(cx - 1, cy - 4, 2, 8);
            } else if (icon === 'chain') {
                ctx.beginPath();
                ctx.arc(cx - 3, cy - 1, 4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx + 3, cy + 1, 4, 0, Math.PI * 2);
                ctx.stroke();
            } else if (icon === 'discharge') {
                for (let i = 0; i < 3; i++) {
                    const ox = (i - 1) * 5;
                    ctx.beginPath();
                    ctx.moveTo(cx + ox + 1, cy - 5);
                    ctx.lineTo(cx + ox - 1, cy);
                    ctx.lineTo(cx + ox, cy);
                    ctx.lineTo(cx + ox - 1, cy + 5);
                    ctx.stroke();
                }
            } else if (icon === 'arc') {
                ctx.beginPath();
                ctx.arc(cx, cy, 8, -Math.PI * 0.6, Math.PI * 0.6);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 5, -Math.PI * 0.6, Math.PI * 0.6);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'aura') {
                // Aura rings
                ctx.beginPath();
                ctx.arc(cx, cy, 9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'expand') {
                // Expanding arrows
                ctx.beginPath();
                ctx.moveTo(cx - 8, cy);
                ctx.lineTo(cx - 4, cy);
                ctx.moveTo(cx + 4, cy);
                ctx.lineTo(cx + 8, cy);
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx, cy - 4);
                ctx.moveTo(cx, cy + 4);
                ctx.lineTo(cx, cy + 8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.stroke();
            } else if (icon === 'pulse') {
                // Pulsing rings
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'drone') {
                // Hexagon drone shape
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * 8;
                    const y = cy + Math.sin(angle) * 8;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'swarm') {
                // Two small drones
                [-5, 5].forEach(ox => {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                        const x = cx + ox + Math.cos(angle) * 5;
                        const y = cy + Math.sin(angle) * 5;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                });
            } else if (icon === 'explosion') {
                // Explosion burst
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerR = 3;
                    const outerR = 9;
                    const r = i % 2 === 0 ? outerR : innerR;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }

        // Show the upgrade selection panel
        function showUpgradePanel() {
            upgradeOptions = generateUpgradeOptions();

            if (upgradeOptions.length === 0) return;

            upgradeSelectionActive = true;
            gameState = 'skilltree';

            // Hide joystick
            joystickActive = false;
            joystickMagnitude = 0;
            const joystickBase = document.getElementById('joystickBase');
            const joystickZone = document.getElementById('joystickZone');
            if (joystickBase) joystickBase.style.display = 'none';
            if (joystickZone) joystickZone.style.display = 'none';

            // Build cards
            const cardsContainer = document.getElementById('upgradeCards');
            cardsContainer.innerHTML = '';

            upgradeOptions.forEach((skillId, index) => {
                const skill = SKILL_TREE[skillId];
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.style.setProperty('--skill-color', skill.color);
                card.style.setProperty('--skill-color-glow', skill.color + '40');

                const isMobile = window.matchMedia('(pointer: coarse)').matches;
                const keyHint = isMobile ? '' : `<div class="upgrade-key">${index + 1}</div>`;

                card.innerHTML = `
                    <div class="upgrade-icon" style="background: ${skill.color}15; border: 2px solid ${skill.color};">
                        <canvas class="skill-icon-canvas" width="40" height="40" data-icon="${skill.icon}" data-color="${skill.color}"></canvas>
                    </div>
                    <div class="upgrade-info">
                        <div class="upgrade-name" style="color: ${skill.color};">${skill.name}</div>
                        <div class="upgrade-desc">${skill.description}</div>
                    </div>
                    ${keyHint}
                `;

                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectUpgrade(skillId);
                });

                cardsContainer.appendChild(card);
            });

            // Render icons on mini canvases
            const canvases = document.querySelectorAll('.skill-icon-canvas');
            canvases.forEach(c => {
                const iconCtx = c.getContext('2d');
                drawSkillIcon(iconCtx, c.dataset.icon, 20, 20, c.dataset.color);
            });

            document.getElementById('upgradePanel').classList.add('active');
        }

        // Select an upgrade option
        function selectUpgrade(skillId) {
            if (!upgradeSelectionActive) return;
            if (!canUnlockSkill(skillId)) return;

            const skill = SKILL_TREE[skillId];
            skillPoints -= skill.cost;
            unlockedSkills.push(skillId);

            spawnFloatingText(player.x, player.y - 40, skill.name + '!', skill.color);

            // Celebration particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(angle) * (80 + Math.random() * 60),
                    vy: Math.sin(angle) * (80 + Math.random() * 60),
                    life: 0.5, maxLife: 0.5,
                    size: 4 + Math.random() * 4,
                    color: skill.color,
                    type: 'levelup'
                });
            }

            hideUpgradePanel();

            // Show again if more skill points remain
            if (skillPoints > 0 && !allSkillsUnlocked()) {
                setTimeout(() => showUpgradePanel(), 300);
            }
        }

        // Hide upgrade panel and resume game
        function hideUpgradePanel() {
            upgradeSelectionActive = false;
            document.getElementById('upgradePanel').classList.remove('active');
            gameState = 'playing';

            // Re-enable joystick zone and base
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            if (joystickZone) joystickZone.style.display = 'block';
            if (joystickBase) joystickBase.style.display = 'block';
        }
        
        // ============================================================
        // WEAPON SYSTEMS
        // ============================================================
        
        function updateWeapons() {
            // Orbital shields
            if (unlockedSkills.includes('orbital_shield')) {
                updateOrbitals();
            }
            // Plasma Field
            if (unlockedSkills.includes('plasma_field')) {
                updateAura();
            }
            // Lightning effects
            updateLightningEffects();
        }

        function updateLightningEffects() {
            for (let i = lightningEffects.length - 1; i >= 0; i--) {
                const effect = lightningEffects[i];
                effect.life -= deltaTime;

                if (effect.life <= 0) {
                    lightningEffects.splice(i, 1);
                }
            }
        }

        function updateOrbitals() {
            let orbitalCount = 3; // Base count from orbital_shield
            if (unlockedSkills.includes('regen_capacitors')) orbitalCount += 2; // Orbital Expansion adds 2 (total 5)
            const orbitalRadius = ORBITAL_RADIUS; // Radio centralizado
            let orbitalSpeed = ORBITAL_SPEED; // Velocidad centralizada

            // Handle orbital count changes with equidistant positioning
            if (orbitals.length !== orbitalCount) {
                // Preserve the first orbital's angle to maintain rotation continuity
                const baseAngle = orbitals.length > 0 ? orbitals[0].angle : 0;
                const angleIncrement = Math.PI * 2 / orbitalCount;

                // Recalculate all orbitals with new equidistant positions
                orbitals = [];
                for (let i = 0; i < orbitalCount; i++) {
                    orbitals.push({
                        angle: baseAngle + angleIncrement * i,
                        hitCooldown: 0
                    });
                }
            }

            // Update orbital positions and check collisions
            for (let i = 0; i < orbitals.length; i++) {
                const orb = orbitals[i];
                orb.angle += orbitalSpeed * deltaTime;
                if (!orb.hitEnemies) orb.hitEnemies = {}; // Track cooldown per enemy

                const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;

                // Check collision with nearby enemies (using spatial grid)
                const nearbyEnemies = spatialGrid.queryRadius(orbX, orbY, 50);
                for (const e of nearbyEnemies) {
                    // Per-enemy cooldown check
                    if (orb.hitEnemies[e.id] && orb.hitEnemies[e.id] > 0) {
                        orb.hitEnemies[e.id] -= deltaTime;
                        continue;
                    }

                    const config = ENEMY_TYPES[e.type];
                    const dx = orbX - e.x;
                    const dy = orbY - e.y;
                    const distSq = dx * dx + dy * dy;
                    const collisionDist = config.radius + ORBITAL_SIZE;

                    if (distSq < collisionDist * collisionDist) {
                        let orbitalDamage = 16; // Base damage
                        if (unlockedSkills.includes('energy_absorption')) orbitalDamage += 16; // Energy Absorption boost
                        e.hp -= orbitalDamage;
                        orb.hitEnemies[e.id] = 0.15; // Cooldown per enemy (can hit same enemy again after 0.15s)

                        // Show damage floating text
                        spawnFloatingText(e.x, e.y - config.radius, orbitalDamage.toString(), SKILL_TREE['orbital_shield'].color);
                        spawnRing(e.x, e.y, config.color);

                        if (e.hp <= 0) {
                            const enemyIndex = enemies.indexOf(e);
                            if (enemyIndex !== -1) killEnemy(e, enemyIndex);
                        }
                        // No break - can hit multiple enemies per frame
                    }
                }

                // Orbital vs Boss
                if (currentBoss) {
                    if (!orb.hitEnemies['boss']) orb.hitEnemies['boss'] = 0;
                    if (orb.hitEnemies['boss'] > 0) {
                        orb.hitEnemies['boss'] -= deltaTime;
                    } else {
                        const dx = orbX - currentBoss.x;
                        const dy = orbY - currentBoss.y;
                        const distSq = dx * dx + dy * dy;
                        const collisionDist = currentBoss.size * 0.85 + ORBITAL_SIZE;
                        if (distSq < collisionDist * collisionDist) {
                            let orbitalDamage = 16;
                            if (unlockedSkills.includes('energy_absorption')) orbitalDamage += 16;
                            damageBoss(orbitalDamage);
                            orb.hitEnemies['boss'] = 0.15;
                            spawnRing(orbX, orbY, currentBoss.color);
                        }
                    }
                }
            }
        }

        function updateAura() {
            const stats = getWeaponStats();
            if (!stats.hasAura || !player) return;

            // Update pulse animation
            auraState.pulseAnimation += deltaTime * 3;

            // Update tick timer
            auraState.tickTimer += deltaTime;

            // Only deal damage on tick intervals
            if (auraState.tickTimer < stats.auraTickRate) return;
            auraState.tickTimer = 0;

            // Find all enemies within aura radius
            const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, stats.auraRadius);

            for (const e of nearbyEnemies) {
                const config = ENEMY_TYPES[e.type];
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const distSq = dx * dx + dy * dy;
                const effectiveRadius = stats.auraRadius + config.radius;

                if (distSq < effectiveRadius * effectiveRadius) {
                    // Apply damage
                    e.hp -= stats.auraDamage;

                    // Visual feedback
                    spawnFloatingText(e.x, e.y - config.radius, stats.auraDamage.toString(), SKILL_TREE['plasma_field'].color);
                    spawnRing(e.x, e.y, SKILL_TREE['plasma_field'].color);

                    // Check for death
                    if (e.hp <= 0) {
                        const enemyIndex = enemies.indexOf(e);
                        if (enemyIndex !== -1) killEnemy(e, enemyIndex);
                    }
                }
            }

            // Aura also damages boss
            if (currentBoss) {
                const dx = currentBoss.x - player.x;
                const dy = currentBoss.y - player.y;
                const distSq = dx * dx + dy * dy;
                const effectiveRadius = stats.auraRadius + currentBoss.size * 0.85;
                if (distSq < effectiveRadius * effectiveRadius) {
                    damageBoss(stats.auraDamage);
                    spawnRing(currentBoss.x, currentBoss.y, SKILL_TREE['plasma_field'].color);
                }
            }
        }

        // ============================================================
        // ROCKET EXPLOSION (unified for all rocket death scenarios)
        // ============================================================

        function explodePlayerRocket(b) {
            if (b.type !== 'rocket' && b.type !== 'mini_rocket') return;
            const explosionX = b.x;
            const explosionY = b.y;
            const explosionRadius = b.explosionRadius || 0;
            const explosionDamage = b.explosionDamage || 0;

            // Visual explosion effect
            spawnRing(explosionX, explosionY, COLORS.PLAYER, Math.max(explosionRadius * 2.5, 40));

            if (explosionRadius > 0 && explosionDamage > 0) {
                // Damage enemies in blast radius
                const enemiesInBlast = spatialGrid.queryRadius(explosionX, explosionY, explosionRadius);
                for (const blastEnemy of enemiesInBlast) {
                    const dx = blastEnemy.x - explosionX;
                    const dy = blastEnemy.y - explosionY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= explosionRadius) {
                        const falloff = 1 - (dist / explosionRadius) * 0.5;
                        const dmg = Math.ceil(explosionDamage * falloff);
                        blastEnemy.hp -= dmg;
                        const config = ENEMY_TYPES[blastEnemy.type];
                        spawnFloatingText(blastEnemy.x, blastEnemy.y - config.radius, dmg.toString(), COLORS.PLAYER);
                        spawnRing(blastEnemy.x, blastEnemy.y, COLORS.PLAYER);
                        if (blastEnemy.hp <= 0) {
                            const idx = enemies.indexOf(blastEnemy);
                            if (idx !== -1) killEnemy(blastEnemy, idx);
                        }
                    }
                }

                // Damage boss in blast radius
                if (currentBoss) {
                    const dx = currentBoss.x - explosionX;
                    const dy = currentBoss.y - explosionY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= explosionRadius + currentBoss.size) {
                        const falloff = 1 - (dist / (explosionRadius + currentBoss.size)) * 0.5;
                        const dmg = Math.ceil(explosionDamage * falloff);
                        damageBoss(dmg);
                    }
                }

                // Damage boss projectiles in blast radius (only reduce hp, cleanup happens in collision loops)
                for (const bp of bossProjectiles) {
                    const dx = bp.x - explosionX;
                    const dy = bp.y - explosionY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= explosionRadius) {
                        bp.hp -= explosionDamage;
                        if (bp.hp <= 0) {
                            spawnRing(bp.x, bp.y, bp.color, 15);
                        }
                    }
                }

                // Damage homing missiles in blast radius (only reduce hp, cleanup happens in collision loops)
                for (const m of bossHomingMissiles) {
                    if (m.hp <= 0) continue;
                    const dx = m.x - explosionX;
                    const dy = m.y - explosionY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= explosionRadius) {
                        m.hp -= explosionDamage;
                    }
                }

                // Damage trail nodes in blast radius
                for (let ni = bossTrailNodes.length - 1; ni >= 0; ni--) {
                    const node = bossTrailNodes[ni];
                    if (!node.active || node.hp <= 0) continue;
                    const dx = node.x - explosionX;
                    const dy = node.y - explosionY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= explosionRadius) {
                        node.hp -= explosionDamage;
                        if (node.hp <= 0) destroyTrailNode(ni);
                    }
                }
            }

            // Ricochet: spawn mini rockets
            if (b.hasRicochet && b.type === 'rocket') {
                const ricochetTargets = spatialGrid.queryRadius(explosionX, explosionY, 400);
                let targetsFound = 0;
                for (const target of ricochetTargets) {
                    if (targetsFound >= 2) break;
                    if (target.hp <= 0) continue;

                    const angle = Math.atan2(target.y - explosionY, target.x - explosionX);
                    const spread = (Math.random() - 0.5) * 0.3;

                    const miniRocket = pools.bullet.acquire();
                    miniRocket.x = explosionX;
                    miniRocket.y = explosionY;
                    miniRocket.vx = Math.cos(angle + spread) * 550;
                    miniRocket.vy = Math.sin(angle + spread) * 550;
                    miniRocket.life = 1.5;
                    miniRocket.damage = Math.ceil(b.damage * 0.5);
                    miniRocket.explosionDamage = 0;
                    miniRocket.explosionRadius = 0;
                    miniRocket.hasRicochet = false;
                    miniRocket.type = 'mini_rocket';
                    miniRocket.color = COLORS.PLAYER;
                    miniRocket.piercing = false;
                    miniRocket.turnRate = 250;
                    miniRocket.size = 0.6;
                    miniRocket.trail = [];
                    bullets.push(miniRocket);
                    targetsFound++;
                }
            }
        }

        // ============================================================
        // COLLISIONS
        // ============================================================

        // Swept collision: checks if line segment intersects circle
        // Returns true if the line from (x1,y1) to (x2,y2) passes through circle at (cx,cy) with radius r
        function lineCircleCollision(x1, y1, x2, y2, cx, cy, r) {
            // Vector from start to end of line
            const dx = x2 - x1;
            const dy = y2 - y1;

            // Vector from start to circle center
            const fx = x1 - cx;
            const fy = y1 - cy;

            // Quadratic equation coefficients: at^2 + bt + c = 0
            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;

            // If bullet didn't move (a ≈ 0), just check current position
            if (a < 0.0001) {
                return c <= 0;
            }

            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) {
                return false; // No intersection
            }

            const sqrtDisc = Math.sqrt(discriminant);
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);

            // Check if intersection happens within the line segment (t between 0 and 1)
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }

        function checkCollisions() {
            if (!player) return;
            
            // Bullet vs Enemy (using spatial grid for optimization)
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                let bulletDestroyed = false;

                // Use previous position for swept collision (fallback to current if first frame)
                const prevX = b.prevX !== undefined ? b.prevX : b.x;
                const prevY = b.prevY !== undefined ? b.prevY : b.y;

                // Query enemies along the bullet's path (expand search radius to cover movement)
                const moveDistSq = (b.x - prevX) * (b.x - prevX) + (b.y - prevY) * (b.y - prevY);
                const moveDist = Math.sqrt(moveDistSq);
                const searchRadius = 100 + moveDist;
                const midX = (b.x + prevX) / 2;
                const midY = (b.y + prevY) / 2;
                const nearbyEnemies = spatialGrid.queryRadius(midX, midY, searchRadius);

                for (const e of nearbyEnemies) {
                    const config = ENEMY_TYPES[e.type];
                    const hitRadius = config.radius * 0.9; // Shrink hitbox 10%
                    const collisionDist = hitRadius + 4;

                    // Use swept collision detection (line-circle intersection)
                    if (lineCircleCollision(prevX, prevY, b.x, b.y, e.x, e.y, collisionDist)) {
                        // Check if piercing bullet already hit this enemy
                        if (b.piercing && b.hitEnemies && b.hitEnemies.has(e)) {
                            continue;
                        }

                        const damage = b.damage || 1;
                        e.hp -= damage;

                        // Show damage floating text
                        spawnFloatingText(e.x, e.y - config.radius, damage.toString(), b.color || COLORS.BULLET);

                        // Hit effect
                        spawnRing(b.x, b.y, config.color);

                        if (e.hp <= 0) {
                            const enemyIndex = enemies.indexOf(e);
                            if (enemyIndex !== -1) {
                                killEnemy(e, enemyIndex);
                            }
                        }

                        // Handle bullet destruction/piercing
                        if (b.piercing) {
                            if (!b.hitEnemies) b.hitEnemies = new Set();
                            b.hitEnemies.add(e);
                        } else {
                            bulletDestroyed = true;
                            break;
                        }
                    }
                }

                if (bulletDestroyed) {
                    explodePlayerRocket(b);
                    pools.bullet.release(b);
                    fastRemove(bullets, i);
                }
            }

            // Bullet vs Boss
            if (currentBoss) {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    const dx = currentBoss.x - b.x;
                    const dy = currentBoss.y - b.y;
                    const distSq = dx * dx + dy * dy;
                    const hitDist = currentBoss.size * 0.85;
                    if (distSq < hitDist * hitDist) {
                        // Skip if piercing bullet already hit this boss
                        if (b.piercing && b.hitEnemies && b.hitEnemies.has(currentBoss)) {
                            continue;
                        }

                        const damage = b.damage || 1;
                        damageBoss(damage);
                        spawnRing(b.x, b.y, currentBoss.color);

                        if (b.piercing) {
                            if (!b.hitEnemies) b.hitEnemies = new Set();
                            b.hitEnemies.add(currentBoss);
                        } else {
                            explodePlayerRocket(b);
                            pools.bullet.release(b);
                            fastRemove(bullets, i);
                        }
                    }
                }
            }

            // Enemy vs Player (using spatial grid for nearby enemies only)
            const nearbyEnemiesForPlayer = spatialGrid.queryRadius(player.x, player.y, 100);
            for (const e of nearbyEnemiesForPlayer) {
                const config = ENEMY_TYPES[e.type];

                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const distSq = dx * dx + dy * dy;
                const collisionDist = PLAYER_COLLISION_RADIUS + config.radius * 0.9;
                const collisionDistSq = collisionDist * collisionDist;
                const nearMissDistSq = (collisionDist + NEAR_MISS_RADIUS) * (collisionDist + NEAR_MISS_RADIUS);

                // Near-miss check
                if (distSq < nearMissDistSq && distSq > collisionDistSq) {
                    if (!e.nearMissTriggered) {
                        e.nearMissTriggered = true;
                        triggerNearMiss();
                    }
                }

                // Collision
                if (distSq < collisionDistSq && player.invulnerable <= 0) {
                    damagePlayer();

                    // Kamikaze dies on contact
                    if (e.type === 'KAMIKAZE') {
                        spawnRing(e.x, e.y, config.color, 50);
                        const idx = enemies.indexOf(e);
                        if (idx !== -1) {
                            pools.enemy.release(e);
                            fastRemove(enemies, idx);
                        }
                    }
                }
            }
            
            // Enemy bullet vs Player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];

                const dx = player.x - b.x;
                const dy = player.y - b.y;
                const distSq = dx * dx + dy * dy;
                const collisionDistSq = PLAYER_COLLISION_RADIUS * PLAYER_COLLISION_RADIUS;
                const nearMissDistSq = (PLAYER_COLLISION_RADIUS + NEAR_MISS_RADIUS) * (PLAYER_COLLISION_RADIUS + NEAR_MISS_RADIUS);

                // Near-miss
                if (distSq < nearMissDistSq && distSq > collisionDistSq) {
                    if (!b.nearMissTriggered) {
                        b.nearMissTriggered = true;
                        triggerNearMiss();
                    }
                }

                if (distSq < collisionDistSq && player.invulnerable <= 0) {
                    damagePlayer();
                    pools.enemyBullet.release(b);
                    fastRemove(enemyBullets, i);
                }
            }

            // Boss projectiles vs Player
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const bp = bossProjectiles[i];
                const dx = player.x - bp.x;
                const dy = player.y - bp.y;
                const distSq = dx * dx + dy * dy;
                const collisionDist = PLAYER_COLLISION_RADIUS + bp.radius;

                if (distSq < collisionDist * collisionDist && player.invulnerable <= 0) {
                    damagePlayer();
                    spawnRing(bp.x, bp.y, bp.color, 30);
                    triggerShake(4, 150);
                    bossProjectiles.splice(i, 1);
                }
            }

            // Homing missiles vs Player
            for (let i = bossHomingMissiles.length - 1; i >= 0; i--) {
                const m = bossHomingMissiles[i];
                const dx = player.x - m.x;
                const dy = player.y - m.y;
                const distSq = dx * dx + dy * dy;
                const collisionDist = PLAYER_COLLISION_RADIUS + m.radius;

                if (distSq < collisionDist * collisionDist && player.invulnerable <= 0) {
                    for (let d = 0; d < m.damage; d++) {
                        damagePlayer();
                    }
                    triggerFlash('#FF4400', 0.4, 200);
                    explodeHomingMissile(m);
                    bossHomingMissiles.splice(i, 1);
                }
            }

            // Player bullets vs Homing missiles (destructible)
            if (currentBoss && currentBoss.type === 'missileTitan') {
                for (let i = bossHomingMissiles.length - 1; i >= 0; i--) {
                    const m = bossHomingMissiles[i];
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const b = bullets[j];
                        const dx = m.x - b.x;
                        const dy = m.y - b.y;
                        const distSq = dx * dx + dy * dy;
                        const hitDist = m.radius + 6;
                        if (distSq < hitDist * hitDist) {
                            m.hp -= (b.damage || 1);
                            if (!b.piercing) {
                                explodePlayerRocket(b);
                                pools.bullet.release(b);
                                fastRemove(bullets, j);
                            }
                            if (m.hp <= 0) break;
                        }
                    }
                }

                // Orbitals vs Homing missiles
                if (orbitals.length > 0) {
                    const orbitalRadius = ORBITAL_RADIUS;
                    for (let i = bossHomingMissiles.length - 1; i >= 0; i--) {
                        const m = bossHomingMissiles[i];
                        for (let k = 0; k < orbitals.length; k++) {
                            const orb = orbitals[k];
                            const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                            const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;
                            const dx = m.x - orbX;
                            const dy = m.y - orbY;
                            const distSq = dx * dx + dy * dy;
                            const hitDist = m.radius + ORBITAL_SIZE;
                            if (distSq < hitDist * hitDist) {
                                m.hp -= 20; // Orbitals deal significant damage to missiles
                                spawnRing(m.x, m.y, '#FFD93D', 20);
                                break;
                            }
                        }
                    }
                }
            }

            // Player bullets vs Trail nodes (destructible)
            if (currentBoss && currentBoss.type === 'lightningNexus' && bossTrailNodes.length > 0) {
                for (let i = bossTrailNodes.length - 1; i >= 0; i--) {
                    const node = bossTrailNodes[i];
                    if (!node.active) continue;
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const b = bullets[j];
                        const dx = node.x - b.x;
                        const dy = node.y - b.y;
                        const distSq = dx * dx + dy * dy;
                        const hitDist = node.radius + 6;
                        if (distSq < hitDist * hitDist) {
                            node.hp -= (b.damage || 1);
                            if (!b.piercing) {
                                explodePlayerRocket(b);
                                pools.bullet.release(b);
                                fastRemove(bullets, j);
                            }
                            if (node.hp <= 0) {
                                destroyTrailNode(i);
                                break;
                            }
                        }
                    }
                }

                // Orbitals vs Trail nodes
                if (orbitals.length > 0) {
                    const orbitalRadius = ORBITAL_RADIUS;
                    for (let i = bossTrailNodes.length - 1; i >= 0; i--) {
                        const node = bossTrailNodes[i];
                        if (!node.active) continue;
                        for (let k = 0; k < orbitals.length; k++) {
                            const orb = orbitals[k];
                            const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                            const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;
                            const dx = node.x - orbX;
                            const dy = node.y - orbY;
                            const distSq = dx * dx + dy * dy;
                            const hitDist = node.radius + ORBITAL_SIZE;
                            if (distSq < hitDist * hitDist) {
                                node.hp -= 20;
                                spawnRing(node.x, node.y, '#00FFFF', 20);
                                if (node.hp <= 0) {
                                    destroyTrailNode(i);
                                }
                                break;
                            }
                        }
                    }
                }
            }

            // Boss spheres vs Player (gentle contact damage)
            if (currentBoss && currentBoss.type === 'orbitalGuardian' && bossSpheres.length > 0) {
                if (!player._sphereDmgCooldown) player._sphereDmgCooldown = 0;
                player._sphereDmgCooldown = Math.max(0, player._sphereDmgCooldown - deltaTime);
                if (player._sphereDmgCooldown <= 0 && player.invulnerable <= 0) {
                    for (let i = 0; i < bossSpheres.length; i++) {
                        const s = bossSpheres[i];
                        const dx = player.x - s.x;
                        const dy = player.y - s.y;
                        const distSq = dx * dx + dy * dy;
                        const collisionDist = PLAYER_COLLISION_RADIUS + s.radius;
                        if (distSq < collisionDist * collisionDist) {
                            // Contact tick damage: 10 shield per 0.15s
                            player._sphereDmgCooldown = 0.15;
                            player.shieldRegenTimer = 0;
                            player.shield = Math.max(0, player.shield - 10);
                            player.shieldFlashTimer = 0.15;
                            triggerShake(3, 120);
                            triggerFlash('#00DFFF', 0.15, 80);
                            spawnRing(s.x, s.y, s.color, 20);
                            if (player.shield <= 0) {
                                player.hp--;
                                player.shield = PLAYER_MAX_SHIELD;
                                triggerFlash('#FF6B6B', 0.3, 150);
                                if (player.hp <= 0) {
                                    player.shield = 0;
                                    gameOver();
                                }
                            }
                            break;
                        }
                    }
                }
            }

            // Boss body vs Player (contact damage for standing on boss)
            if (currentBoss && player.invulnerable <= 0) {
                if (!player._bossDmgCooldown) player._bossDmgCooldown = 0;
                player._bossDmgCooldown = Math.max(0, player._bossDmgCooldown - deltaTime);
                if (player._bossDmgCooldown <= 0) {
                    const dx = player.x - currentBoss.x;
                    const dy = player.y - currentBoss.y;
                    const distSq = dx * dx + dy * dy;
                    const collisionDist = PLAYER_COLLISION_RADIUS + currentBoss.size * 0.8;
                    if (distSq < collisionDist * collisionDist) {
                        player._bossDmgCooldown = 0.12;
                        damagePlayer();
                        triggerShake(5, 150);
                        spawnRing(player.x, player.y, currentBoss.color, 30);
                    }
                }
            }

            // Lightning Nexus: lightning strikes vs Player
            checkLightningStrikeCollisions();
            checkTrailCollisions();

            // Player bullets vs Boss projectiles (destructible)
            if (currentBoss) {
                for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                    const bp = bossProjectiles[i];
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const b = bullets[j];
                        const dx = bp.x - b.x;
                        const dy = bp.y - b.y;
                        const distSq = dx * dx + dy * dy;
                        const hitDist = bp.radius + 6;
                        if (distSq < hitDist * hitDist) {
                            bp.hp -= (b.damage || 1);
                            if (!b.piercing) {
                                explodePlayerRocket(b);
                                pools.bullet.release(b);
                                fastRemove(bullets, j);
                            }
                            if (bp.hp <= 0) {
                                // Destroy boss projectile with particles
                                for (let p = 0; p < 4; p++) {
                                    spawnRing(bp.x, bp.y, bp.color, 15);
                                }
                                bossProjectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }

                // Orbitals vs Boss projectiles
                if (orbitals.length > 0) {
                    const orbitalRadius = ORBITAL_RADIUS;
                    for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                        const bp = bossProjectiles[i];
                        for (let k = 0; k < orbitals.length; k++) {
                            const orb = orbitals[k];
                            const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                            const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;
                            const dx = bp.x - orbX;
                            const dy = bp.y - orbY;
                            const distSq = dx * dx + dy * dy;
                            const hitDist = bp.radius + ORBITAL_SIZE;
                            if (distSq < hitDist * hitDist) {
                                spawnRing(bp.x, bp.y, bp.color, 20);
                                bossProjectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }

                // Plasma aura vs Boss projectiles
                const stats = getWeaponStats();
                if (stats.hasAura) {
                    for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                        const bp = bossProjectiles[i];
                        const dx = bp.x - player.x;
                        const dy = bp.y - player.y;
                        const distSq = dx * dx + dy * dy;
                        const auraRange = stats.auraRadius + bp.radius;
                        if (distSq < auraRange * auraRange) {
                            spawnRing(bp.x, bp.y, SKILL_TREE['plasma_field'].color, 15);
                            bossProjectiles.splice(i, 1);
                        }
                    }

                    // Plasma aura vs Homing missiles (deals damage, doesn't instant-kill)
                    for (let i = bossHomingMissiles.length - 1; i >= 0; i--) {
                        const m = bossHomingMissiles[i];
                        const dx = m.x - player.x;
                        const dy = m.y - player.y;
                        const distSq = dx * dx + dy * dy;
                        const auraRange = stats.auraRadius + m.radius;
                        if (distSq < auraRange * auraRange) {
                            m.hp -= stats.auraDamage || 5;
                            spawnRing(m.x, m.y, SKILL_TREE['plasma_field'].color, 20);
                        }
                    }

                    // Plasma aura vs Trail nodes
                    for (let i = bossTrailNodes.length - 1; i >= 0; i--) {
                        const node = bossTrailNodes[i];
                        if (!node.active || node.hp <= 0) continue;
                        const dx = node.x - player.x;
                        const dy = node.y - player.y;
                        const distSq = dx * dx + dy * dy;
                        const auraRange = stats.auraRadius + node.radius;
                        if (distSq < auraRange * auraRange) {
                            node.hp -= stats.auraDamage || 5;
                            spawnRing(node.x, node.y, SKILL_TREE['plasma_field'].color, 20);
                            if (node.hp <= 0) destroyTrailNode(i);
                        }
                    }
                }
            }
        }

        function damagePlayer() {
            // Reset shield regen timer
            player.shieldRegenTimer = 0;

            // Small hit cooldown (no visual effect, just prevents frame-stacking)
            player.invulnerable = 0.05;

            // Shield absorbs damage
            player.shield = Math.max(0, player.shield - SHIELD_DAMAGE_ABSORPTION);
            player.shieldFlashTimer = 0.15;

            // Visual effects for shield hit
            triggerShake(SHAKE_INTENSITY_HIT * 0.5, SHAKE_DURATION_HIT * 0.6);
            triggerFlash(COLORS.SHIELD, 0.2, 100);

            // Shield depleted - consume hull and restore shield
            if (player.shield <= 0) {
                player.hp--;
                player.shield = PLAYER_MAX_SHIELD;

                triggerShake(SHAKE_INTENSITY_HIT, SHAKE_DURATION_HIT);
                triggerFlash('#FF6B6B', 0.4, 200);

                if (player.hp <= 0) {
                    player.shield = 0; // Stay at 0 for death
                    gameOver();
                }
            }
        }
        
        function triggerNearMiss() {
            score += NEAR_MISS_POINTS;

            spawnFloatingText(player.x + (Math.random() - 0.5) * 30, player.y - 30, '+' + NEAR_MISS_POINTS, COLORS.PLAYER);
            triggerSlowmo(SLOWMO_DURATION);
            triggerFlash(COLORS.PLAYER, 0.22, 180);
            
            // Burst particles
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                particles.push({
                    x: player.x + Math.cos(angle) * PLAYER_COLLISION_RADIUS,
                    y: player.y + Math.sin(angle) * PLAYER_COLLISION_RADIUS,
                    vx: Math.cos(angle) * 100,
                    vy: Math.sin(angle) * 100,
                    life: 0.3,
                    maxLife: 0.3,
                    size: 3,
                    color: COLORS.PLAYER,
                    type: 'nearmiss'
                });
            }
        }
        
        function gameOver() {
            // Save high score
            try {
                const savedHighScore = parseInt(localStorage.getItem('StellarSwarm_highscore_v1') || '0');
                if (score > savedHighScore) {
                    localStorage.setItem('StellarSwarm_highscore_v1', Math.floor(score).toString());
                }
            } catch (e) {
                console.warn('Could not save high score to localStorage:', e);
            }

            // Death explosion
            spawnDeathExplosion();
            
            triggerShake(10, SHAKE_DURATION_DEATH);
            triggerFlash('#FFFFFF', 0.6, 120);
            triggerSlowmo(240);
            
            setTimeout(() => {
                gameState = 'gameOver';
            }, 800);
        }
        
        function spawnDeathExplosion() {
            // Shards
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i + Math.random() * 0.5;
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (100 + Math.random() * 80) + player.vx * 0.3,
                    vy: Math.sin(angle) * (100 + Math.random() * 80) + player.vy * 0.3,
                    life: 0.9,
                    maxLife: 0.9,
                    size: 12,
                    color: COLORS.PLAYER,
                    type: 'shard',
                    angle: angle * 180 / Math.PI,
                    rotSpeed: (Math.random() - 0.5) * 400
                });
            }
            
            // Small particles
            for (let i = 0; i < 18; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (50 + Math.random() * 150),
                    vy: Math.sin(angle) * (50 + Math.random() * 150),
                    life: 0.6 + Math.random() * 0.3,
                    maxLife: 0.8,
                    size: 3 + Math.random() * 4,
                    color: Math.random() > 0.5 ? COLORS.PLAYER : COLORS.THRUSTER,
                    type: 'debris'
                });
            }
        }

        // ============================================================
        // PARTICLES & EFFECTS
        // ============================================================
        
        // Single ring effect - replaces all particle explosions for performance
        function spawnRing(x, y, color, maxSize = 15) {
            const ring = pools.particle.acquire();
            ring.x = x;
            ring.y = y;
            ring.vx = 0;
            ring.vy = 0;
            ring.type = 'ring';
            ring.color = color;
            ring.size = maxSize * 0.25;
            ring.maxSize = maxSize;
            ring.life = 0.2;
            ring.maxLife = 0.2;
            particles.push(ring);
        }

        function spawnFloatingText(x, y, text, color) {
            const ft = pools.floatingText.acquire();
            ft.x = x;
            ft.y = y;
            ft.text = text;
            ft.color = color;
            ft.life = 0.7;
            ft.maxLife = 0.7;
            floatingTexts.push(ft);
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.life -= deltaTime;
                
                if (p.type === 'shard' && p.rotSpeed) {
                    p.angle += p.rotSpeed * deltaTime;
                }
                if (p.type === 'thruster' && p.rotationSpeed) {
                    p.rotation += p.rotationSpeed * deltaTime;
                }
                
                // Drag on particles (thruster uses exponential slowdown based on life)
                if (p.type === 'thruster') {
                    const lifeRatio = p.life / p.maxLife;
                    const drag = Math.pow(0.92, 1 + (1 - lifeRatio) * 4);
                    p.vx *= drag;
                    p.vy *= drag;
                } else {
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                }
                
                if (p.life <= 0) {
                    pools.particle.release(p);
                    fastRemove(particles, i);
                }
            }
        }
        
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const t = floatingTexts[i];
                t.y -= 40 * deltaTime;
                t.life -= deltaTime;
                
                if (t.life <= 0) {
                    pools.floatingText.release(t);
                    fastRemove(floatingTexts, i);
                }
            }
        }

        function updateEffects() {
            // Shake
            if (shakeDuration > 0) {
                shakeTimer += deltaTime * 1000;
                if (shakeTimer >= shakeDuration) {
                    shakeDuration = 0;
                    shakeIntensity = 0;
                }
            }
            
            // Flash
            if (flashDuration > 0) {
                flashDuration -= deltaTime * 1000;
                if (flashDuration <= 0) {
                    flashColor = null;
                    flashOpacity = 0;
                }
            }
            
            // Milestone
            if (milestoneActive) {
                milestoneTimer -= deltaTime * 1000;
                if (milestoneTimer <= 0) {
                    milestoneActive = false;
                }
            }
        }
        
        function triggerShake(intensity, duration) {
            shakeIntensity = intensity;
            shakeDuration = duration;
            shakeTimer = 0;
        }
        
        function triggerFlash(color, opacity, duration) {
            flashColor = color;
            flashOpacity = opacity;
            flashDuration = duration;
        }
        
        function triggerSlowmo(duration) {
            slowmoTimer = duration;
            slowmoDuration = duration;
        }
        
        function checkMilestones() {
            const milestone = Math.floor(score / MILESTONE_INTERVAL) * MILESTONE_INTERVAL;
            if (milestone > lastMilestone && milestone > 0) {
                lastMilestone = milestone;
                milestoneActive = true;
                milestoneTimer = 1200;

                // Gold particles
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: Math.random() * CANVAS_WIDTH,
                        y: -20,
                        vx: (Math.random() - 0.5) * 100,
                        vy: 100 + Math.random() * 100,
                        life: 1.5,
                        maxLife: 1.5,
                        size: 4 + Math.random() * 4,
                        color: COLORS.GOLD,
                        type: 'confetti'
                    });
                }
            }
        }

        // ============================================================
        // ARENA RENDERING
        // ============================================================

        function renderArena() {
            if (!arenaActive) return;

            const r = arenaCurrentRadius;
            const pulse = 0.6 + 0.4 * Math.sin(gameTime * 3);
            const cx = arenaCenter.x;
            const cy = arenaCenter.y;

            ctx.save();

            // Dark overlay OUTSIDE the arena ring
            ctx.save();
            ctx.beginPath();
            ctx.rect(cx - 6000, cy - 6000, 12000, 12000);
            ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fill();
            ctx.restore();

            // Radial energy lines every 15 degrees
            ctx.save();
            ctx.globalAlpha = pulse * 0.4;
            ctx.strokeStyle = '#0088CC';
            ctx.lineWidth = 1;
            for (let angle = 0; angle < 360; angle += 15) {
                const rad = angle * Math.PI / 180 + gameTime * 0.2;
                const innerR = r - 25;
                const outerR = r + 5;
                ctx.beginPath();
                ctx.moveTo(cx + Math.cos(rad) * innerR, cy + Math.sin(rad) * innerR);
                ctx.lineTo(cx + Math.cos(rad) * outerR, cy + Math.sin(rad) * outerR);
                ctx.stroke();
            }
            ctx.restore();

            // Main arena ring with glow
            ctx.save();
            ctx.globalAlpha = pulse;

            ctx.shadowColor = '#00CCFF';
            ctx.shadowBlur = 20;

            const gradient = ctx.createLinearGradient(
                cx - r, cy,
                cx + r, cy
            );
            gradient.addColorStop(0, '#00CCFF');
            gradient.addColorStop(0.5, '#0066FF');
            gradient.addColorStop(1, '#00CCFF');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.stroke();

            // Inner subtle ring
            ctx.shadowBlur = 0;
            ctx.globalAlpha = pulse * 0.3;
            ctx.strokeStyle = '#00CCFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, r - 15, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();

            // Boss incoming warning marker at arena center
            if (bossIncoming) {
                const bi = bossIncoming;
                const bossColor = BOSS_COLORS[bi.bossIndex];
                const t = gameTime;
                const warnPulse = 0.4 + 0.6 * Math.abs(Math.sin(t * 5));

                ctx.save();
                ctx.translate(cx, cy);

                // Pulsating concentric rings converging inward
                for (let ring = 0; ring < 3; ring++) {
                    const ringPhase = (t * 2 + ring * 0.7) % 2;
                    const ringRadius = 120 * (1 - ringPhase / 2);
                    const ringAlpha = (1 - ringPhase / 2) * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = bossColor;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = ringAlpha;
                    ctx.stroke();
                }

                // Crosshair lines
                ctx.globalAlpha = warnPulse * 0.6;
                ctx.strokeStyle = bossColor;
                ctx.lineWidth = 1.5;
                const crossLen = 40;
                ctx.beginPath();
                ctx.moveTo(-crossLen, 0); ctx.lineTo(crossLen, 0);
                ctx.moveTo(0, -crossLen); ctx.lineTo(0, crossLen);
                ctx.stroke();

                // Rotating corner brackets
                ctx.rotate(t * 1.5);
                ctx.globalAlpha = warnPulse * 0.7;
                ctx.lineWidth = 2.5;
                const bSize = 30;
                const bLen = 12;
                for (let corner = 0; corner < 4; corner++) {
                    ctx.save();
                    ctx.rotate(corner * Math.PI / 2);
                    ctx.beginPath();
                    ctx.moveTo(bSize, bSize - bLen);
                    ctx.lineTo(bSize, bSize);
                    ctx.lineTo(bSize - bLen, bSize);
                    ctx.stroke();
                    ctx.restore();
                }

                // Boss name text
                ctx.rotate(-t * 1.5); // undo rotation for text
                ctx.globalAlpha = warnPulse;
                ctx.textAlign = 'center';
                ctx.font = 'bold 16px "Segoe UI", sans-serif';
                ctx.fillStyle = bossColor;
                ctx.fillText(BOSS_NAMES[bi.bossIndex], 0, -70);

                // "WARNING" blinking text
                if (Math.sin(t * 8) > 0) {
                    ctx.font = 'bold 12px "Segoe UI", sans-serif';
                    ctx.fillStyle = '#FF4444';
                    ctx.fillText('WARNING', 0, 70);
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            }

            ctx.restore();
        }

        // ============================================================
        // RENDERING
        // ============================================================

        function render() {
            // Apply shake
            ctx.save();
            if (shakeDuration > 0) {
                const progress = shakeTimer / shakeDuration;
                const currentIntensity = shakeIntensity * (1 - progress);
                ctx.translate(
                    (Math.random() - 0.5) * currentIntensity * 2,
                    (Math.random() - 0.5) * currentIntensity * 2
                );
            }

            // Background (rendered without camera offset)
            renderBackground();

            // *** APPLY CAMERA TRANSFORM FOR ALL GAME ENTITIES ***
            ctx.save();
            const cameraOffset = worldToScreen(0, 0);
            ctx.translate(cameraOffset.x, cameraOffset.y);

            // Game entities (all rendered in world coordinates)
            if (gameState === 'playing' || gameState === 'paused' || gameState === 'gameOver') {
                // Arena overlay (rendered first so entities appear on top)
                if (arenaActive) {
                    renderArena();
                }
                renderPickups();
                renderEnemies();
                renderBullets();
                renderDrones();
                renderEnemyBullets();
                renderBoss();
                renderBossSpheres();
                renderBossProjectiles();
                renderHomingMissiles();
                renderLightningStrikes();
                renderTrailNodes();
                if (player && gameState !== 'gameOver') {
                    renderAura();
                    renderPlayer();
                    renderMissileWarning();
                    renderShieldArc();
                    renderOrbitals();
                    renderLightning();
                }
                renderParticles();
                renderFloatingTexts();
            }


            ctx.restore(); // Restore camera transform

            ctx.restore(); // Restore shake transform

            // Flash overlay (screen space)
            if (flashColor && flashOpacity > 0) {
                ctx.fillStyle = flashColor;
                ctx.globalAlpha = flashOpacity * (flashDuration / 180);
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.globalAlpha = 1;
            }

            // UI
            renderUI();

            // Debug overlay (toggle with B key)
            if (showDebugOverlay) {
                perfMonitor.renderDebug();
            }
        }

        function renderBackground() {
            // 1. Base gradient (cached in initBackgroundCache)
            ctx.fillStyle = cachedBgGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Skip fancy effects in low performance mode
            if (lowPerfMode) return;

            // 3. Fade-in for grid effects (0 → 1 over 3 seconds)
            const gridFadeIn = Math.min(1, gameTime / 5);
            if (gridFadeIn < 0.01) return;

            // 4. Parallax grid (2 layers)
            // Helper to handle negative modulo correctly
            const mod = (n, m) => ((n % m) + m) % m;

            // Far layer: sparse grid, slow parallax (distant feel)
            const farSpacing = 120;
            const farSpeed = 0.15;
            const farOpacity = 0.025;
            const farLineWidth = 1;
            const farOffsetX = mod(camera.x * farSpeed, farSpacing);
            const farOffsetY = mod(camera.y * farSpeed, farSpacing);
            ctx.strokeStyle = `rgba(127, 219, 255, ${farOpacity * gridFadeIn})`;
            ctx.lineWidth = farLineWidth;
            ctx.beginPath();
            for (let x = -farOffsetX; x <= CANVAS_WIDTH + farSpacing; x += farSpacing) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
            }
            for (let y = -farOffsetY; y <= CANVAS_HEIGHT + farSpacing; y += farSpacing) {
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
            }
            ctx.stroke();

            // Near layer: larger grid, faster parallax (closer feel)
            const nearSpacing = 400;
            const nearSpeed = 0.4;
            const nearOpacity = 0.04;
            const nearLineWidth = 1.5;
            const nearOffsetX = mod(camera.x * nearSpeed, nearSpacing);
            const nearOffsetY = mod(camera.y * nearSpeed, nearSpacing);
            ctx.strokeStyle = `rgba(127, 219, 255, ${nearOpacity * gridFadeIn})`;
            ctx.lineWidth = nearLineWidth;
            ctx.beginPath();
            for (let x = -nearOffsetX; x <= CANVAS_WIDTH + nearSpacing; x += nearSpacing) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
            }
            for (let y = -nearOffsetY; y <= CANVAS_HEIGHT + nearSpacing; y += nearSpacing) {
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
            }
            ctx.stroke();

            // 5. CRT Scanlines (cached pattern)
            ctx.globalAlpha = 0.3 * gridFadeIn;
            ctx.fillStyle = cachedScanlinePattern;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.globalAlpha = 1;

            // 6. Vignette (cached gradient)
            ctx.globalAlpha = gridFadeIn;
            ctx.fillStyle = cachedVignetteGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.globalAlpha = 1;
        }

        // ============================================================
        // SHIELD ARC (around player in world space)
        // ============================================================

        function renderShieldArc() {
            if (!player || player.shield <= 0) return;

            const shieldPercent = player.shield / PLAYER_MAX_SHIELD;
            const isLow = shieldPercent <= SHIELD_ARC_LOW_THRESHOLD && shieldPercent > 0;
            const isRegenerating = player.shieldRegenTimer >= SHIELD_REGEN_DELAY &&
                                   player.shield < PLAYER_MAX_SHIELD;

            const startAngle = -Math.PI / 2; // Start from top
            const endAngle = startAngle + (Math.PI * 2 * shieldPercent);

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.globalAlpha = player.shieldArcOpacity;

            // Determine arc color based on state
            let arcColor = COLORS.HUD_SHIELD;
            let glowIntensity = 0;

            if (player.shieldArcFlashColor) {
                // Flash white on hit
                arcColor = player.shieldArcFlashColor;
                glowIntensity = 20;
            } else if (isLow) {
                // Warning orange with pulse
                const pulse = Math.sin(player.shieldArcPulsePhase * 2) * 0.3 + 0.7;
                ctx.globalAlpha = player.shieldArcOpacity * pulse;
                arcColor = COLORS.HUD_WARNING;
                glowIntensity = 12;
            } else if (isRegenerating) {
                // Regen blue with subtle pulse
                const pulse = Math.sin(player.shieldArcPulsePhase) * 0.2 + 0.8;
                ctx.globalAlpha = player.shieldArcOpacity * pulse;
                arcColor = COLORS.HUD_SHIELD_REGEN;
                glowIntensity = 8;
            }

            // Draw track (faint background circle)
            ctx.strokeStyle = 'rgba(68, 200, 255, 0.06)';
            ctx.lineWidth = SHIELD_ARC_TRACK_STROKE;
            ctx.beginPath();
            ctx.arc(0, 0, SHIELD_ARC_RADIUS, 0, Math.PI * 2);
            ctx.stroke();

            // Draw tick marks around the arc (every 45°)
            ctx.strokeStyle = 'rgba(68, 200, 255, 0.12)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i;
                const innerR = SHIELD_ARC_RADIUS - 6;
                const outerR = SHIELD_ARC_RADIUS - 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR);
                ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                ctx.stroke();
            }

            // Draw fill arc (actual shield)
            if (ENABLE_GLOW_EFFECTS && glowIntensity > 0) {
                ctx.shadowColor = arcColor;
                ctx.shadowBlur = glowIntensity;
            }
            ctx.strokeStyle = arcColor;
            ctx.lineWidth = SHIELD_ARC_STROKE;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 0, SHIELD_ARC_RADIUS, startAngle, endAngle);
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            ctx.restore();
        }


        function renderPlayer() {
            const p = player;
            ctx.save();
            ctx.translate(p.x, p.y + p.bobOffset);
            ctx.rotate(p.angle * Math.PI / 180);
            ctx.translate(-PLAYER_PIVOT_OFFSET, 0);  // Aplica el offset del pivote

            
            // Thruster flame
            if (p.thrusterScale > 0) {
                ctx.fillStyle = COLORS.PLAYER;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                const flameLength = 15 + p.thrusterScale * 20;
                ctx.moveTo(-12, -6);
                ctx.lineTo(-12 - flameLength, 0);
                ctx.lineTo(-12, 6);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Ship body (triangle) - outline only style
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 3;
            ctx.shadowColor = COLORS.PLAYER;
            ctx.shadowBlur = 20;
            
            ctx.beginPath();
            ctx.moveTo(22, 0);
            ctx.lineTo(-12, -16);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-12, 16);
            ctx.closePath();
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function renderMissileWarning() {
            if (!player || bossHomingMissiles.length === 0) return;

            const warningColor = '#FF6600';
            const reticleRadius = 50;
            const pulse = 0.5 + 0.5 * Math.abs(Math.sin(gameTime * 4));

            ctx.save();
            ctx.translate(player.x, player.y);

            // Pulsating dashed reticle circle
            ctx.globalAlpha = pulse * 0.5;
            ctx.strokeStyle = warningColor;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([8, 6]);
            ctx.beginPath();
            ctx.arc(0, 0, reticleRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Rotating corner brackets
            ctx.rotate(gameTime * 2);
            ctx.globalAlpha = pulse * 0.6;
            ctx.lineWidth = 2;
            const bSize = 38;
            const bLen = 10;
            for (let corner = 0; corner < 4; corner++) {
                ctx.save();
                ctx.rotate(corner * Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(bSize, bSize - bLen);
                ctx.lineTo(bSize, bSize);
                ctx.lineTo(bSize - bLen, bSize);
                ctx.stroke();
                ctx.restore();
            }
            ctx.rotate(-gameTime * 2);

            // Directional arrow for each missile
            ctx.globalAlpha = 0.85;
            for (let i = 0; i < bossHomingMissiles.length; i++) {
                const m = bossHomingMissiles[i];
                const angle = Math.atan2(m.y - player.y, m.x - player.x);
                const arrowDist = reticleRadius + 12;

                ctx.save();
                ctx.rotate(angle);
                ctx.translate(arrowDist, 0);

                // Triangle chevron pointing outward
                ctx.fillStyle = warningColor;
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(-5, -6);
                ctx.lineTo(-5, 6);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function renderAura() {
            if (!unlockedSkills.includes('plasma_field') || !player) return;

            const stats = getWeaponStats();
            const auraColor = SKILL_TREE['plasma_field'].color;
            const pulseOffset = Math.sin(auraState.pulseAnimation) * 5;
            const currentRadius = stats.auraRadius + pulseOffset;

            ctx.save();

            // Outer glow ring
            ctx.strokeStyle = auraColor;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            ctx.shadowColor = auraColor;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 15 : 0;
            ctx.beginPath();
            ctx.arc(player.x, player.y, currentRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Semi-transparent fill
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = auraColor;
            ctx.fill();

            // Inner ring
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 1.5;
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(player.x, player.y, currentRadius * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        function renderOrbitals() {
            if (!unlockedSkills.includes('orbital_shield') || !player) return;

            const orbitalRadius = ORBITAL_RADIUS;
            let orbitalSize = ORBITAL_SIZE; // Base size
            if (unlockedSkills.includes('shockwave_emitter')) orbitalSize *= 1.5; // +50% size boost

            // Outline style for orbitals (no glow for performance)
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 2.5;

            for (const orb of orbitals) {
                const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbitalSize, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function renderLightning() {
            if (lightningEffects.length === 0) return;

            for (const effect of lightningEffects) {
                if (effect.points.length < 2) continue;

                const alpha = effect.life / effect.maxLife;

                // Render 3 layers: outer glow, mid glow, core
                for (let layer = 2; layer >= 0; layer--) {
                    ctx.beginPath();
                    ctx.moveTo(effect.points[0].x, effect.points[0].y);

                    // Draw through all pre-computed zigzag points
                    for (let i = 1; i < effect.points.length; i++) {
                        ctx.lineTo(effect.points[i].x, effect.points[i].y);
                    }

                    // Layer styling (narrow lightning)
                    if (layer === 0) {
                        // Core: bright white
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.lineWidth = 1.5;
                    } else if (layer === 1) {
                        // Mid: purple
                        ctx.strokeStyle = `rgba(159, 122, 234, ${alpha * 0.8})`;
                        ctx.lineWidth = 3;
                    } else {
                        // Outer: blue glow
                        ctx.strokeStyle = `rgba(99, 179, 237, ${alpha * 0.5})`;
                        ctx.lineWidth = 6;
                    }

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                }
            }
        }

        function renderBullets() {
            // Sort bullets by type for batched rendering
            const byType = { laser: [], beam: [], rocket: [], spread: [], mini_rocket: [] };

            for (const b of bullets) {
                if (shouldRenderEntity(b, CULLING_DISTANCES.bullets)) {
                    const type = b.type || 'laser';
                    if (byType[type]) byType[type].push(b);
                    else byType.laser.push(b);
                }
            }

            // Batch render lasers
            if (byType.laser.length > 0) {
                ctx.strokeStyle = COLORS.BULLET;
                ctx.shadowColor = COLORS.BULLET;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

                for (const b of byType.laser) {
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.lineWidth = 5;
                    const len = 24;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render beams
            if (byType.beam.length > 0) {
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

                for (const b of byType.beam) {
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.strokeStyle = b.color || COLORS.BULLET;
                    ctx.shadowColor = b.color || COLORS.BULLET;
                    ctx.lineWidth = 5;

                    const len = 24;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render spread shots
            if (byType.spread.length > 0) {
                ctx.strokeStyle = COLORS.GOLD;
                ctx.shadowColor = COLORS.GOLD;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;
                ctx.lineWidth = 2;

                for (const b of byType.spread) {
                    const angle = Math.atan2(b.vy, b.vx);
                    const len = 10;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render rockets with trail
            if (byType.rocket.length > 0) {
                ctx.shadowColor = COLORS.PLAYER;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 10 : 0;

                for (const b of byType.rocket) {
                    // Draw trail as fading line
                    if (b.trail && b.trail.length > 1) {
                        for (let t = 0; t < b.trail.length - 1; t++) {
                            const alpha = 1 - (t / b.trail.length);
                            const width = 2 * (1 - t / b.trail.length);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                            ctx.lineWidth = width;
                            ctx.beginPath();
                            ctx.moveTo(b.trail[t].x, b.trail[t].y);
                            ctx.lineTo(b.trail[t + 1].x, b.trail[t + 1].y);
                            ctx.stroke();
                        }
                    }

                    // Draw rocket
                    ctx.strokeStyle = COLORS.PLAYER;
                    ctx.lineWidth = 2;
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(-6, -5);
                    ctx.lineTo(-4, 0);
                    ctx.lineTo(-6, 5);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Batch render mini rockets with trail (same player color)
            if (byType.mini_rocket.length > 0) {
                ctx.shadowColor = COLORS.PLAYER;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;

                for (const b of byType.mini_rocket) {
                    // Draw trail as fading line
                    if (b.trail && b.trail.length > 1) {
                        for (let t = 0; t < b.trail.length - 1; t++) {
                            const alpha = 1 - (t / b.trail.length);
                            const width = 1.5 * (1 - t / b.trail.length);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                            ctx.lineWidth = width;
                            ctx.beginPath();
                            ctx.moveTo(b.trail[t].x, b.trail[t].y);
                            ctx.lineTo(b.trail[t + 1].x, b.trail[t + 1].y);
                            ctx.stroke();
                        }
                    }

                    // Draw mini rocket
                    ctx.strokeStyle = COLORS.PLAYER;
                    ctx.lineWidth = 1.5;
                    const angle = Math.atan2(b.vy, b.vx);
                    const scale = b.size || 0.6;
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.scale(scale, scale);
                    ctx.beginPath();
                    ctx.moveTo(8, 0);
                    ctx.lineTo(-5, -4);
                    ctx.lineTo(-3, 0);
                    ctx.lineTo(-5, 4);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
        }
        
        function renderEnemyBullets() {
            ctx.strokeStyle = COLORS.ENEMY_BULLET;
            ctx.lineWidth = 2;
            ctx.shadowColor = COLORS.ENEMY_BULLET;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

            for (const b of enemyBullets) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(b, CULLING_DISTANCES.enemyBullets)) continue;

                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function renderDrones() {
            if (drones.length === 0) return;

            const droneColor = COLORS.PLAYER;

            for (const d of drones) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(d, CULLING_DISTANCES.drones)) continue;

                // Draw trail
                if (d.trail.length > 1) {
                    ctx.strokeStyle = droneColor;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.moveTo(d.trail[0].x, d.trail[0].y);
                    for (let i = 1; i < d.trail.length; i++) {
                        ctx.globalAlpha = 0.4 * (1 - i / d.trail.length);
                        ctx.lineTo(d.trail[i].x, d.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Draw drone body
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.angle * Math.PI / 180);

                // Drone shape (small hexagon)
                ctx.strokeStyle = droneColor;
                ctx.fillStyle = droneColor;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * DRONE_SIZE;
                    const y = Math.sin(angle) * DRONE_SIZE;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.stroke();

                // Inner glow dot
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function renderEnemies() {
            // Sort enemies by type for batched rendering
            const byType = { SCOUT: [], KAMIKAZE: [], SPINNER: [], TANK: [] };

            for (const e of enemies) {
                if (shouldRenderEntity(e, CULLING_DISTANCES.enemies)) {
                    byType[e.type].push(e);
                }
            }

            // Batch render scouts (no shadowBlur for performance)
            if (byType.SCOUT.length > 0) {
                const config = ENEMY_TYPES['SCOUT'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;

                for (const e of byType.SCOUT) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.4;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.restore();
                }
            }

            // Batch render kamikazes (no shadowBlur for performance)
            if (byType.KAMIKAZE.length > 0) {
                const config = ENEMY_TYPES['KAMIKAZE'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;

                for (const e of byType.KAMIKAZE) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.moveTo(config.radius, 0);
                    ctx.lineTo(-config.radius, -config.radius * 0.7);
                    ctx.lineTo(-config.radius * 0.5, 0);
                    ctx.lineTo(-config.radius, config.radius * 0.7);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                }
            }

            // Batch render spinners (no shadowBlur for performance)
            if (byType.SPINNER.length > 0) {
                const config = ENEMY_TYPES['SPINNER'];
                ctx.strokeStyle = config.color;

                for (const e of byType.SPINNER) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * config.radius;
                        const y = Math.sin(angle) * config.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    ctx.lineWidth = 2;
                    const rimAngle = gameTime * 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius - 5, rimAngle, rimAngle + Math.PI * 0.5);
                    ctx.stroke();

                    ctx.restore();
                }
            }

            // Batch render tanks (special case - has HP bar)
            // Batch render tanks (no shadowBlur for performance)
            if (byType.TANK.length > 0) {
                const config = ENEMY_TYPES['TANK'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;

                for (const e of byType.TANK) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.4;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
        }
        
        function renderPickups() {
            for (const p of pickups) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(p, CULLING_DISTANCES.pickups)) continue;

                const bob = Math.sin(p.bobTimer * 4) * 3;
                const pulse = 1 + Math.sin(p.bobTimer * 6) * 0.1;
                
                ctx.save();
                ctx.translate(p.x, p.y + bob);
                ctx.scale(pulse, pulse);
                
                // Outline style
                if (p.type === 'health') {
                    ctx.strokeStyle = COLORS.POWERUP;
                    ctx.shadowColor = COLORS.POWERUP;
                } else {
                    ctx.strokeStyle = COLORS.GOLD;
                    ctx.shadowColor = COLORS.GOLD;
                }
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

                // Fade when about to expire
                if (p.life < 2) {
                    ctx.globalAlpha = p.life / 2;
                }

                if (p.type === 'health') {
                    // Diamond shape - outline only
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 0);
                    ctx.closePath();
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        function renderParticles() {
            for (const p of particles) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(p, CULLING_DISTANCES.particles)) continue;

                const alpha = p.life / p.maxLife;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;
                ctx.lineWidth = 2;

                if (p.type === 'shockwave') {
                    // Expanding ring effect
                    const progress = 1 - (p.life / p.maxLife);
                    const currentSize = p.size + (p.maxSize - p.size) * progress;
                    ctx.lineWidth = 3 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.type === 'shard') {
                    // Line spark style
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle * Math.PI / 180);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(p.size * 1.5, 0);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.type === 'thruster') {
                    // Triangle flame particle (filled)
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation || 0);
                    ctx.fillStyle = p.color;
                    const s = p.size;
                    ctx.beginPath();
                    ctx.moveTo(0, -s * 0.6);
                    ctx.lineTo(s * 0.5, s * 0.4);
                    ctx.lineTo(-s * 0.5, s * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (p.type === 'ring') {
                    // Expanding ring for drone explosions (efficient)
                    const progress = 1 - (p.life / p.maxLife);
                    const radius = p.size + (p.maxSize - p.size) * progress;
                    ctx.lineWidth = 3 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Small line spark
                    const angle = Math.atan2(p.vy || 0, p.vx || 0);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + Math.cos(angle) * p.size * 2, p.y + Math.sin(angle) * p.size * 2);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function renderFloatingTexts() {
            ctx.textAlign = 'center';
            ctx.font = 'bold 16px "Segoe UI", sans-serif';

            for (const t of floatingTexts) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(t, CULLING_DISTANCES.floatingTexts)) continue;

                const alpha = t.life / t.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = t.color;
                ctx.shadowColor = t.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 4 : 0;
                ctx.fillText(t.text, t.x, t.y);
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function renderUI() {
            if (gameState === 'menu') {
                renderMenu();
            } else if (gameState === 'playing' || gameState === 'paused' || gameState === 'skilltree') {
                renderHUD();
                if (gameState === 'paused') {
                    renderPauseOverlay();
                }
                // skilltree rendering is handled by HTML panel
            } else if (gameState === 'gameOver') {
                renderHUD();
                renderGameOver();
            }
        }
        
        function renderMenu() {
            // Darken background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            
            // Title
            ctx.font = 'bold 64px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.PLAYER;
            ctx.shadowColor = COLORS.PLAYER;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 20 : 0;
            ctx.fillText('STELLAR SWARM', CANVAS_WIDTH / 2, 140);
            ctx.shadowBlur = 0;
            
            // Tagline
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Drift. Survive. Swarm the stars.', CANVAS_WIDTH / 2, 175);
            
            // High score
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.GOLD;
            ctx.fillText('HIGH SCORE: ' + highScore, CANVAS_WIDTH / 2, 220);
            
            // Start prompt
            ctx.font = 'bold 24px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            ctx.globalAlpha = pulse;
            ctx.fillText('Press ENTER or TAP to Start', CANVAS_WIDTH / 2, 280);
            ctx.globalAlpha = 1;
            
            // Controls
            renderControlsHelp(340);

            // Arsenal gallery
            renderArsenalGallery();
        }

        function renderArsenalGallery() {
            const prog = loadProgression();
            const mobile = isMobile();

            const ARSENAL_WEAPONS = [
                { id: 'laser_cannon', name: 'LASER CANNON', icon: 'laser', color: '#FF6B5B', bossLvl: 0 },
                { id: 'orbital_shield', name: 'ORBITAL SHIELD', icon: 'orbital', color: '#00DFFF', bossLvl: 8 },
                { id: 'missile_launcher', name: 'MISSILE LAUNCHER', icon: 'rocket', color: '#FFD93D', bossLvl: 14 },
                { id: 'lightning_ray', name: 'LIGHTNING RAY', icon: 'lightning', color: '#9F7AEA', bossLvl: 20 },
                { id: 'plasma_field', name: 'PLASMA FIELD', icon: 'aura', color: '#7FDBFF', bossLvl: 27 },
                { id: 'alien_drone', name: 'ALIEN DRONE', icon: 'drone', color: '#39FF14', bossLvl: 35 }
            ];

            const cols = mobile ? 2 : 3;
            const rows = mobile ? 3 : 2;
            const cardW = mobile ? 140 : 200;
            const cardH = mobile ? 100 : 120;
            const gap = mobile ? 12 : 16;

            const gridW = cols * cardW + (cols - 1) * gap;
            const gridX = (CANVAS_WIDTH - gridW) / 2;
            const titleY = mobile ? 680 : 560;
            const gridStartY = titleY + 30;

            // Title
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = 'bold 18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_CYAN;
            ctx.fillText('ARSENAL', CANVAS_WIDTH / 2, titleY);

            // Underline
            const lineW = 60;
            ctx.strokeStyle = 'rgba(127, 219, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(CANVAS_WIDTH / 2 - lineW, titleY + 8);
            ctx.lineTo(CANVAS_WIDTH / 2 + lineW, titleY + 8);
            ctx.stroke();

            const now = Date.now();

            for (let i = 0; i < ARSENAL_WEAPONS.length; i++) {
                const weapon = ARSENAL_WEAPONS[i];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cx = gridX + col * (cardW + gap);
                const cy = gridStartY + row * (cardH + gap);
                const unlocked = prog.unlockedWeapons[weapon.id];

                // Card background
                ctx.fillStyle = unlocked ? 'rgba(10, 20, 40, 0.7)' : 'rgba(10, 10, 15, 0.6)';
                ctx.beginPath();
                ctx.roundRect(cx, cy, cardW, cardH, 6);
                ctx.fill();

                // Card border
                if (unlocked) {
                    const pulse = Math.sin(now / 800 + i * 1.2) * 0.25 + 0.75;
                    ctx.strokeStyle = weapon.color;
                    ctx.globalAlpha = pulse;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(cx, cy, cardW, cardH, 6);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else {
                    ctx.strokeStyle = 'rgba(100, 100, 120, 0.35)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(cx, cy, cardW, cardH, 6);
                    ctx.stroke();
                }

                // Icon area
                const iconX = cx + cardW / 2;
                const iconY = cy + (mobile ? 30 : 36);

                if (unlocked) {
                    // Draw weapon icon scaled up
                    ctx.save();
                    ctx.translate(iconX, iconY);
                    ctx.scale(1.8, 1.8);
                    drawSkillIcon(ctx, weapon.icon, 0, 0, weapon.color);
                    ctx.restore();

                    // Checkmark
                    ctx.strokeStyle = '#39FF14';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx + cardW - 18, cy + 10);
                    ctx.lineTo(cx + cardW - 14, cy + 15);
                    ctx.lineTo(cx + cardW - 8, cy + 7);
                    ctx.stroke();
                } else {
                    // Locked icon (padlock)
                    ctx.strokeStyle = 'rgba(100, 100, 120, 0.5)';
                    ctx.fillStyle = 'rgba(100, 100, 120, 0.5)';
                    ctx.lineWidth = 1.5;
                    // Lock body
                    ctx.fillRect(iconX - 6, iconY - 2, 12, 10);
                    // Lock shackle
                    ctx.beginPath();
                    ctx.arc(iconX, iconY - 4, 5, Math.PI, 0);
                    ctx.stroke();
                }

                // Weapon name
                ctx.textAlign = 'center';
                const nameY = cy + (mobile ? 62 : 76);
                ctx.font = `bold ${mobile ? 9 : 11}px "Segoe UI", sans-serif`;
                ctx.fillStyle = unlocked ? weapon.color : 'rgba(130, 130, 150, 0.6)';
                ctx.fillText(weapon.name, cx + cardW / 2, nameY);

                // Boss level requirement (locked only)
                if (!unlocked) {
                    ctx.font = `${mobile ? 8 : 9}px "Segoe UI", sans-serif`;
                    ctx.fillStyle = 'rgba(150, 150, 170, 0.5)';
                    ctx.fillText('BOSS LVL ' + weapon.bossLvl, cx + cardW / 2, nameY + (mobile ? 13 : 15));
                }
            }

            ctx.restore();
        }

        function renderControlsHelp(startY) {
            ctx.textAlign = 'left';
            ctx.font = '14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            
            const controls = [
                ['W / ↑', 'Thrust'],
                ['S / ↓', 'Reverse'],
                ['A / ←', 'Rotate Left'],
                ['D / →', 'Rotate Right'],
                ['P / ESC', 'Pause']
            ];
            
            const colWidth = 180;
            const startX = CANVAS_WIDTH / 2 - colWidth;
            
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.font = 'bold 16px "Segoe UI", sans-serif';
            ctx.fillText('CONTROLS', startX, startY);
            
            ctx.font = '14px "Segoe UI", sans-serif';
            for (let i = 0; i < controls.length; i++) {
                const y = startY + 25 + i * 22;
                ctx.fillStyle = COLORS.PLAYER;
                ctx.fillText(controls[i][0], startX, y);
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText(controls[i][1], startX + 80, y);
            }
            
            // Touch controls note
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.font = 'italic 12px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Touch: Use joystick to move', CANVAS_WIDTH / 2, startY + 180);
        }
        
        function renderHUD() {
            if (!player) return;

            const HUD_PADDING = 16;

            // ═══════════════════════════════════════
            // KILLS & SCORE (top-left)
            // ═══════════════════════════════════════
            ctx.textAlign = 'left';

            // "KILLS" label
            ctx.font = '10px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText('KILLS', HUD_PADDING, 25);

            // Kills value (big)
            ctx.font = 'bold 28px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_PRIMARY;
            if (ENABLE_GLOW_EFFECTS) {
                ctx.shadowColor = COLORS.HUD_CYAN_GLOW;
                ctx.shadowBlur = 20;
            }
            ctx.fillText(totalKills.toLocaleString(), HUD_PADDING, 52);
            ctx.shadowBlur = 0;

            // "SCORE" label
            ctx.font = '9px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText('SCORE', HUD_PADDING, 68);

            // Score value (smaller)
            ctx.font = '14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText(Math.floor(score).toLocaleString(), HUD_PADDING, 82);

            // ═══════════════════════════════════════
            // LEVEL & XP PANEL (top-center)
            // ═══════════════════════════════════════
            const levelPanelWidth = 260;
            const levelPanelX = (CANVAS_WIDTH - levelPanelWidth) / 2;

            // "LEVEL" label + hexagon badge
            ctx.textAlign = 'center';
            ctx.font = '10px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText('LEVEL', CANVAS_WIDTH / 2 - 30, 25);

            // Hexagon badge
            const hexX = CANVAS_WIDTH / 2 + 10;
            const hexY = 30;
            const hexSize = 18;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 2;
                const px = hexX + Math.cos(angle) * hexSize;
                const py = hexY + Math.sin(angle) * hexSize;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 255, 170, 0.04)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 255, 170, 0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Level number inside hexagon
            ctx.font = 'bold 14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_GREEN;
            if (ENABLE_GLOW_EFFECTS) {
                ctx.shadowColor = 'rgba(0, 255, 170, 0.5)';
                ctx.shadowBlur = 10;
            }
            ctx.fillText(playerLevel.toString(), hexX, hexY + 5);
            ctx.shadowBlur = 0;

            // XP bar
            const xpBarX = levelPanelX;
            const xpBarY = 52;
            const xpBarWidth = levelPanelWidth;
            const xpBarHeight = 6;
            const xpProgress = playerXP / xpToNextLevel;

            // Bar track
            ctx.fillStyle = 'rgba(255, 255, 255, 0.04)';
            ctx.strokeStyle = 'rgba(0, 255, 170, 0.12)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(xpBarX, xpBarY, xpBarWidth, xpBarHeight, 1);
            ctx.fill();
            ctx.stroke();

            // Bar fill
            if (xpProgress > 0) {
                const fillGrad = ctx.createLinearGradient(xpBarX, 0, xpBarX + xpBarWidth * xpProgress, 0);
                fillGrad.addColorStop(0, COLORS.HUD_GREEN_DIM);
                fillGrad.addColorStop(1, COLORS.HUD_GREEN);
                ctx.fillStyle = fillGrad;
                ctx.beginPath();
                ctx.roundRect(xpBarX, xpBarY, xpBarWidth * xpProgress, xpBarHeight, 1);
                ctx.fill();

                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = 'rgba(0, 255, 170, 0.4)';
                    ctx.shadowBlur = 12;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Tick marks
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 10; i++) {
                const tickX = xpBarX + (xpBarWidth / 10) * i;
                ctx.beginPath();
                ctx.moveTo(tickX, xpBarY);
                ctx.lineTo(tickX, xpBarY + xpBarHeight);
                ctx.stroke();
            }

            // XP text
            ctx.textAlign = 'right';
            ctx.font = '9px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.HUD_TEXT_SECONDARY;
            ctx.fillText(playerXP + ' / ' + xpToNextLevel + ' XP', xpBarX + xpBarWidth, xpBarY + xpBarHeight + 12);

            // ═══════════════════════════════════════
            // VITALS PANEL (top-right)
            // ═══════════════════════════════════════
            const vitalsX = CANVAS_WIDTH - HUD_PADDING;

            // HULL - mini ships (filled)
            ctx.textAlign = 'right';
            const shipScale = 0.4;
            const shipSpacing = 26;
            const hullStartX = vitalsX - (PLAYER_MAX_HP * shipSpacing) + 10;

            for (let i = 0; i < PLAYER_MAX_HP; i++) {
                const shipX = hullStartX + i * shipSpacing;
                const shipY = 28;
                const isActive = i < player.hp;

                ctx.save();
                ctx.translate(shipX, shipY);
                ctx.scale(shipScale, shipScale);
                ctx.rotate(-Math.PI / 2); // Ships pointing up

                ctx.beginPath();
                ctx.moveTo(22, 0);
                ctx.lineTo(-12, -16);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-12, 16);
                ctx.closePath();

                if (isActive) {
                    ctx.fillStyle = COLORS.PLAYER;
                    ctx.fill();
                    if (ENABLE_GLOW_EFFECTS) {
                        ctx.shadowColor = COLORS.HUD_CYAN_GLOW;
                        ctx.shadowBlur = 8;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                } else {
                    ctx.fillStyle = COLORS.HUD_CYAN_DIM;
                    ctx.globalAlpha = 0.3;
                    ctx.fill();
                }
                ctx.restore();
            }

            // SHIELD section
            const shieldPercent = player.shield / PLAYER_MAX_SHIELD;
            const isRegenerating = player.shieldRegenTimer >= SHIELD_REGEN_DELAY && player.shield < PLAYER_MAX_SHIELD;

            // Shield bar
            const shieldBarWidth = 160;
            const shieldBarHeight = 10;
            const shieldBarX = vitalsX - shieldBarWidth;
            const shieldBarY = 50;

            // Shield icon (left of bar)
            const shieldIconX = shieldBarX - 18;
            const shieldIconY = shieldBarY + shieldBarHeight / 2;
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(shieldIconX, shieldIconY - 2, 8, -Math.PI * 0.8, Math.PI * 0.8);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(shieldIconX - 6, shieldIconY + 5);
            ctx.lineTo(shieldIconX, shieldIconY + 10);
            ctx.lineTo(shieldIconX + 6, shieldIconY + 5);
            ctx.stroke();

            // Bar background (using player color)
            ctx.fillStyle = 'rgba(127, 219, 255, 0.04)';
            ctx.strokeStyle = 'rgba(127, 219, 255, 0.18)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(shieldBarX, shieldBarY, shieldBarWidth, shieldBarHeight, 2);
            ctx.fill();
            ctx.stroke();

            // Bar fill
            if (shieldPercent > 0) {
                let barColor = COLORS.PLAYER;
                let barGlowColor = COLORS.HUD_CYAN_GLOW;

                if (player.shieldFlashTimer > 0) {
                    barColor = '#FFFFFF';
                    barGlowColor = 'rgba(255, 255, 255, 0.5)';
                } else if (isRegenerating) {
                    const pulse = Math.sin(Date.now() / 80) * 0.2 + 0.8;
                    ctx.globalAlpha = pulse;
                    barColor = COLORS.HUD_SHIELD_REGEN;
                }

                const fillGrad = ctx.createLinearGradient(shieldBarX, 0, shieldBarX + shieldBarWidth * shieldPercent, 0);
                fillGrad.addColorStop(0, COLORS.HUD_CYAN_DIM);
                fillGrad.addColorStop(1, barColor);
                ctx.fillStyle = fillGrad;
                ctx.beginPath();
                ctx.roundRect(shieldBarX, shieldBarY, shieldBarWidth * shieldPercent, shieldBarHeight, 2);
                ctx.fill();

                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = barGlowColor;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                ctx.globalAlpha = 1;
            }

            // Regen icon (spinning arc)
            if (isRegenerating) {
                const regenIconX = shieldBarX - 32;
                const regenIconY = shieldBarY + shieldBarHeight / 2;
                const rotation = Date.now() / 200;

                ctx.save();
                ctx.translate(regenIconX, regenIconY);
                ctx.rotate(rotation);
                ctx.strokeStyle = COLORS.HUD_SHIELD_REGEN;
                ctx.lineWidth = 1.2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 1.5);
                ctx.stroke();
                // Arrow
                ctx.fillStyle = COLORS.HUD_SHIELD_REGEN;
                ctx.beginPath();
                ctx.moveTo(-2, -3.5);
                ctx.lineTo(-2, -6.5);
                ctx.lineTo(1, -5);
                ctx.fill();
                ctx.restore();
            }

            // ═══════════════════════════════════════
            // WAVE ALERT (below level panel, conditional)
            // ═══════════════════════════════════════
            if (waveAlertActive && waveAlertTimer < WAVE_ALERT_DURATION) {
                const alertProgress = waveAlertTimer / WAVE_ALERT_DURATION;
                const fadeIn = Math.min(1, alertProgress * 4);
                const fadeOut = alertProgress > 0.7 ? 1 - ((alertProgress - 0.7) / 0.3) : 1;
                const alpha = fadeIn * fadeOut;

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.textAlign = 'center';

                // "WAVE X" text
                ctx.font = 'bold 16px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.HUD_RED;
                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
                    ctx.shadowBlur = 20;
                }
                ctx.fillText('WAVE ' + waveAlertNumber, CANVAS_WIDTH / 2, 100);
                ctx.shadowBlur = 0;

                // Subtitle
                if (waveAlertSubtitle) {
                    ctx.font = '9px "Segoe UI", sans-serif';
                    ctx.fillStyle = 'rgba(255, 107, 107, 0.5)';
                    ctx.fillText(waveAlertSubtitle.toUpperCase(), CANVAS_WIDTH / 2, 115);
                }

                ctx.restore();
            }

            // ═══════════════════════════════════════
            // ACTIVE WEAPONS (top-right, below shield)
            // ═══════════════════════════════════════
            const allWeapons = [
                { id: 'laser_cannon', color: '#FF6B5B', icon: 'laser' },
                { id: 'missile_launcher', color: '#FFD93D', icon: 'rocket' },
                { id: 'orbital_shield', color: '#00DFFF', icon: 'orbital' },
                { id: 'lightning_ray', color: '#9F7AEA', icon: 'lightning' },
                { id: 'plasma_field', color: '#7FDBFF', icon: 'aura' },
                { id: 'alien_drone', color: '#39FF14', icon: 'drone' }
            ];

            // Only show active (unlocked) weapons
            const activeWeapons = allWeapons.filter(w => unlockedSkills.includes(w.id));
            const weaponIconSize = 12;
            const weaponSpacing = 32;
            const weaponsStartX = vitalsX - (activeWeapons.length * weaponSpacing) + weaponSpacing / 2;
            const weaponsY = 85;

            for (let i = 0; i < activeWeapons.length; i++) {
                const weapon = activeWeapons[i];
                const iconX = weaponsStartX + i * weaponSpacing;
                const iconY = weaponsY;

                // Weapon icon circle
                ctx.beginPath();
                ctx.arc(iconX, iconY, weaponIconSize, 0, Math.PI * 2);
                ctx.strokeStyle = weapon.color;
                ctx.lineWidth = 1.5;
                ctx.stroke();

                if (ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = weapon.color;
                    ctx.shadowBlur = 6;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Draw weapon icon inside circle
                ctx.fillStyle = weapon.color;
                ctx.strokeStyle = weapon.color;
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';

                ctx.save();
                ctx.translate(iconX, iconY);
                const s = weaponIconSize * 0.5;

                switch (weapon.icon) {
                    case 'laser':
                        // Horizontal beam
                        ctx.beginPath();
                        ctx.moveTo(-s, 0);
                        ctx.lineTo(s, 0);
                        ctx.stroke();
                        break;
                    case 'rocket':
                        // Triangle pointing up
                        ctx.beginPath();
                        ctx.moveTo(0, -s);
                        ctx.lineTo(-s * 0.6, s * 0.6);
                        ctx.lineTo(s * 0.6, s * 0.6);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'orbital':
                        // Small orbit with dot
                        ctx.beginPath();
                        ctx.arc(0, 0, s * 0.5, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(s * 0.5, 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'lightning':
                        // Lightning bolt
                        ctx.beginPath();
                        ctx.moveTo(s * 0.2, -s);
                        ctx.lineTo(-s * 0.2, 0);
                        ctx.lineTo(s * 0.2, 0);
                        ctx.lineTo(-s * 0.2, s);
                        ctx.stroke();
                        break;
                    case 'aura':
                        // Concentric arcs
                        ctx.beginPath();
                        ctx.arc(0, 0, s * 0.3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 0, s * 0.7, Math.PI * 0.2, Math.PI * 0.8);
                        ctx.stroke();
                        break;
                    case 'drone':
                        // Diamond
                        ctx.beginPath();
                        ctx.moveTo(0, -s * 0.7);
                        ctx.lineTo(s * 0.5, 0);
                        ctx.lineTo(0, s * 0.7);
                        ctx.lineTo(-s * 0.5, 0);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();

                // Upgrade dots below icon
                const upgrades = WEAPON_UPGRADES[weapon.id] || [];
                const dotSpacing = 6;
                const dotY = iconY + weaponIconSize + 7;
                const dotsStartX = iconX - ((upgrades.length - 1) * dotSpacing) / 2;

                for (let j = 0; j < upgrades.length; j++) {
                    const dotX = dotsStartX + j * dotSpacing;
                    const isUpgraded = unlockedSkills.includes(upgrades[j]);

                    ctx.beginPath();
                    ctx.arc(dotX, dotY, 2.5, 0, Math.PI * 2);

                    if (isUpgraded) {
                        ctx.fillStyle = weapon.color;
                        ctx.fill();
                    } else {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.fill();
                    }
                }
            }

            // ═══════════════════════════════════════
            // SKILL POINTS INDICATOR
            // ═══════════════════════════════════════
            if (skillPoints > 0) {
                ctx.textAlign = 'center';
                ctx.fillStyle = COLORS.HUD_GOLD;
                ctx.font = 'bold 14px "Segoe UI", sans-serif';
                ctx.fillText('SKILL POINTS: ' + skillPoints + ' (Press TAB)', CANVAS_WIDTH / 2, CANVAS_HEIGHT - 55);
            }

            // Boss health bar (overlays HUD when boss is active)
            renderBossHealthBar();
        }
        function renderPauseOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            ctx.font = 'bold 48px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
            
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Press P or ESC to Resume', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.fillText('Press R to Restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
        }
        
        function renderGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            
            // Game Over title
            ctx.font = 'bold 56px "Segoe UI", sans-serif';
            ctx.fillStyle = '#FF6B6B';
            ctx.shadowColor = '#FF6B6B';
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 15 : 0;
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 80);
            ctx.shadowBlur = 0;
            
            // Score
            ctx.font = 'bold 32px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('SCORE: ' + Math.floor(score), CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            
            // High score
            ctx.font = '24px "Segoe UI", sans-serif';
            if (isNewHighScore) {
                ctx.fillStyle = COLORS.GOLD;
                ctx.shadowColor = COLORS.GOLD;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 10 : 0;
                ctx.fillText('★ NEW HIGH SCORE! ★', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText('BEST: ' + highScore, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            }
            
            // Time survived
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Time: ' + minutes + 'm ' + seconds + 's', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 55);
            
            // Retry prompt
            ctx.font = 'bold 22px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            ctx.globalAlpha = pulse;
            ctx.fillText('Press R or TAP to Retry', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 100);
            ctx.globalAlpha = 1;
        }
        
        // ============================================================
        // UTILITIES
        // ============================================================
        
        function normalizeAngle(angle) {
            while (angle > 180) angle -= 360;
            while (angle < -180) angle += 360;
            return angle;
        }

        // ============================================================
        // START GAME
        // ============================================================
        
        init();
        
    })();
    </script>
</body>
</html>
