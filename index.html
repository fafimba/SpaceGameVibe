<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Stellar Swarm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100dvh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        #gameContainer {
            position: relative;
            background: #020617;
        }
        
        #game {
            display: block;
        }
        
        /* Touch Controls */
        #touchControls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .touch-zone {
            position: absolute;
            pointer-events: auto;
        }
        
        #joystickZone {
            left: 50%;
            bottom: 0;
            width: 50%;
            height: 50%;
            transform: translateX(-50%);
        }

        #joystickBase {
            position: fixed;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 50%;
            display: none;
            pointer-events: none;
        }

        #joystickKnob {
            position: absolute;
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 50%;
            left: 12px;
            top: 12px;
            transition: none;
        }
        
        @media (pointer: coarse) {
            #touchControls {
                display: block;
            }
        }

        /* Upgrade Selection Panel */
        #upgradePanel {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 20, 0.95);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #upgradePanel.active {
            display: flex;
        }

        .upgrade-title {
            color: #FFD700;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            text-align: center;
        }

        .upgrade-subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 30px;
            text-align: center;
        }

        .upgrade-cards {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 380px;
        }

        .upgrade-card {
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.95) 0%, rgba(30, 40, 70, 0.9) 100%);
            border: 2px solid rgba(100, 100, 140, 0.4);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .upgrade-card:hover {
            transform: scale(1.02);
            border-color: var(--skill-color);
            box-shadow: 0 0 25px var(--skill-color-glow);
            background: linear-gradient(135deg, rgba(30, 40, 60, 0.95) 0%, rgba(40, 50, 80, 0.9) 100%);
        }

        .upgrade-card:active {
            transform: scale(0.98);
        }

        .upgrade-icon {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        .upgrade-info {
            flex: 1;
            min-width: 0;
        }

        .upgrade-name {
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .upgrade-desc {
            font-size: 13px;
            color: #aaa;
            line-height: 1.35;
        }

        .upgrade-key {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #666;
            flex-shrink: 0;
        }

        @media (max-height: 500px) {
            .upgrade-title {
                font-size: 24px;
                margin-bottom: 4px;
            }
            .upgrade-subtitle {
                font-size: 14px;
                margin-bottom: 15px;
            }
            .upgrade-card {
                padding: 12px;
            }
            .upgrade-icon {
                width: 44px;
                height: 44px;
            }
            .upgrade-name {
                font-size: 15px;
            }
            .upgrade-desc {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="touchControls">
            <div id="joystickZone" class="touch-zone"></div>
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <div id="upgradePanel">
            <div class="upgrade-title">LEVEL UP!</div>
            <div class="upgrade-subtitle">Choose an upgrade</div>
            <div class="upgrade-cards" id="upgradeCards"></div>
        </div>
    </div>

    <script>
    // ============================================================
    // STELLAR SWARM - Single File Game
    // ============================================================

    (function() {
        'use strict';

        // ============================================================
        // CONSTANTS
        // ============================================================
        
        // Canvas dimensions - set dynamically based on device
        let CANVAS_WIDTH = 1920;
        let CANVAS_HEIGHT = 1080;

        // Detect mobile device
        function isMobile() {
            return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) && window.innerWidth < 1024;
        }
        
        // Physics
        const ROTATION_SPEED = 300;          // deg/sec
        const THRUST_ACCEL = 2200;           // px/sec²
        const REVERSE_ACCEL = 450;           // px/sec²
        const MAX_SPEED = 600;               // px/sec
        const DRAG_FACTOR = 0.5;             // Increased drag to reduce inertia
        const BULLET_SPEED = 2000;           // px/sec
        const ORBITAL_RADIUS = 130;          // px - Radio base de los escudos orbitales
        const ORBITAL_SIZE = 26;             // px - Tamaño base de cada esfera orbital
        const ORBITAL_SPEED = 3;           // rad/sec - Velocidad base de rotacion

        // Garlic Aura
        const AURA_BASE_RADIUS = 100;      // px
        const AURA_BASE_DAMAGE = 4;        // damage per tick
        const AURA_BASE_TICK_RATE = 0.5;   // seconds between ticks

        // Alien Drone
        const DRONE_SPEED = 450;           // px/sec
        const DRONE_BASE_DAMAGE = 1;       // damage on impact
        const DRONE_EXPLOSION_RADIUS = 80; // px - explosion AoE radius
        const DRONE_EXPLOSION_DAMAGE = 1;  // damage in explosion area
        const DRONE_TURN_RATE = 360;       // degrees/sec
        const DRONE_SIZE = 5;              // px - small drones

        // Player
        const PLAYER_SIZE = 48;
        const PLAYER_COLLISION_RADIUS = 20;
        const PLAYER_VISUAL_RADIUS = 24;
        const PLAYER_MAX_HP = 3;
        const PLAYER_PIVOT_OFFSET = -5;
        const PLAYER_MASS = 2.5;             // Mass factor: higher = more inertia, harder to change direction       // Offset del punto de pivote: positivo = hacia el morro, negativo = hacia la cola

        // Shield System
        const PLAYER_MAX_SHIELD = 100;           // Escudo máximo
        const SHIELD_REGEN_RATE = 15;            // Puntos por segundo
        const SHIELD_REGEN_DELAY = 2.5;          // Segundos sin daño para regenerar
        const SHIELD_DAMAGE_ABSORPTION = 25;     // Daño por golpe (4 golpes = escudo vacío)

        // Weapons
        const AUTO_FIRE_INTERVAL = 0.35;
        const BULLET_LIFETIME = 1.2;
        
        // Enemies
        const ENEMY_TYPES = {
            SCOUT: { radius: 10, speed: 120, turnRate: 90, hp: 4, points: 10, color: '#FF6B6B', outline: '#C04848' },
            KAMIKAZE: { radius: 10, speed: 180, turnRate: 60, hp: 4, points: 25, color: '#FF9A6B', outline: '#D86A3A' },
            SPINNER: { radius: 14, speed: 90, turnRate: 60, hp: 4, points: 40, color: '#3A9AD9', outline: '#1E6F9A', fireRate: 1.2 },
            TANK: { radius: 22, speed: 70, turnRate: 45, hp: 12, points: 75, color: '#C792FF', outline: '#8A5DBF' }
        };
        
        const INITIAL_SPAWN_INTERVAL_MIN = 0.15;
        const INITIAL_SPAWN_INTERVAL_MAX = 0.35;
        const MIN_SPAWN_INTERVAL = 0.03;
        const SPAWN_DECAY_RATE = 0.05;
        const SPAWN_DECAY_INTERVAL = 10;
        const MAX_ENEMIES = 500;
        const MAX_ENEMIES_LOW_PERF = 200;
        
        // Scoring
        const CHAIN_WINDOW = 2.2;
        const CHAIN_MULTIPLIERS = [1, 1.2, 1.5, 2, 2.5, 3];
        const NEAR_MISS_RADIUS = 12;
        const NEAR_MISS_POINTS = 5;
        const MILESTONE_INTERVAL = 5000;
        
        // Effects
        const SHAKE_INTENSITY_HIT = 6;
        const SHAKE_DURATION_HIT = 220;
        const SHAKE_DURATION_DEATH = 420;
        const SLOWMO_FACTOR = 0.45;
        const SLOWMO_DURATION = 180;
        
        // Colors
        const COLORS = {
            PLAYER: '#7FDBFF',
            PLAYER_OUTLINE: '#3A9AD9',
            SHIELD: '#3A9AD9',
            SHIELD_BG: '#1A4A6A',
            THRUSTER: '#FFDD57',
            BULLET: '#7FDBFF',
            ENEMY_BULLET: '#FF6B6B',
            POWERUP: '#00FFAA',
            GOLD: '#FFDD57',
            RARE: '#C792FF',
            XP: '#00FFAA',
            UI_PRIMARY: '#FFFFFF',
            UI_SECONDARY: '#AAAAAA',
            BG_TOP: '#020617',
            BG_BOTTOM: '#000000'
        };
        
        // XP & Level System
        const XP_PER_LEVEL_BASE = 25;
        const XP_PER_LEVEL_GROWTH = 1.4;

        // Touch Controls
        const JOYSTICK_MAX_DISTANCE = 38;
        const JOYSTICK_DEADZONE = 0.2;
        const JOYSTICK_THRUST_THRESHOLD = 0.3;

        // Auto-Aim
        const AUTO_AIM_CONE_DEGREES = 30; // ±30° = 60° total cone
        const AUTO_AIM_MAX_DISTANCE = 700; // px - max range for laser auto-aim

        // Enemy Spawn
        const ENEMY_SPAWN_OFFSET_MIN = 50;
        const ENEMY_SPAWN_OFFSET_RANGE = 30;
        const ENEMY_SEPARATION_PADDING = 8;

        // Wave System - Vampire Survivor style
        const WAVE_INTERVAL_BASE = 2.5;       // Base seconds between waves (gets faster with level)
        const WAVE_INTERVAL_VARIANCE = 1.5;   // Random variance in seconds
        const WAVE_SPAWN_DISTANCE = 850;      // Distance from player
        const WAVE_PATTERNS = [
            'arc',           // Enemies in an arc around player
            'side',          // All enemies from one side
            'pincer',        // Enemies from two opposite sides
            'circle',        // Hexagonal staggered pattern (3 inner, 3 outer)
            'line',          // Horizontal or vertical line
            'cluster',       // Tight cluster from one direction
            'spiral',        // Spiral pattern converging on player
            'corners',       // From all 4 corners
            'rush',          // Dense column rushing from one direction
            'scatter',       // Random positions all around
            'v_formation'    // V-shape formation
        ];

        // Sector System - Infinite World
        const SECTOR_WIDTH = 3840;      // 2x viewport width
        const SECTOR_HEIGHT = 2160;     // 2x viewport height
        const GRID_SIZE = 3;            // 3x3 grid
        const WORLD_WIDTH = SECTOR_WIDTH * GRID_SIZE;   // 11520
        const WORLD_HEIGHT = SECTOR_HEIGHT * GRID_SIZE; // 6480

        const SECTOR_BOUNDS = {
            minX: -SECTOR_WIDTH / 2,     // -1920
            maxX: SECTOR_WIDTH / 2,      // +1920
            minY: -SECTOR_HEIGHT / 2,    // -1080
            maxY: SECTOR_HEIGHT / 2      // +1080
        };

        // Player Rotation
        const JOYSTICK_ROTATION_THRESHOLD = 5; // degrees
        
        // Skill Tree Definitions
        const SKILL_TREE = {
            // Root node - Ship Arsenal (unlocked by default)
            'arsenal': {
                name: 'SHIP ARSENAL',
                description: 'Your ship\'s weapon systems',
                prereqs: [],
                cost: 0,
                color: '#00DFFF',
                icon: 'arsenal',
                nodeType: 'hexagon'
            },
            // LASER CANNON branch (red/coral theme)
            'laser_cannon': {
                name: 'LASER CANNON',
                description: 'High-powered energy weapon',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'laser',
                nodeType: 'rectangle'
            },
            'rapid_fire': {
                name: 'Rapid Fire Module',
                description: 'Faster fire rate',
                prereqs: ['laser_cannon'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'rate',
                nodeType: 'circle'
            },
            'piercing_lens': {
                name: 'Piercing Lens',
                description: 'Laser penetrates enemies',
                prereqs: ['laser_cannon'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'beam',
                nodeType: 'circle'
            },
            'beam_splitter': {
                name: 'Beam Splitter',
                description: 'Fire 3 beams in a cone',
                prereqs: ['laser_cannon'],
                cost: 1,
                color: '#FF6B5B',
                icon: 'spread',
                nodeType: 'circle'
            },
            // MISSILE LAUNCHER branch (yellow/gold theme)
            'missile_launcher': {
                name: 'MISSILE LAUNCHER',
                description: 'Homing missile system',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#FFD93D',
                icon: 'rocket',
                nodeType: 'rectangle'
            },
            'homing_guidance': {
                name: 'Rapid Barrage',
                description: 'Double burst (6 missiles per salvo)',
                prereqs: ['missile_launcher'],
                cost: 1,
                color: '#FFD93D',
                icon: 'target',
                nodeType: 'circle'
            },
            'cluster_payload': {
                name: 'Ricochet Warhead',
                description: 'Spawn 2 mini missiles on hit',
                prereqs: ['missile_launcher'],
                cost: 1,
                color: '#FFD93D',
                icon: 'cluster',
                nodeType: 'circle'
            },
            'armor_piercing': {
                name: 'Heavy Payload',
                description: '+12 missile & +8 explosion damage',
                prereqs: ['missile_launcher'],
                cost: 1,
                color: '#FFD93D',
                icon: 'damage',
                nodeType: 'circle'
            },
            // ORBITAL SHIELD branch (cyan/teal theme)
            'orbital_shield': {
                name: 'ORBITAL SHIELD',
                description: '3 fast rotating orbs damage enemies',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#00DFFF',
                icon: 'orbital',
                nodeType: 'rectangle'
            },
            'regen_capacitors': {
                name: 'Orbital Expansion',
                description: '+2 orbs (5 total)',
                prereqs: ['orbital_shield'],
                cost: 1,
                color: '#00DFFF',
                icon: 'regen',
                nodeType: 'circle'
            },
            'shockwave_emitter': {
                name: 'Orbital Amplification',
                description: 'Orbs +50% size',
                prereqs: ['orbital_shield'],
                cost: 1,
                color: '#00DFFF',
                icon: 'shockwave',
                nodeType: 'circle'
            },
            'energy_absorption': {
                name: 'Energy Absorption',
                description: 'Orbs deal +16 damage',
                prereqs: ['orbital_shield'],
                cost: 1,
                color: '#00DFFF',
                icon: 'absorb',
                nodeType: 'circle'
            },
            // LIGHTNING RAY branch (electric purple/blue theme)
            'lightning_ray': {
                name: 'LIGHTNING RAY',
                description: 'Chain lightning hits nearby enemies',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'lightning',
                nodeType: 'rectangle'
            },
            'chain_amplifier': {
                name: 'Chain Amplifier',
                description: '+3 chain bounces (6 total)',
                prereqs: ['lightning_ray'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'chain',
                nodeType: 'circle'
            },
            'rapid_discharge': {
                name: 'Rapid Discharge',
                description: '+50% lightning fire rate',
                prereqs: ['lightning_ray'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'discharge',
                nodeType: 'circle'
            },
            'extended_arc': {
                name: 'Extended Arc',
                description: '+50% detection & chain range',
                prereqs: ['lightning_ray'],
                cost: 1,
                color: '#9F7AEA',
                icon: 'arc',
                nodeType: 'circle'
            },
            // PLASMA FIELD branch (cyan theme - same as player)
            'plasma_field': {
                name: 'PLASMA FIELD',
                description: 'Damaging energy field around the ship',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'aura',
                nodeType: 'rectangle'
            },
            'field_expansion': {
                name: 'Field Expansion',
                description: '+50% field radius',
                prereqs: ['plasma_field'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'expand',
                nodeType: 'circle'
            },
            'field_intensity': {
                name: 'Field Intensity',
                description: '+8 field damage',
                prereqs: ['plasma_field'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'damage',
                nodeType: 'circle'
            },
            'field_pulse': {
                name: 'Rapid Pulse',
                description: '+50% tick rate',
                prereqs: ['plasma_field'],
                cost: 1,
                color: '#7FDBFF',
                icon: 'pulse',
                nodeType: 'circle'
            },
            // ALIEN DRONE branch (green/toxic theme)
            'alien_drone': {
                name: 'ALIEN DRONE',
                description: 'Kamikaze drones spawn from killed enemies',
                prereqs: ['arsenal'],
                cost: 1,
                color: '#39FF14',
                icon: 'drone',
                nodeType: 'rectangle'
            },
            'drone_duo': {
                name: 'Drone Swarm',
                description: 'Spawn 2 drones per kill',
                prereqs: ['alien_drone'],
                cost: 1,
                color: '#39FF14',
                icon: 'swarm',
                nodeType: 'circle'
            },
            'drone_duration': {
                name: 'Extended Range',
                description: 'Drones last twice as long',
                prereqs: ['alien_drone'],
                cost: 1,
                color: '#39FF14',
                icon: 'duration',
                nodeType: 'circle'
            },
            'drone_explosion': {
                name: 'Volatile Core',
                description: 'Drones explode on impact (AoE damage)',
                prereqs: ['alien_drone'],
                cost: 1,
                color: '#39FF14',
                icon: 'explosion',
                nodeType: 'circle'
            }
        };
        
        // ============================================================
        // GAME STATE
        // ============================================================
        
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        
        let gameState = 'menu'; // menu, playing, paused, gameOver, skilltree
        let lastTime = 0;
        let deltaTime = 0;
        let timeScale = 1;
        let gameTime = 0;
        let score = 0;
        let highScore = 0;
        let isNewHighScore = false;

        // Safe localStorage access
        try {
            highScore = parseInt(localStorage.getItem('StellarSwarm_highscore_v1')) || 0;
        } catch (e) {
            console.warn('localStorage not available:', e);
            highScore = 0;
        }
        
        // Performance monitoring
        let frameTimeAccum = 0;
        let frameCount = 0;
        let avgFrameTime = 16;
        let lowPerfMode = false;

        // Disable glow effects for massive performance boost
        // shadowBlur is extremely expensive on canvas
        const ENABLE_GLOW_EFFECTS = false;

        // Helper to set glow only when enabled
        function setGlow(context, color, blur) {
            if (ENABLE_GLOW_EFFECTS) {
                context.shadowColor = color;
                context.shadowBlur = blur;
            }
        }

        function clearGlow(context) {
            if (ENABLE_GLOW_EFFECTS) {
                context.shadowBlur = 0;
            }
        }
        
        // Input state
        const keys = {};
        const input = {
            rotateLeft: false,
            rotateRight: false,
            thrust: false,
            reverse: false,
            pause: false
        };
        
        // Cheat code system
        let cheatCodeBuffer = '';
        const CHEAT_CODES = {
            'rocket': () => {
                // Unlock missile launcher and all missile upgrades
                if (!unlockedSkills.includes('missile_launcher')) {
                    unlockedSkills.push('missile_launcher');
                }
                ['homing_guidance', 'cluster_payload', 'armor_piercing'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                showFloatingText(player.x, player.y - 50, 'MISSILES UNLOCKED', '#FFD93D');
                createTextExplosion(player.x, player.y, 'MISSILES UNLOCKED', '#FFD93D');
            },
            'orbit': () => {
                // Unlock orbital shield and all shield upgrades
                if (!unlockedSkills.includes('orbital_shield')) {
                    unlockedSkills.push('orbital_shield');
                }
                ['regen_capacitors', 'shockwave_emitter', 'energy_absorption'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                showFloatingText(player.x, player.y - 50, 'ORBITAL SHIELD UNLOCKED', '#00DFFF');
                createTextExplosion(player.x, player.y, 'ORBITAL SHIELD UNLOCKED', '#00DFFF');
            },
            'chain': () => {
                // Unlock lightning ray and all lightning upgrades
                if (!unlockedSkills.includes('lightning_ray')) {
                    unlockedSkills.push('lightning_ray');
                }
                ['chain_amplifier', 'rapid_discharge', 'extended_arc'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                showFloatingText(player.x, player.y - 50, 'LIGHTNING RAY UNLOCKED', '#9F7AEA');
                createTextExplosion(player.x, player.y, 'LIGHTNING RAY UNLOCKED', '#9F7AEA');
            },
            'drone': () => {
                // Unlock alien drone and all drone upgrades
                if (!unlockedSkills.includes('alien_drone')) {
                    unlockedSkills.push('alien_drone');
                }
                ['drone_duo', 'drone_duration', 'drone_explosion'].forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                showFloatingText(player.x, player.y - 50, 'ALIEN DRONES UNLOCKED', '#39FF14');
                createTextExplosion(player.x, player.y, 'ALIEN DRONES UNLOCKED', '#39FF14');
            },
            'full': () => {
                // Unlock ALL skills
                Object.keys(SKILL_TREE).forEach(skill => {
                    if (!unlockedSkills.includes(skill)) {
                        unlockedSkills.push(skill);
                    }
                });
                showFloatingText(player.x, player.y - 50, 'ALL ABILITIES UNLOCKED', '#FFD700');
                createTextExplosion(player.x, player.y, 'FULL ARSENAL', '#FFD700');
            }
        };
        
        // Touch state
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickMagnitude = 0;
        
        // Player
        let player = null;
        
        // Entity pools
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let particles = [];
        let floatingTexts = [];
        let pickups = [];
        let orbitals = [];
        let lightningEffects = [];
        let drones = [];
        let auraState = {
            tickTimer: 0,
            pulseAnimation: 0
        };

        // Camera system
        let camera = {
            x: 0,              // World X position (center of viewport)
            y: 0,              // World Y position (center of viewport)
            targetX: 0,        // Target X to follow (player.x)
            targetY: 0,        // Target Y to follow (player.y)
            smoothing: 0.1     // Camera lag for smooth follow (0.1 = 10% per frame)
        };


        // XP & Level state
        let playerXP = 0;
        let playerLevel = 1;
        let xpToNextLevel = XP_PER_LEVEL_BASE;
        
        // Skill Tree state
        let skillPoints = 0;
        let unlockedSkills = ['arsenal', 'laser_cannon'];
        let upgradeOptions = [];
        let upgradeSelectionActive = false;
        
        // Spawn system
        let spawnTimer = 0;
        let spawnInterval = INITIAL_SPAWN_INTERVAL_MAX;
        let lastSpawnDecayTime = 0;
        let waveNumber = 0;

        // Wave system
        let waveTimer = WAVE_INTERVAL_BASE + Math.random() * WAVE_INTERVAL_VARIANCE;
        let lastWavePattern = null;
        
        // Chain system
        let chainMultiplier = 0;
        let lastKillTime = 0;
        
        // Effects
        let shakeIntensity = 0;
        let shakeDuration = 0;
        let shakeTimer = 0;
        let flashColor = null;
        let flashOpacity = 0;
        let flashDuration = 0;
        let slowmoTimer = 0;
        let slowmoDuration = 0;
        
        // Milestones
        let lastMilestone = 0;
        let milestoneActive = false;
        let milestoneTimer = 0;
        
        // Background
        let nebulas = [];
        let cachedBgGradient = null;
        let cachedScanlinePattern = null;
        let cachedVignetteGradient = null;
        let lastCacheWidth = 0;
        let lastCacheHeight = 0;

        // Idle state
        let idleTimer = 0;

        // ============================================================
        // PERFORMANCE OPTIMIZATIONS
        // ============================================================

        // Spatial Grid for collision detection optimization
        const SPATIAL_GRID_CELL_SIZE = 250;

        const spatialGrid = {
            cellSize: SPATIAL_GRID_CELL_SIZE,
            cells: new Map(),
            // Reusable arrays to avoid allocations
            _queryResults: [],
            _querySeen: new Set(),
            _cellKeys: [],

            getCellKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            },

            clear() {
                for (const cell of this.cells.values()) {
                    cell.length = 0;
                }
            },

            insert(entity, radius = 50) {
                const minCellX = Math.floor((entity.x - radius) / this.cellSize);
                const maxCellX = Math.floor((entity.x + radius) / this.cellSize);
                const minCellY = Math.floor((entity.y - radius) / this.cellSize);
                const maxCellY = Math.floor((entity.y + radius) / this.cellSize);

                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    for (let cy = minCellY; cy <= maxCellY; cy++) {
                        const key = `${cx},${cy}`;
                        if (!this.cells.has(key)) {
                            this.cells.set(key, []);
                        }
                        this.cells.get(key).push(entity);
                    }
                }
            },

            queryRadius(x, y, radius) {
                // Reuse arrays to avoid garbage collection
                const results = this._queryResults;
                const seen = this._querySeen;
                results.length = 0;
                seen.clear();

                const minCellX = Math.floor((x - radius) / this.cellSize);
                const maxCellX = Math.floor((x + radius) / this.cellSize);
                const minCellY = Math.floor((y - radius) / this.cellSize);
                const maxCellY = Math.floor((y + radius) / this.cellSize);

                for (let cx = minCellX; cx <= maxCellX; cx++) {
                    for (let cy = minCellY; cy <= maxCellY; cy++) {
                        const cell = this.cells.get(`${cx},${cy}`);
                        if (cell) {
                            for (let i = 0; i < cell.length; i++) {
                                const entity = cell[i];
                                if (!seen.has(entity)) {
                                    seen.add(entity);
                                    results.push(entity);
                                }
                            }
                        }
                    }
                }
                return results;
            }
        };

        // Object Pool for reducing garbage collection
        class ObjectPool {
            constructor(factory, resetFn, capacity) {
                this.factory = factory;
                this.resetFn = resetFn;
                this.capacity = capacity;
                this.available = [];

                for (let i = 0; i < capacity; i++) {
                    this.available.push(factory());
                }
            }

            acquire() {
                if (this.available.length > 0) {
                    return this.available.pop();
                }
                console.warn('Pool exhausted, creating new object');
                return this.factory();
            }

            release(obj) {
                if (this.available.length < this.capacity) {
                    this.resetFn(obj);
                    this.available.push(obj);
                }
            }

            releaseAll(array) {
                for (const obj of array) {
                    this.release(obj);
                }
                array.length = 0;
            }
        }

        // Create object pools for all entity types (sized to support 1000+ entities)
        const pools = {
            bullet: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, damage: 1, type: 'laser', color: '', piercing: false, hitEnemies: null, turnRate: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.hitEnemies = null; obj.piercing = false; obj.turnRate = 0; },
                500
            ),

            enemy: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, angle: 0, type: '', hp: 1, maxHp: 1, fireTimer: 0, burstCooldown: 0, spawnTime: 0, offScreenTime: 0, nearMissTriggered: false }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.hp = 1; obj.nearMissTriggered = false; obj.offScreenTime = 0; },
                400
            ),

            particle: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, size: 0, color: '', type: '', angle: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.angle = 0; },
                400
            ),

            enemyBullet: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0, nearMissTriggered: false }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.life = 0; obj.nearMissTriggered = false; },
                300
            ),

            floatingText: new ObjectPool(
                () => ({ x: 0, y: 0, text: '', color: '', life: 0, maxLife: 0, vy: -50 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.text = ''; obj.life = 0; },
                100
            ),

            pickup: new ObjectPool(
                () => ({ x: 0, y: 0, type: '', life: 0, bobTimer: 0 }),
                (obj) => { obj.x = 0; obj.y = 0; obj.type = ''; obj.life = 0; obj.bobTimer = 0; },
                50
            ),

            drone: new ObjectPool(
                () => ({ x: 0, y: 0, vx: 0, vy: 0, angle: 0, life: 0, damage: 1, hasExplosion: false, trail: [] }),
                (obj) => { obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0; obj.angle = 0; obj.life = 0; obj.trail = []; },
                100
            )
        };

        // Culling distance thresholds
        const CULLING_DISTANCES = {
            enemies: 6000,
            particles: 4000,
            pickups: 5000,
            floatingTexts: 3000,
            bullets: 5760,
            enemyBullets: 5760,
            drones: 5000
        };

        // Fast removal helper: swap-and-pop is O(1) instead of splice's O(n)
        function fastRemove(array, index) {
            if (index < array.length - 1) {
                array[index] = array[array.length - 1];
            }
            array.pop();
        }

        // Performance monitoring
        const perfMonitor = {
            frameTimeAccum: 0,
            frameCount: 0,
            avgFrameTime: 16,
            fps: 60,

            entityCounts: {
                bullets: 0,
                enemies: 0,
                particles: 0,
                enemyBullets: 0,
                pickups: 0
            },

            optimizationStats: {
                spatialGridCells: 0,
                entitiesCulled: 0
            },

            update(dt) {
                this.frameTimeAccum += dt * 1000;
                this.frameCount++;

                if (this.frameCount >= 30) {
                    this.avgFrameTime = this.frameTimeAccum / this.frameCount;
                    this.fps = Math.round(1000 / this.avgFrameTime);
                    this.frameTimeAccum = 0;
                    this.frameCount = 0;
                }

                this.entityCounts.bullets = bullets.length;
                this.entityCounts.enemies = enemies.length;
                this.entityCounts.particles = particles.length;
                this.entityCounts.enemyBullets = enemyBullets.length;
                this.entityCounts.pickups = pickups.length;

                this.optimizationStats.spatialGridCells = spatialGrid.cells.size;
            },

            renderDebug() {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 100, 220, 220);

                ctx.font = '12px monospace';
                ctx.fillStyle = '#00FF00';
                ctx.textAlign = 'left';

                let y = 120;
                ctx.fillText(`FPS: ${this.fps}`, 20, y); y += 18;
                ctx.fillText(`Frame: ${this.avgFrameTime.toFixed(2)}ms`, 20, y); y += 18;
                ctx.fillText(`---`, 20, y); y += 18;
                ctx.fillText(`Bullets: ${this.entityCounts.bullets}`, 20, y); y += 18;
                ctx.fillText(`Enemies: ${this.entityCounts.enemies}`, 20, y); y += 18;
                ctx.fillText(`Particles: ${this.entityCounts.particles}`, 20, y); y += 18;
                ctx.fillText(`EnemyBullets: ${this.entityCounts.enemyBullets}`, 20, y); y += 18;
                ctx.fillText(`Pickups: ${this.entityCounts.pickups}`, 20, y); y += 18;
                ctx.fillText(`---`, 20, y); y += 18;
                ctx.fillText(`Grid Cells: ${this.optimizationStats.spatialGridCells}`, 20, y); y += 18;

                ctx.restore();
            }
        };

        let showDebugOverlay = false;

        // ============================================================
        // INITIALIZATION
        // ============================================================

        function initBackgroundCache() {
            // Only regenerate if dimensions changed
            if (lastCacheWidth === CANVAS_WIDTH && lastCacheHeight === CANVAS_HEIGHT) {
                return;
            }
            lastCacheWidth = CANVAS_WIDTH;
            lastCacheHeight = CANVAS_HEIGHT;

            // Regenerate background gradient (radial, lighter in center)
            const bgCenterX = CANVAS_WIDTH / 2;
            const bgCenterY = CANVAS_HEIGHT / 2;
            const bgOuterRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
            cachedBgGradient = ctx.createRadialGradient(
                bgCenterX, bgCenterY, 0,
                bgCenterX, bgCenterY, bgOuterRadius
            );
            cachedBgGradient.addColorStop(0, COLORS.BG_TOP);
            cachedBgGradient.addColorStop(1, COLORS.BG_BOTTOM);

            // Create scanline pattern (1x4 canvas with alternating lines)
            const scanlineCanvas = document.createElement('canvas');
            scanlineCanvas.width = 1;
            scanlineCanvas.height = 4;
            const scanlineCtx = scanlineCanvas.getContext('2d');
            scanlineCtx.fillStyle = 'rgba(127, 219, 255, 0.04)';
            scanlineCtx.fillRect(0, 0, 1, 2);
            // Lines 2-3 remain transparent
            cachedScanlinePattern = ctx.createPattern(scanlineCanvas, 'repeat');

            // Create vignette gradient
            const centerX = CANVAS_WIDTH / 2;
            const centerY = CANVAS_HEIGHT / 2;
            const innerRadius = CANVAS_HEIGHT * 0.3;
            const outerRadius = CANVAS_HEIGHT * 0.8;
            cachedVignetteGradient = ctx.createRadialGradient(
                centerX, centerY, innerRadius,
                centerX, centerY, outerRadius
            );
            cachedVignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            cachedVignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
        }

        function init() {
            // Set canvas dimensions based on device
            if (isMobile()) {
                CANVAS_WIDTH = 720;
                CANVAS_HEIGHT = 1280;
            } else {
                CANVAS_WIDTH = 1920;
                CANVAS_HEIGHT = 1080;
            }

            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            generateBackground();
            initBackgroundCache();
            setupInput();
            setupTouchControls();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            requestAnimationFrame(gameLoop);
        }
        
        function resizeCanvas() {
            const windowRatio = window.innerWidth / window.innerHeight;
            const gameRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            
            let width, height;
            if (windowRatio > gameRatio) {
                height = window.innerHeight;
                width = height * gameRatio;
            } else {
                width = window.innerWidth;
                height = width / gameRatio;
            }
            
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        
        function generateBackground() {
            // Generate nebula blobs
            nebulas = [];
            for (let i = 0; i < 5; i++) {
                nebulas.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    radius: Math.random() * 100 + 50,
                    color: Math.random() > 0.5 ? 'rgba(199, 146, 255, 0.05)' : 'rgba(58, 154, 217, 0.05)'
                });
            }
        }
        
        function resetGame() {
            player = {
                x: WORLD_WIDTH / 2,   // Center of world (5760)
                y: WORLD_HEIGHT / 2,  // Center of world (3240)
                vx: 0,
                vy: 0,
                angle: -90, // Pointing up
                hp: PLAYER_MAX_HP,
                shield: PLAYER_MAX_SHIELD,
                shieldRegenTimer: 0,
                shieldFlashTimer: 0,
                fireTimer: 0,
                invulnerable: 0,
                thrusterScale: 0,
                bobOffset: 0,
                bobTimer: 0
            };

            // Initialize camera at player position
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;

            // Release all pooled objects
            pools.bullet.releaseAll(bullets);
            pools.enemy.releaseAll(enemies);
            pools.particle.releaseAll(particles);
            pools.enemyBullet.releaseAll(enemyBullets);
            pools.floatingText.releaseAll(floatingTexts);
            pools.pickup.releaseAll(pickups);
            pools.drone.releaseAll(drones);

            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            floatingTexts = [];
            pickups = [];
            orbitals = [];
            lightningEffects = [];
            drones = [];
            auraState = { tickTimer: 0, pulseAnimation: 0 };

            score = 0;
            gameTime = 0;
            chainMultiplier = 0;
            lastKillTime = 0;
            
            // XP & Level reset
            playerXP = 0;
            playerLevel = 1;
            xpToNextLevel = XP_PER_LEVEL_BASE;
            
            // Skill Tree reset
            skillPoints = 0;
            unlockedSkills = ['arsenal', 'laser_cannon'];
            upgradeOptions = [];
            upgradeSelectionActive = false;
            document.getElementById('upgradePanel').classList.remove('active');
            
            spawnTimer = 0;
            spawnInterval = INITIAL_SPAWN_INTERVAL_MAX;
            lastSpawnDecayTime = 0;
            waveNumber = 0;
            waveTimer = WAVE_INTERVAL_BASE + Math.random() * WAVE_INTERVAL_VARIANCE;
            lastWavePattern = null;

            shakeIntensity = 0;
            shakeDuration = 0;
            flashColor = null;
            slowmoTimer = 0;
            
            lastMilestone = 0;
            milestoneActive = false;
            isNewHighScore = false;
            idleTimer = 0;
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================
        
        function setupInput() {
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                // Handle cheat codes (only when playing)
                if (gameState === 'playing' && e.key.length === 1) {
                    cheatCodeBuffer += e.key.toLowerCase();
                    
                    // Check if any cheat code matches the buffer
                    for (const [code, action] of Object.entries(CHEAT_CODES)) {
                        if (cheatCodeBuffer.includes(code)) {
                            action();
                            cheatCodeBuffer = '';
                            break;
                        }
                    }
                    
                    // Keep buffer manageable
                    if (cheatCodeBuffer.length > 20) {
                        cheatCodeBuffer = cheatCodeBuffer.slice(-10);
                    }
                }
                
                if (e.code === 'Escape') {
                    if (gameState === 'playing') {
                        gameState = 'paused';
                    } else if (gameState === 'paused') {
                        gameState = 'playing';
                    }
                    // skilltree: no ESC close - must choose an upgrade
                }

                // P key pauses the game
                if (e.code === 'KeyP') {
                    if (gameState === 'playing') {
                        gameState = 'paused';
                    } else if (gameState === 'paused') {
                        gameState = 'playing';
                    }
                }

                if (e.code === 'Enter' || e.code === 'Space') {
                    if (gameState === 'menu') {
                        gameState = 'playing';
                        resetGame();
                    }
                }

                if (e.code === 'KeyR' && gameState === 'gameOver') {
                    gameState = 'playing';
                    resetGame();
                }

                // Toggle debug overlay with B key
                if (e.code === 'KeyB') {
                    showDebugOverlay = !showDebugOverlay;
                }

                // Upgrade panel: select with 1, 2, 3 keys
                if (gameState === 'skilltree' && upgradeSelectionActive) {
                    if (e.code === 'Digit1' && upgradeOptions[0]) {
                        selectUpgrade(upgradeOptions[0]);
                    } else if (e.code === 'Digit2' && upgradeOptions[1]) {
                        selectUpgrade(upgradeOptions[1]);
                    } else if (e.code === 'Digit3' && upgradeOptions[2]) {
                        selectUpgrade(upgradeOptions[2]);
                    }
                }
                
                e.preventDefault();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
        }
        
        function updateInput() {
            input.rotateLeft = keys['ArrowLeft'] || keys['KeyA'];
            input.rotateRight = keys['ArrowRight'] || keys['KeyD'];
            input.thrust = keys['ArrowUp'] || keys['KeyW'];
            input.reverse = keys['ArrowDown'] || keys['KeyS'];
            // Apply touch input
            if (joystickActive) {
                if (joystickMagnitude > JOYSTICK_THRUST_THRESHOLD) {
                    input.thrust = true;
                }
                // Joystick rotation handled directly in player update
            }
            
        }
        
        function setupTouchControls() {
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');

            let joystickTouch = null;
            const baseRect = { x: 30, y: 0, cx: 90, cy: 0 };
            
            joystickZone.addEventListener('touchstart', (e) => {
                if (gameState === 'menu') {
                    gameState = 'playing';
                    resetGame();
                    return;
                }

                if (gameState === 'gameOver') {
                    gameState = 'playing';
                    resetGame();
                    return;
                }

                if (gameState === 'skilltree') {
                    return; // Don't activate joystick during skill tree
                }

                joystickTouch = e.touches[0];
                joystickActive = true;

                // Position joystick centered at touch point
                joystickBase.style.display = 'block';
                joystickBase.style.left = (joystickTouch.clientX - 40) + 'px';
                joystickBase.style.top = (joystickTouch.clientY - 40) + 'px';

                // Reset knob to center
                joystickKnob.style.left = '12px';
                joystickKnob.style.top = '12px';
                joystickMagnitude = 0;

                e.preventDefault();
            });
            
            joystickZone.addEventListener('touchmove', (e) => {
                if (joystickActive) {
                    joystickTouch = e.touches[0];
                    updateJoystick(joystickTouch);
                }
                e.preventDefault();
            });
            
            joystickZone.addEventListener('touchend', () => {
                joystickActive = false;
                joystickMagnitude = 0;
                joystickKnob.style.left = '12px';
                joystickKnob.style.top = '12px';
                joystickBase.style.display = 'none';
            });
            
            function updateJoystick(touch) {
                const rect = joystickBase.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > JOYSTICK_MAX_DISTANCE) {
                    dx = (dx / dist) * JOYSTICK_MAX_DISTANCE;
                    dy = (dy / dist) * JOYSTICK_MAX_DISTANCE;
                }

                joystickKnob.style.left = (12 + dx) + 'px';
                joystickKnob.style.top = (12 + dy) + 'px';

                joystickMagnitude = Math.min(dist / JOYSTICK_MAX_DISTANCE, 1);
                joystickAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            }

        }

        // ============================================================
        // COORDINATE SYSTEM
        // ============================================================

        // Convert world coordinates to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: worldX - camera.x + CANVAS_WIDTH / 2,
                y: worldY - camera.y + CANVAS_HEIGHT / 2
            };
        }

        // Convert screen coordinates to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: screenX + camera.x - CANVAS_WIDTH / 2,
                y: screenY + camera.y - CANVAS_HEIGHT / 2
            };
        }

        // Check if position is within camera view (with padding)
        function isInView(worldX, worldY, padding = 100) {
            const screen = worldToScreen(worldX, worldY);
            return screen.x >= -padding &&
                   screen.x <= CANVAS_WIDTH + padding &&
                   screen.y >= -padding &&
                   screen.y <= CANVAS_HEIGHT + padding;
        }

        // Check if entity should be rendered based on distance from camera
        function shouldRenderEntity(entity, distanceThreshold) {
            const dx = entity.x - camera.x;
            const dy = entity.y - camera.y;
            const distSq = dx * dx + dy * dy;
            return distSq < distanceThreshold * distanceThreshold;
        }

        // ============================================================
        // SECTOR BOUNDARY SYSTEM
        // ============================================================

        function checkSectorBoundary() {
            if (!player) return;

            let transportX = 0;
            let transportY = 0;

            // Check X boundaries
            if (player.x > camera.x + SECTOR_BOUNDS.maxX) {
                // Player exited right side of center sector
                transportX = -3 * SECTOR_WIDTH;
                player.x += transportX;
            } else if (player.x < camera.x + SECTOR_BOUNDS.minX) {
                // Player exited left side of center sector
                transportX = 3 * SECTOR_WIDTH;
                player.x += transportX;
            }

            // Check Y boundaries
            if (player.y > camera.y + SECTOR_BOUNDS.maxY) {
                // Player exited bottom of center sector
                transportY = -3 * SECTOR_HEIGHT;
                player.y += transportY;
            } else if (player.y < camera.y + SECTOR_BOUNDS.minY) {
                // Player exited top of center sector
                transportY = 3 * SECTOR_HEIGHT;
                player.y += transportY;
            }

            // If transport occurred, transport all entities
            if (transportX !== 0 || transportY !== 0) {
                transportEntities(transportX, transportY);
            }
        }

        function transportEntities(offsetX, offsetY) {
            // Transport all entity types
            const entityPools = [
                enemies,
                bullets,
                enemyBullets,
                particles,
                pickups
            ];

            for (const pool of entityPools) {
                for (const entity of pool) {
                    entity.x += offsetX;
                    entity.y += offsetY;
                }
            }

            // Transport floating texts
            for (const text of floatingTexts) {
                text.x += offsetX;
                text.y += offsetY;
            }

            // Transport nebulas (for parallax consistency)
            for (const nebula of nebulas) {
                nebula.x += offsetX;
                nebula.y += offsetY;
            }


            // Update camera to follow player instantly (no lerp during transport)
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;
        }

        // ============================================================
        // CAMERA UPDATE
        // ============================================================

        function updateCamera() {
            if (!player) return;

            // Camera fixed to player (no smoothing)
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;
        }

        // ============================================================
        // GAME LOOP
        // ============================================================

        function gameLoop(timestamp) {
            // Calculate delta time
            if (lastTime === 0) lastTime = timestamp;
            const rawDt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            // Performance monitoring
            frameTimeAccum += rawDt * 1000;
            frameCount++;
            if (frameCount >= 30) {
                avgFrameTime = frameTimeAccum / frameCount;
                lowPerfMode = avgFrameTime > 40;
                frameTimeAccum = 0;
                frameCount = 0;
            }
            
            // Apply time scale (for slow-mo)
            deltaTime = Math.min(rawDt, 0.1) * timeScale;
            
            // Update time scale
            if (slowmoTimer > 0) {
                slowmoTimer -= rawDt * 1000;
                timeScale = SLOWMO_FACTOR;
            } else {
                timeScale = 1;
            }
            
            // Update based on game state
            if (gameState === 'playing') {
                update();
            }
            
            // Always render
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            updateInput();

            gameTime += deltaTime;
            idleTimer += deltaTime;

            // Rebuild spatial grid for collision detection optimization
            spatialGrid.clear();
            for (const e of enemies) {
                const config = ENEMY_TYPES[e.type];
                spatialGrid.insert(e, config.radius + 100);
            }

            // Update performance monitor
            perfMonitor.update(deltaTime);

            // Update player FIRST (so camera can follow in same frame)
            updatePlayer();

            // Update camera immediately after player moves (prevents jitter)
            updateCamera();

            // Check sector boundaries AFTER both are updated
            checkSectorBoundary();

            // Update spawn system
            updateSpawnSystem();

            // Update other entities
            updateBullets();
            updateDrones();
            updateEnemies();
            updateEnemyBullets();
            updateParticles();
            updateFloatingTexts();
            updatePickups();
            updateWeapons();
            
            // Check collisions
            checkCollisions();
            
            // Update effects
            updateEffects();
            
            // Update chain multiplier decay
            if (gameTime - lastKillTime > CHAIN_WINDOW && chainMultiplier > 0) {
                chainMultiplier = Math.max(0, chainMultiplier - deltaTime * 2);
            }
            
            // Survival time bonus
            score += deltaTime;
            
            // Check milestones
            checkMilestones();
            
            // Update high score
            if (score > highScore) {
                highScore = Math.floor(score);
                isNewHighScore = true;
            }
        }

        // ============================================================
        // PLAYER
        // ============================================================
        
        function updatePlayer() {
            if (!player) return;
            
            // Rotation
            let targetRotation = 0;
            if (input.rotateLeft) targetRotation -= ROTATION_SPEED;
            if (input.rotateRight) targetRotation += ROTATION_SPEED;
            
            // Touch joystick rotation - almost instant rotation towards joystick direction
            if (joystickActive && joystickMagnitude > JOYSTICK_DEADZONE) {
                const angleDiff = normalizeAngle(joystickAngle - player.angle);
                if (Math.abs(angleDiff) > JOYSTICK_ROTATION_THRESHOLD) {
                    // Near-instant rotation: lerp 90% of the way each frame
                    player.angle = player.angle + angleDiff * 0.1;
                    targetRotation = 0; // Bypass normal rotation system
                }
            }
            
            player.angle += targetRotation * deltaTime;
            
            // Thrust
            const rad = player.angle * Math.PI / 180;
            let accel = 0;
            
            if (input.thrust) {
                accel = THRUST_ACCEL;
                player.thrusterScale = Math.min(1, player.thrusterScale + deltaTime / 0.08);
                idleTimer = 0;
            } else if (input.reverse) {
                accel = -REVERSE_ACCEL;
                idleTimer = 0;
            }
            
            if (!input.thrust) {
                player.thrusterScale = Math.max(0, player.thrusterScale - deltaTime / 0.12);
            }
            
            player.vx += Math.cos(rad) * accel * deltaTime / PLAYER_MASS;
            player.vy += Math.sin(rad) * accel * deltaTime / PLAYER_MASS;
            
            // Apply drag
            const dragMult = Math.exp(-DRAG_FACTOR * deltaTime);
            player.vx *= dragMult;
            player.vy *= dragMult;
            
            // Clamp speed
            const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (speed > MAX_SPEED) {
                player.vx = (player.vx / speed) * MAX_SPEED;
                player.vy = (player.vy / speed) * MAX_SPEED;
            }
            
            // Position update
            player.x += player.vx * deltaTime;
            player.y += player.vy * deltaTime;

            // Invulnerability
            player.invulnerable = Math.max(0, player.invulnerable - deltaTime);

            // Shield regeneration
            player.shieldFlashTimer = Math.max(0, player.shieldFlashTimer - deltaTime);
            player.shieldRegenTimer += deltaTime;
            if (player.shieldRegenTimer >= SHIELD_REGEN_DELAY && player.shield < PLAYER_MAX_SHIELD) {
                player.shield = Math.min(PLAYER_MAX_SHIELD, player.shield + SHIELD_REGEN_RATE * deltaTime);
            }

            // Auto-fire laser (only when enemy is in aim cone)
            player.fireTimer -= deltaTime;
            if (player.fireTimer <= 0 && hasEnemyInAimCone()) {
                fireBullet();
                player.fireTimer = getWeaponStats().fireRate;
            }

            // Auto-fire rockets (independent system, 360º detection)
            if (!player.rocketTimer) player.rocketTimer = 0;
            player.rocketTimer -= deltaTime;
            const stats = getWeaponStats();
            if (stats.hasRockets && player.rocketTimer <= 0) {
                const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, 600);
                if (nearbyEnemies.length > 0) {
                    fireRocket(nearbyEnemies, stats);
                    // Cooldown fijo de 1.0s (la habilidad ahora aumenta la ráfaga, no la cadencia)
                    player.rocketTimer = 1.0;
                }
            }

            // Auto-fire lightning (independent system, 360º detection)
            if (!player.lightningTimer) player.lightningTimer = 0;
            player.lightningTimer -= deltaTime;
            if (stats.hasLightning && player.lightningTimer <= 0) {
                const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, stats.lightningRange);
                if (nearbyEnemies.length > 0) {
                    fireLightning(nearbyEnemies, stats);
                    player.lightningTimer = stats.lightningCadence;
                }
            }

            // Idle bob
            if (idleTimer > 2) {
                player.bobTimer += deltaTime;
                player.bobOffset = Math.sin(player.bobTimer * 5.2) * 2;
            } else {
                player.bobOffset *= 0.9;
            }
            
            // Spawn thruster particles (reduced frequency when many entities)
            const totalEntities = bullets.length + enemies.length + particles.length;
            const thrusterChance = totalEntities > 200 ? 0.1 : (totalEntities > 100 ? 0.2 : 0.4);
            if (player.thrusterScale > 0.3 && Math.random() < thrusterChance) {
                spawnThrusterParticle();
            }
        }
        
        // Helper function to get computed weapon stats from skill tree
        function getWeaponStats() {
            let damage = 8; // Base damage
            let fireRate = AUTO_FIRE_INTERVAL;
            let pierce = false;
            let spreadCount = 0;
            let hasRockets = false;
            let rocketCount = 1;
            let rocketDamage = 8;
            let hasLaser = false;

            // Laser Cannon branch
            if (unlockedSkills.includes('laser_cannon')) {
                hasLaser = true;
                damage += 4; // Laser cannon adds +4 damage
            }
            if (unlockedSkills.includes('rapid_fire')) {
                fireRate -= 0.1; // Faster fire rate
            }
            if (unlockedSkills.includes('piercing_lens')) {
                pierce = true;
                damage += 4;
            }
            if (unlockedSkills.includes('beam_splitter')) {
                spreadCount = 3;
            }
            fireRate = Math.max(0.1, fireRate); // Minimum fire rate

            // Missile Launcher branch
            let rocketBurstCount = 3; // Misiles por ráfaga (3 normal, 6 con habilidad)
            let rocketExplosionDamage = 12;
            let rocketExplosionRadius = 80;
            let rocketRicochet = false;

            if (unlockedSkills.includes('missile_launcher')) {
                hasRockets = true;
            }
            if (unlockedSkills.includes('homing_guidance')) {
                rocketBurstCount = 6; // Ráfaga doble de misiles
            }
            if (unlockedSkills.includes('armor_piercing')) {
                rocketDamage += 12;
                rocketExplosionDamage += 8;
            }
            if (unlockedSkills.includes('cluster_payload')) {
                rocketRicochet = true; // Spawns mini rockets on impact
            }

            // Lightning Ray branch
            let hasLightning = false;
            let lightningBounces = 3;
            let lightningCadence = 1.2;
            let lightningRange = 225;
            let lightningChainRange = 350;
            let lightningDamage = 8;

            if (unlockedSkills.includes('lightning_ray')) {
                hasLightning = true;
            }
            if (unlockedSkills.includes('chain_amplifier')) {
                lightningBounces = 6;
            }
            if (unlockedSkills.includes('rapid_discharge')) {
                lightningCadence = 0.8;
            }
            if (unlockedSkills.includes('extended_arc')) {
                lightningRange = 650;
                lightningChainRange = 500;
            }

            // Garlic Aura branch
            let hasAura = false;
            let auraRadius = AURA_BASE_RADIUS;
            let auraDamage = AURA_BASE_DAMAGE;
            let auraTickRate = AURA_BASE_TICK_RATE;

            if (unlockedSkills.includes('plasma_field')) {
                hasAura = true;
            }
            if (unlockedSkills.includes('field_expansion')) {
                auraRadius *= 1.5;
            }
            if (unlockedSkills.includes('field_intensity')) {
                auraDamage += 8;
            }
            if (unlockedSkills.includes('field_pulse')) {
                auraTickRate *= 0.67;
            }

            // Alien Drone branch
            let hasDrones = false;
            let droneCount = 1;
            let droneLifetime = 1.5; // Base lifetime in seconds
            let droneHasExplosion = false;

            if (unlockedSkills.includes('alien_drone')) {
                hasDrones = true;
            }
            if (unlockedSkills.includes('drone_duo')) {
                droneCount = 2;
            }
            if (unlockedSkills.includes('drone_duration')) {
                droneLifetime = 3; // Extended lifetime
            }
            if (unlockedSkills.includes('drone_explosion')) {
                droneHasExplosion = true;
            }

            return { damage, fireRate, pierce, spreadCount, hasRockets, rocketCount, rocketDamage, hasLaser, rocketBurstCount, rocketExplosionDamage, rocketExplosionRadius, rocketRicochet, hasLightning, lightningBounces, lightningCadence, lightningRange, lightningChainRange, lightningDamage, hasAura, auraRadius, auraDamage, auraTickRate, hasDrones, droneCount, droneLifetime, droneHasExplosion };
        }

        function hasEnemyInAimCone() {
            const playerRad = player.angle * Math.PI / 180;
            const aimCone = AUTO_AIM_CONE_DEGREES * Math.PI / 180;

            for (const enemy of enemies) {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > AUTO_AIM_MAX_DISTANCE) continue;

                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);

                if (angleDiff <= aimCone) {
                    return true;
                }
            }
            return false;
        }

        function fireBullet() {
            const playerRad = player.angle * Math.PI / 180;
            const noseOffset = PLAYER_SIZE / 2 - PLAYER_PIVOT_OFFSET;
            const noseX = player.x + Math.cos(playerRad) * noseOffset;
            const noseY = player.y + Math.sin(playerRad) * noseOffset;
            
            // Get computed stats from skill tree
            const stats = getWeaponStats();
            const bulletSpeed = BULLET_SPEED;
            
            // Auto-aim: find enemy within frontal cone and predict intercept point
            let targetRad = playerRad;
            let closestDist = Infinity;
            let closestEnemy = null;
            const aimCone = AUTO_AIM_CONE_DEGREES * Math.PI / 180;

            for (const enemy of enemies) {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle((angleToEnemy - playerRad) * 180 / Math.PI) * Math.PI / 180);

                if (angleDiff <= aimCone && dist < closestDist && dist <= AUTO_AIM_MAX_DISTANCE) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            }

            // Calculate intercept point (lead the target)
            if (closestEnemy) {
                const evx = closestEnemy.vx || 0;
                const evy = closestEnemy.vy || 0;

                // Iterative approximation for intercept point (2 iterations for accuracy)
                let predictedX = closestEnemy.x;
                let predictedY = closestEnemy.y;

                for (let i = 0; i < 2; i++) {
                    const dx = predictedX - noseX;
                    const dy = predictedY - noseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const timeToTarget = dist / bulletSpeed;

                    predictedX = closestEnemy.x + evx * timeToTarget;
                    predictedY = closestEnemy.y + evy * timeToTarget;
                }

                targetRad = Math.atan2(predictedY - noseY, predictedX - noseX);
            }
            
            // Fire main weapon (LASER or BEAM if pierce unlocked)
            if (stats.pierce) {
                // Pierce/Beam shot - replaces normal laser
                const bullet = pools.bullet.acquire();
                bullet.x = noseX;
                bullet.y = noseY;
                bullet.vx = Math.cos(targetRad) * (bulletSpeed * 1.2);
                bullet.vy = Math.sin(targetRad) * (bulletSpeed * 1.2);
                bullet.life = BULLET_LIFETIME * 1.5;
                bullet.damage = stats.damage;
                bullet.type = 'beam';
                bullet.color = COLORS.BULLET;
                bullet.piercing = true;
                bullet.hitEnemies = new Set();
                bullets.push(bullet);
            } else {
                // Normal laser shot
                const bullet = pools.bullet.acquire();
                bullet.x = noseX;
                bullet.y = noseY;
                bullet.vx = Math.cos(targetRad) * bulletSpeed;
                bullet.vy = Math.sin(targetRad) * bulletSpeed;
                bullet.life = BULLET_LIFETIME;
                bullet.damage = stats.damage;
                bullet.type = 'laser';
                bullet.color = SKILL_TREE['laser_cannon'].color;
                bullet.piercing = false;
                bullets.push(bullet);
            }

            // Fire SPREAD if unlocked (additional bullets in cone, excluding center)
            if (stats.spreadCount > 0) {
                const spreadAngle = 8 + (stats.spreadCount - 3) * 3; // degrees (reduced angle)
                const mainColor = SKILL_TREE['laser_cannon'].color;

                for (let i = 0; i < stats.spreadCount; i++) {
                    // Skip the middle bullet (already fired by main weapon)
                    const middleIndex = (stats.spreadCount - 1) / 2;
                    if (i === middleIndex) continue;

                    const offset = ((i / (stats.spreadCount - 1)) - 0.5) * 2 * (spreadAngle * Math.PI / 180);
                    const angle = targetRad + offset;
                    const spreadBullet = pools.bullet.acquire();
                    spreadBullet.x = noseX;
                    spreadBullet.y = noseY;
                    spreadBullet.vx = Math.cos(angle) * bulletSpeed;
                    spreadBullet.vy = Math.sin(angle) * bulletSpeed;
                    spreadBullet.life = BULLET_LIFETIME;
                    spreadBullet.damage = stats.damage;
                    spreadBullet.type = 'laser';
                    spreadBullet.color = mainColor;
                    spreadBullet.piercing = stats.pierce;

                    // Add hitEnemies array if piercing
                    if (stats.pierce) {
                        spreadBullet.hitEnemies = new Set();
                    }

                    bullets.push(spreadBullet);
                }
            }
        }

        // Fire rockets in burst (360º enemy detection)
        function fireRocket(nearbyEnemies, stats) {
            // Find closest enemy to aim at
            let closestEnemy = null;
            let closestDist = Infinity;
            for (const e of nearbyEnemies) {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = e;
                }
            }

            if (!closestEnemy) return;

            // Disparar ráfaga de misiles con delays
            const burstCount = stats.rocketBurstCount; // 3 normal, 6 con habilidad
            const delayBetweenRockets = 50; // ms entre cada misil de la ráfaga
            const angleSpread = 0.4; // Dispersión angular total de la ráfaga (radianes)

            for (let i = 0; i < burstCount; i++) {
                setTimeout(() => {
                    // Recalcular posición del enemigo para cada misil (puede haberse movido)
                    const currentDx = closestEnemy.x - player.x;
                    const currentDy = closestEnemy.y - player.y;
                    const currentDist = Math.sqrt(currentDx * currentDx + currentDy * currentDy);

                    // Predict enemy position based on velocity
                    const rocketSpeed = 600;
                    const timeToTarget = currentDist / rocketSpeed;
                    const predictedX = closestEnemy.x + (closestEnemy.vx || 0) * timeToTarget * 0.5;
                    const predictedY = closestEnemy.y + (closestEnemy.vy || 0) * timeToTarget * 0.5;

                    // Ángulo base hacia el objetivo
                    const baseAngle = Math.atan2(predictedY - player.y, predictedX - player.x);

                    // Calcular offset angular para efecto de ráfaga
                    // Distribuye los misiles en un abanico
                    const angleOffset = (i / (burstCount - 1) - 0.5) * angleSpread + (Math.random() - 0.5) * 0.1;
                    const angleToTarget = baseAngle + (burstCount > 1 ? angleOffset : 0);

                    const rocket = pools.bullet.acquire();
                    rocket.x = player.x;
                    rocket.y = player.y;

                    // === COMPORTAMIENTO DE MISIL REALISTA ===
                    // Fase 1: Impulso inicial
                    const initialSpeed = 1000;
                    const boostDuration = 0.3;

                    // Fase 2: Navegación (girando)
                    const cruiseSpeed = 150;

                    // Fase 3: Aproximación final
                    const finalSpeed = 1200;
                    const angleThreshold = 10.2;

                    // Configuración del misil
                    rocket.currentSpeed = initialSpeed;
                    rocket.targetSpeed = initialSpeed;
                    rocket.initialSpeed = initialSpeed;
                    rocket.cruiseSpeed = cruiseSpeed;
                    rocket.finalSpeed = finalSpeed;
                    rocket.boostTimer = boostDuration;
                    rocket.angleThreshold = angleThreshold;
                    rocket.targetAngle = angleToTarget;
                    rocket.hasCompletedBoostPhase = false;

                    // Spawn perpendicular al objetivo con variación por misil
                    const spawnAngle = angleToTarget - Math.PI;
                    rocket.vx = Math.cos(spawnAngle) * initialSpeed;
                    rocket.vy = Math.sin(spawnAngle) * initialSpeed;

                    // Propiedades estándar
                    rocket.life = 2;
                    rocket.damage = stats.rocketDamage;
                    rocket.explosionDamage = stats.rocketExplosionDamage;
                    rocket.explosionRadius = stats.rocketExplosionRadius;
                    rocket.hasRicochet = stats.rocketRicochet;
                    rocket.type = 'rocket';
                    rocket.color = COLORS.PLAYER;
                    rocket.piercing = false;
                    rocket.turnRate = 300;
                    rocket.trail = [];
                    bullets.push(rocket);
                }, i * delayBetweenRockets);
            }
        }

        function fireLightning(nearbyEnemies, stats) {
            // Find closest enemy to start the chain
            let closestEnemy = null;
            let closestDist = Infinity;

            for (const e of nearbyEnemies) {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = e;
                }
            }

            if (!closestEnemy) return;

            // Build the lightning chain - collect all targets first, then apply damage
            const chainPoints = [{ x: player.x, y: player.y }];
            const chainTargets = [];
            const hitEnemies = new Set();
            let currentTarget = closestEnemy;
            let bounceCount = 0;

            // Phase 1: Build the chain (find all targets)
            while (currentTarget && bounceCount < stats.lightningBounces) {
                chainPoints.push({ x: currentTarget.x, y: currentTarget.y });
                chainTargets.push(currentTarget);
                hitEnemies.add(currentTarget);
                bounceCount++;

                // Find next closest enemy within chain range from current target
                const lastHitX = currentTarget.x;
                const lastHitY = currentTarget.y;

                let nextTarget = null;
                let nextDist = Infinity;

                for (const candidate of enemies) {
                    if (hitEnemies.has(candidate)) continue;
                    if (candidate.hp <= 0) continue;

                    const dx = candidate.x - lastHitX;
                    const dy = candidate.y - lastHitY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= stats.lightningChainRange && dist < nextDist) {
                        nextDist = dist;
                        nextTarget = candidate;
                    }
                }

                currentTarget = nextTarget;
            }

            // Phase 2: Apply damage to all targets and kill dead enemies
            const enemiesToKill = [];
            for (const target of chainTargets) {
                const config = ENEMY_TYPES[target.type];
                target.hp -= stats.lightningDamage;

                // Visual feedback
                spawnFloatingText(target.x, target.y - config.radius,
                    stats.lightningDamage.toString(), SKILL_TREE['lightning_ray'].color);
                spawnHitParticles(target.x, target.y, SKILL_TREE['lightning_ray'].color);

                if (target.hp <= 0) {
                    enemiesToKill.push(target);
                }
            }

            // Phase 3: Kill dead enemies (after chain is complete)
            for (const target of enemiesToKill) {
                const enemyIndex = enemies.indexOf(target);
                if (enemyIndex !== -1) {
                    killEnemy(target, enemyIndex);
                }
            }

            // Create lightning visual effect with pre-computed zigzag
            if (chainPoints.length > 1) {
                // Generate zigzag path between each pair of points
                const zigzagPoints = [];
                for (let i = 0; i < chainPoints.length - 1; i++) {
                    const start = chainPoints[i];
                    const end = chainPoints[i + 1];

                    // Add start point
                    if (i === 0) zigzagPoints.push({ x: start.x, y: start.y });

                    // Calculate distance and direction
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Number of zigzag segments based on distance
                    const segments = Math.max(3, Math.floor(dist / 30));
                    const perpX = -dy / dist;
                    const perpY = dx / dist;

                    // Generate zigzag points
                    for (let s = 1; s < segments; s++) {
                        const t = s / segments;
                        const baseX = start.x + dx * t;
                        const baseY = start.y + dy * t;

                        // Alternating zigzag with random offset (narrower)
                        const zigzagAmount = (Math.random() * 12 + 6) * (s % 2 === 0 ? 1 : -1);
                        zigzagPoints.push({
                            x: baseX + perpX * zigzagAmount,
                            y: baseY + perpY * zigzagAmount
                        });
                    }

                    // Add end point
                    zigzagPoints.push({ x: end.x, y: end.y });
                }

                lightningEffects.push({
                    points: zigzagPoints,
                    life: 0.2,
                    maxLife: 0.2,
                    color: SKILL_TREE['lightning_ray'].color
                });
            }
        }

        function spawnAlienDrone(x, y) {
            const stats = getWeaponStats();
            if (!stats.hasDrones) return;

            for (let i = 0; i < stats.droneCount; i++) {
                const drone = pools.drone.acquire();

                // Spawn at enemy death position with slight offset for multiple drones
                const angleOffset = stats.droneCount > 1 ? (i / stats.droneCount) * Math.PI * 2 : 0;
                drone.x = x + Math.cos(angleOffset) * 10;
                drone.y = y + Math.sin(angleOffset) * 10;

                // Initial velocity pointing outward briefly
                drone.vx = Math.cos(angleOffset) * 100;
                drone.vy = Math.sin(angleOffset) * 100;
                drone.angle = angleOffset * 180 / Math.PI;

                drone.life = stats.droneLifetime;
                drone.damage = DRONE_BASE_DAMAGE;
                drone.hasExplosion = stats.droneHasExplosion;
                drone.trail = [];
                drone.color = COLORS.PLAYER;

                drones.push(drone);
            }
        }

        function spawnThrusterParticle() {
            const rad = (player.angle + 180) * Math.PI / 180;
            const spread = (Math.random() - 0.5) * 0.5;
            const tailOffset = 20 + PLAYER_PIVOT_OFFSET;

            const p = pools.particle.acquire();
            p.x = player.x + Math.cos(rad) * tailOffset;
            p.y = player.y + Math.sin(rad) * tailOffset;
            p.vx = Math.cos(rad + spread) * (100 + Math.random() * 50) + player.vx * 0.3;
            p.vy = Math.sin(rad + spread) * (100 + Math.random() * 50) + player.vy * 0.3;
            p.life = 0.3 + Math.random() * 0.2;
            p.maxLife = 0.4;
            p.size = 3 + Math.random() * 3;
            p.color = COLORS.PLAYER;
            p.type = 'thruster';
            particles.push(p);
        }
        
        // ============================================================
        // BULLETS
        // ============================================================
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                
                // Rocket and mini-rocket homing behavior
                if (b.type === 'rocket' || b.type === 'mini_rocket') {
                    // Find nearest enemy using spatial grid
                    let nearestDist = Infinity;
                    let nearestEnemy = null;
                    const nearbyEnemies = spatialGrid.queryRadius(b.x, b.y, 600);
                    for (const e of nearbyEnemies) {
                        const dx = e.x - b.x;
                        const dy = e.y - b.y;
                        const distSq = dx * dx + dy * dy;
                        if (distSq < nearestDist * nearestDist) {
                            nearestDist = Math.sqrt(distSq);
                            nearestEnemy = e;
                        }
                    }
                    
                    if (nearestEnemy) {
                        // Predict enemy position based on velocity
                        const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                        const timeToTarget = nearestDist / Math.max(speed, 100);
                        const predictedX = nearestEnemy.x + (nearestEnemy.vx || 0) * timeToTarget * 0.7;
                        const predictedY = nearestEnemy.y + (nearestEnemy.vy || 0) * timeToTarget * 0.7;

                        const dx = predictedX - b.x;
                        const dy = predictedY - b.y;
                        const targetAngle = Math.atan2(dy, dx);
                        const currentAngle = Math.atan2(b.vy, b.vx);
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                        // === LÓGICA DE MISIL CON 3 FASES (SIN REINICIAR EN NUEVOS OBJETIVOS) ===
                        
                        // Actualizar timer del impulso inicial (SOLO la primera vez)
                        if (b.boostTimer > 0) {
                            b.boostTimer -= deltaTime;
                            if (b.boostTimer <= 0) {
                                // 👈 Cambiar a velocidad de navegación (fase 2) - SOLO UNA VEZ
                                b.currentSpeed = b.cruiseSpeed;
                                b.hasCompletedBoostPhase = true; // 👈 MARCAR QUE COMPLETÓ FASE DE FRENADO
                            }
                        }
                        
                        // SOLO aplicar lógica de aceleración si está fuera del boost inicial
                        // Esto evita que se reinicie el frenado con nuevos objetivos
                        if (b.hasCompletedBoostPhase) {
                            const angleToTargetRad = Math.abs(angleDiff);
                            
                            // Fase 3: Aceleración final si apunta al objetivo
                            if (angleToTargetRad < b.angleThreshold) {
                                b.targetSpeed = b.finalSpeed; // 👈 VELOCIDAD FINAL
                            } else {
                                b.targetSpeed = b.cruiseSpeed; // 👈 VELOCIDAD DE NAVEGACIÓN
                            }
                            
                            // Transición suave de velocidad
                            const speedTransitionRate = 5.0; // 👈 VELOCIDAD DE TRANSICIÓN (más rápido = más abrupto)
                            if (Math.abs(b.currentSpeed - b.targetSpeed) > 1) {
                                const speedChange = (b.targetSpeed - b.currentSpeed) * speedTransitionRate * deltaTime;
                                b.currentSpeed += speedChange;
                            }
                        }
                        
                        // Aplicar giro
                        const maxTurn = (b.turnRate * Math.PI / 180) * deltaTime;
                        const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                        const newAngle = currentAngle + turn;
                        
                        // Aplicar velocidad actual
                        b.vx = Math.cos(newAngle) * b.currentSpeed;
                        b.vy = Math.sin(newAngle) * b.currentSpeed;
                    }

                    // Store trail positions for line rendering
                    if (!b.trail) b.trail = [];
                    const isMini = b.type === 'mini_rocket';
                    const maxTrailLength = isMini ? 25 : 50;
                    b.trail.unshift({ x: b.x, y: b.y });
                    if (b.trail.length > maxTrailLength) {
                        b.trail.pop();
                    }
                }

                // Piercing laser particles (beam or laser with piercing)
                if ((b.type === 'beam' || (b.type === 'laser' && b.piercing))) {
                    const totalEntities = bullets.length + enemies.length;
                    const beamTrailChance = totalEntities > 100 ? 0.3 : 0.6;
                    if (Math.random() < beamTrailChance) {
                        const angle = Math.atan2(b.vy, b.vx);
                        const perpAngle = angle + Math.PI / 2;
                        const offset = (Math.random() - 0.5) * 8;
                        const p = pools.particle.acquire();
                        p.x = b.x + Math.cos(perpAngle) * offset;
                        p.y = b.y + Math.sin(perpAngle) * offset;
                        p.vx = (Math.random() - 0.5) * 20 - Math.cos(angle) * 30;
                        p.vy = (Math.random() - 0.5) * 20 - Math.sin(angle) * 30;
                        p.life = 0.15;
                        p.maxLife = 0.15;
                        p.size = 2 + Math.random() * 2;
                        p.color = b.color || COLORS.BULLET;
                        p.type = 'piercing_trail';
                        particles.push(p);
                    }
                }

                // Store previous position for swept collision detection
                b.prevX = b.x;
                b.prevY = b.y;

                b.x += b.vx * deltaTime;
                b.y += b.vy * deltaTime;
                b.life -= deltaTime;

                // Remove bullets that are too far from camera or expired
                // Allow bullets to travel across adjacent sectors
                const distFromCamera = Math.sqrt(
                    Math.pow(b.x - camera.x, 2) +
                    Math.pow(b.y - camera.y, 2)
                );
                const maxDistance = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 3; // 5760px

                if (b.life <= 0 || distFromCamera > maxDistance) {
                    pools.bullet.release(b);
                    fastRemove(bullets, i);
                }
            }
        }

        // ============================================================
        // ALIEN DRONES
        // ============================================================

        function updateDrones() {
            const droneColor = COLORS.PLAYER;

            for (let i = drones.length - 1; i >= 0; i--) {
                const d = drones[i];

                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;

                for (const e of enemies) {
                    const dx = e.x - d.x;
                    const dy = e.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = e;
                    }
                }

                // Homing behavior towards nearest enemy
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - d.x;
                    const dy = nearestEnemy.y - d.y;
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(d.vy, d.vx);

                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    const maxTurn = (DRONE_TURN_RATE * Math.PI / 180) * deltaTime;
                    const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                    const newAngle = currentAngle + turn;

                    d.vx = Math.cos(newAngle) * DRONE_SPEED;
                    d.vy = Math.sin(newAngle) * DRONE_SPEED;
                    d.angle = newAngle * 180 / Math.PI;
                }

                // Store trail for visual effect
                d.trail.unshift({ x: d.x, y: d.y });
                if (d.trail.length > 8) d.trail.pop();

                // Update position
                d.x += d.vx * deltaTime;
                d.y += d.vy * deltaTime;
                d.life -= deltaTime;

                // Check collision with enemies
                let hitEnemy = null;
                for (const e of enemies) {
                    const config = ENEMY_TYPES[e.type];
                    const dx = e.x - d.x;
                    const dy = e.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < config.radius + DRONE_SIZE) {
                        hitEnemy = e;
                        break;
                    }
                }

                if (hitEnemy) {
                    const config = ENEMY_TYPES[hitEnemy.type];

                    // Apply direct damage
                    hitEnemy.hp -= d.damage;
                    spawnFloatingText(hitEnemy.x, hitEnemy.y - config.radius, d.damage.toString(), droneColor);
                    spawnHitParticles(hitEnemy.x, hitEnemy.y, droneColor);

                    // Check if enemy dies from direct hit
                    if (hitEnemy.hp <= 0) {
                        const enemyIndex = enemies.indexOf(hitEnemy);
                        if (enemyIndex !== -1) killEnemy(hitEnemy, enemyIndex);
                    }

                    // Explosion AoE damage
                    if (d.hasExplosion) {
                        spawnExplosion(d.x, d.y, droneColor, 15);

                        // Find all enemies in explosion radius
                        for (const e of enemies) {
                            if (e === hitEnemy) continue; // Already damaged
                            const edx = e.x - d.x;
                            const edy = e.y - d.y;
                            const eDist = Math.sqrt(edx * edx + edy * edy);

                            if (eDist < DRONE_EXPLOSION_RADIUS) {
                                const eConfig = ENEMY_TYPES[e.type];
                                e.hp -= DRONE_EXPLOSION_DAMAGE;
                                spawnFloatingText(e.x, e.y - eConfig.radius, DRONE_EXPLOSION_DAMAGE.toString(), droneColor);
                                spawnHitParticles(e.x, e.y, droneColor);

                                if (e.hp <= 0) {
                                    const idx = enemies.indexOf(e);
                                    if (idx !== -1) killEnemy(e, idx);
                                }
                            }
                        }
                    } else {
                        // Small impact effect
                        spawnExplosion(d.x, d.y, droneColor, 6);
                    }

                    // Remove drone after impact
                    pools.drone.release(d);
                    fastRemove(drones, i);
                    continue;
                }

                // Remove expired drones or too far from camera
                const distFromCamera = Math.sqrt(
                    Math.pow(d.x - camera.x, 2) +
                    Math.pow(d.y - camera.y, 2)
                );

                if (d.life <= 0 || distFromCamera > CULLING_DISTANCES.drones) {
                    pools.drone.release(d);
                    fastRemove(drones, i);
                }
            }
        }

        // ============================================================
        // ENEMIES
        // ============================================================
        
        function updateSpawnSystem() {
            // Decay spawn interval over time
            if (gameTime - lastSpawnDecayTime > SPAWN_DECAY_INTERVAL) {
                spawnInterval *= (1 - SPAWN_DECAY_RATE);
                spawnInterval = Math.max(MIN_SPAWN_INTERVAL, spawnInterval);
                lastSpawnDecayTime = gameTime;
                waveNumber++;
            }

            // Spawn enemies
            spawnTimer -= deltaTime;
            // Scale max enemies with wave number (+5 enemies per wave)
            const baseMaxEnemies = lowPerfMode ? MAX_ENEMIES_LOW_PERF : MAX_ENEMIES;
            const maxEnemies = baseMaxEnemies + (waveNumber * 5);

            if (spawnTimer <= 0 && enemies.length < maxEnemies) {
                spawnEnemy();
                spawnTimer = spawnInterval + Math.random() * (spawnInterval * 0.5);
            }

            // Wave system - starts aggressively from level 2
            if (playerLevel >= 2) {
                waveTimer -= deltaTime;
                if (waveTimer <= 0) {
                    // Spawn 1-3 waves simultaneously at higher levels
                    const simultaneousWaves = playerLevel >= 5 ? (Math.random() < 0.4 ? 2 : 1) : 1;
                    for (let w = 0; w < simultaneousWaves; w++) {
                        spawnWave();
                    }
                    // Faster waves as level increases (minimum 1.2 seconds between waves)
                    const levelSpeedBonus = Math.min((playerLevel - 2) * 0.25, 1.8);
                    waveTimer = Math.max(1.2, WAVE_INTERVAL_BASE - levelSpeedBonus) + Math.random() * WAVE_INTERVAL_VARIANCE;
                }
            }
        }

        function spawnWave() {
            if (!player) return;

            // Pick a random pattern different from the last one
            let pattern;
            do {
                pattern = WAVE_PATTERNS[Math.floor(Math.random() * WAVE_PATTERNS.length)];
            } while (pattern === lastWavePattern && WAVE_PATTERNS.length > 1);
            lastWavePattern = pattern;

            // Scale wave size with level (more enemies at higher levels)
            const baseCount = 15 + Math.floor(playerLevel * 4);
            const count = Math.min(baseCount, 60); // Cap at 60 per wave

            // Scale enemy HP based on player level (+25% per level)
            const config = ENEMY_TYPES['SCOUT'];
            const hpMultiplier = 1 + (playerLevel - 1) * 0.25;
            const scaledHp = Math.ceil(config.hp * hpMultiplier);

            const spawnPositions = [];

            switch (pattern) {
                case 'arc': {
                    // Arc around player (original pattern but smaller)
                    const centerAngle = Math.random() * 360;
                    const arcDegrees = 90 + Math.random() * 60; // 90-150 degree arc
                    for (let i = 0; i < count; i++) {
                        const angle = (centerAngle - arcDegrees/2 + (arcDegrees / (count - 1)) * i) * Math.PI / 180;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 100;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'side': {
                    // All from one side in a wall
                    const side = Math.floor(Math.random() * 4); // 0=left, 1=right, 2=top, 3=bottom
                    for (let i = 0; i < count; i++) {
                        let x, y;
                        const spread = (i - count/2) * 25;
                        if (side === 0) { // Left
                            x = player.x - WAVE_SPAWN_DISTANCE;
                            y = player.y + spread;
                        } else if (side === 1) { // Right
                            x = player.x + WAVE_SPAWN_DISTANCE;
                            y = player.y + spread;
                        } else if (side === 2) { // Top
                            x = player.x + spread;
                            y = player.y - WAVE_SPAWN_DISTANCE;
                        } else { // Bottom
                            x = player.x + spread;
                            y = player.y + WAVE_SPAWN_DISTANCE;
                        }
                        spawnPositions.push({ x, y });
                    }
                    break;
                }
                case 'pincer': {
                    // From two opposite sides
                    const horizontal = Math.random() > 0.5;
                    const halfCount = Math.floor(count / 2);
                    for (let i = 0; i < halfCount; i++) {
                        const spread = (i - halfCount/2) * 30;
                        if (horizontal) {
                            spawnPositions.push({ x: player.x - WAVE_SPAWN_DISTANCE, y: player.y + spread });
                            spawnPositions.push({ x: player.x + WAVE_SPAWN_DISTANCE, y: player.y + spread });
                        } else {
                            spawnPositions.push({ x: player.x + spread, y: player.y - WAVE_SPAWN_DISTANCE });
                            spawnPositions.push({ x: player.x + spread, y: player.y + WAVE_SPAWN_DISTANCE });
                        }
                    }
                    break;
                }
                case 'circle': {
                    // Hexagonal staggered pattern (3 inner, 3 outer)
                    // Replaces the unfair "full circle" trap with escape routes
                    const baseAngle = Math.random() * Math.PI * 2;
                    // Screen half-width is 960, so 1100 ensures they are off-screen
                    const innerDist = 1100; 
                    const outerDist = 1500;

                    for (let i = 0; i < count; i++) {
                        // Distribute among 6 clusters
                        const clusterIdx = i % 6;
                        
                        // Even indices (0, 2, 4) are inner (closest)
                        // Odd indices (1, 3, 5) are outer (furthest, filling gaps)
                        const isInner = clusterIdx % 2 === 0;
                        
                        // 6 points of hexagon: 0, 60, 120, 180, 240, 300 degrees
                        const angleStep = Math.PI / 3; 
                        const clusterAngle = baseAngle + (clusterIdx * angleStep);

                        // Random spread within the cluster
                        const spreadAngle = (Math.random() - 0.5) * 0.4; // ~20 degree spread
                        const finalAngle = clusterAngle + spreadAngle;

                        const baseDist = isInner ? innerDist : outerDist;
                        const distVariation = Math.random() * 150; // Depth variation
                        const dist = baseDist + distVariation;

                        spawnPositions.push({
                            x: player.x + Math.cos(finalAngle) * dist,
                            y: player.y + Math.sin(finalAngle) * dist
                        });
                    }
                    break;
                }
                case 'line': {
                    // Diagonal line sweeping towards player
                    const angle = Math.random() * 360 * Math.PI / 180;
                    const perpAngle = angle + Math.PI / 2;
                    for (let i = 0; i < count; i++) {
                        const offset = (i - count/2) * 35;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * WAVE_SPAWN_DISTANCE + Math.cos(perpAngle) * offset,
                            y: player.y + Math.sin(angle) * WAVE_SPAWN_DISTANCE + Math.sin(perpAngle) * offset
                        });
                    }
                    break;
                }
                case 'cluster': {
                    // Tight cluster from one direction
                    const angle = Math.random() * 360 * Math.PI / 180;
                    for (let i = 0; i < count; i++) {
                        const offsetAngle = angle + (Math.random() - 0.5) * 0.5;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 150;
                        spawnPositions.push({
                            x: player.x + Math.cos(offsetAngle) * dist,
                            y: player.y + Math.sin(offsetAngle) * dist
                        });
                    }
                    break;
                }
                case 'spiral': {
                    // Spiral pattern
                    const startAngle = Math.random() * 360;
                    for (let i = 0; i < count; i++) {
                        const angle = (startAngle + i * 25) * Math.PI / 180;
                        const dist = WAVE_SPAWN_DISTANCE + i * 15;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'corners': {
                    // From all 4 corners
                    const perCorner = Math.floor(count / 4);
                    const corners = [
                        { dx: -1, dy: -1 },
                        { dx: 1, dy: -1 },
                        { dx: -1, dy: 1 },
                        { dx: 1, dy: 1 }
                    ];
                    for (const corner of corners) {
                        for (let i = 0; i < perCorner; i++) {
                            const spreadX = (Math.random() - 0.5) * 200;
                            const spreadY = (Math.random() - 0.5) * 200;
                            spawnPositions.push({
                                x: player.x + corner.dx * WAVE_SPAWN_DISTANCE * 0.7 + spreadX,
                                y: player.y + corner.dy * WAVE_SPAWN_DISTANCE * 0.7 + spreadY
                            });
                        }
                    }
                    break;
                }
                case 'rush': {
                    // Dense column rushing from one direction
                    const rushAngle = Math.random() * 360 * Math.PI / 180;
                    const perpAngle = rushAngle + Math.PI / 2;
                    const rows = 4;
                    const perRow = Math.ceil(count / rows);
                    for (let row = 0; row < rows; row++) {
                        for (let i = 0; i < perRow; i++) {
                            const offset = (i - perRow/2) * 20;
                            const rowDist = row * 40;
                            spawnPositions.push({
                                x: player.x + Math.cos(rushAngle) * (WAVE_SPAWN_DISTANCE + rowDist) + Math.cos(perpAngle) * offset,
                                y: player.y + Math.sin(rushAngle) * (WAVE_SPAWN_DISTANCE + rowDist) + Math.sin(perpAngle) * offset
                            });
                        }
                    }
                    break;
                }
                case 'scatter': {
                    // Random positions all around (chaotic)
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = WAVE_SPAWN_DISTANCE + Math.random() * 300 - 150;
                        spawnPositions.push({
                            x: player.x + Math.cos(angle) * dist,
                            y: player.y + Math.sin(angle) * dist
                        });
                    }
                    break;
                }
                case 'v_formation': {
                    // V-shape formation flying towards player
                    const vAngle = Math.random() * 360 * Math.PI / 180;
                    const halfCount = Math.floor(count / 2);
                    for (let i = 0; i < halfCount; i++) {
                        const offset = i * 30;
                        const depth = i * 25;
                        // Left wing of V
                        spawnPositions.push({
                            x: player.x + Math.cos(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.cos(vAngle + Math.PI/2) * offset,
                            y: player.y + Math.sin(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.sin(vAngle + Math.PI/2) * offset
                        });
                        // Right wing of V
                        spawnPositions.push({
                            x: player.x + Math.cos(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.cos(vAngle - Math.PI/2) * offset,
                            y: player.y + Math.sin(vAngle) * (WAVE_SPAWN_DISTANCE + depth) + Math.sin(vAngle - Math.PI/2) * offset
                        });
                    }
                    break;
                }
            }

            // Spawn all enemies in the wave
            for (const pos of spawnPositions) {
                const angleToPlayer = Math.atan2(player.y - pos.y, player.x - pos.x);

                const enemy = pools.enemy.acquire();
                enemy.x = pos.x;
                enemy.y = pos.y;
                enemy.vx = Math.cos(angleToPlayer) * config.speed * 0.5;
                enemy.vy = Math.sin(angleToPlayer) * config.speed * 0.5;
                enemy.angle = angleToPlayer * 180 / Math.PI;
                enemy.type = 'SCOUT';
                enemy.hp = scaledHp;
                enemy.maxHp = scaledHp;
                enemy.fireTimer = 0;
                enemy.burstCooldown = 0;
                enemy.spawnTime = gameTime;
                enemy.offScreenTime = 0;
                enemies.push(enemy);
            }
        }
        
        function spawnEnemy() {
            if (!player) return; // Safety check

            // Determine enemy type based on wave/score
            let type = 'SCOUT';
            const r = Math.random();

            if (score > 5000 && r < 0.08) {
                type = 'TANK';
            } else if (waveNumber >= 10 && r < 0.20) {
                type = 'KAMIKAZE';
            }

            // Spawn position relative to PLAYER (not canvas bounds)
            const side = Math.floor(Math.random() * 4);
            let x, y;
            const offset = ENEMY_SPAWN_OFFSET_MIN + Math.random() * ENEMY_SPAWN_OFFSET_RANGE;
            const spawnDistance = CANVAS_WIDTH / 2 + offset;

            switch (side) {
                case 0: // Left
                    x = player.x - spawnDistance;
                    y = player.y + (Math.random() - 0.5) * CANVAS_HEIGHT;
                    break;
                case 1: // Right
                    x = player.x + spawnDistance;
                    y = player.y + (Math.random() - 0.5) * CANVAS_HEIGHT;
                    break;
                case 2: // Top
                    x = player.x + (Math.random() - 0.5) * CANVAS_WIDTH;
                    y = player.y - spawnDistance;
                    break;
                case 3: // Bottom
                    x = player.x + (Math.random() - 0.5) * CANVAS_WIDTH;
                    y = player.y + spawnDistance;
                    break;
            }

            const config = ENEMY_TYPES[type];
            const angleToPlayer = Math.atan2(player.y - y, player.x - x);
            
            // Scale enemy HP based on player level (+40% per level)
            const hpMultiplier = 1 + (playerLevel - 1) * 0.40;
            const scaledHp = Math.ceil(config.hp * hpMultiplier);

            const enemy = pools.enemy.acquire();
            enemy.x = x;
            enemy.y = y;
            enemy.vx = Math.cos(angleToPlayer) * config.speed * 0.5;
            enemy.vy = Math.sin(angleToPlayer) * config.speed * 0.5;
            enemy.angle = angleToPlayer * 180 / Math.PI;
            enemy.type = type;
            enemy.hp = scaledHp;
            enemy.maxHp = scaledHp;
            enemy.fireTimer = config.fireRate || 0;
            enemy.burstCooldown = 0;
            enemy.spawnTime = gameTime;
            enemy.offScreenTime = 0;
            enemies.push(enemy);
        }
        
        function updateEnemies() {
            if (!player) return; // Safety check

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const config = ENEMY_TYPES[e.type];
                // Speed scaling removed - constant speed
                const speed = config.speed;

                // Seek player with limited turn rate
                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                const angleDiff = normalizeAngle(targetAngle - e.angle);
                
                const maxTurn = config.turnRate * deltaTime;
                if (Math.abs(angleDiff) > maxTurn) {
                    e.angle += Math.sign(angleDiff) * maxTurn;
                } else {
                    e.angle = targetAngle;
                }
                
                // Apply velocity toward facing direction
                const rad = e.angle * Math.PI / 180;
                const targetVx = Math.cos(rad) * speed;
                const targetVy = Math.sin(rad) * speed;
                
                // Smooth acceleration
                e.vx += (targetVx - e.vx) * deltaTime * 2;
                e.vy += (targetVy - e.vy) * deltaTime * 2;
                
                // Tank burst
                if (e.type === 'TANK') {
                    e.burstCooldown -= deltaTime;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    if (e.burstCooldown <= 0 && distToPlayer < 200) {
                        e.vx = Math.cos(rad) * 280;
                        e.vy = Math.sin(rad) * 280;
                        e.burstCooldown = 6;
                    }
                }
                
                // Spinner fires
                if (e.type === 'SPINNER') {
                    e.fireTimer -= deltaTime;
                    if (e.fireTimer <= 0) {
                        fireSpinnerBullets(e);
                        e.fireTimer = config.fireRate;
                    }
                }
                
                // Separation from other enemies (using spatial grid)
                const nearbyEnemies = spatialGrid.queryRadius(e.x, e.y, config.radius * 4);
                for (const other of nearbyEnemies) {
                    if (other === e) continue; // Skip self

                    const sepDx = e.x - other.x;
                    const sepDy = e.y - other.y;
                    const sepDistSq = sepDx * sepDx + sepDy * sepDy;
                    const minDist = config.radius + ENEMY_TYPES[other.type].radius + ENEMY_SEPARATION_PADDING;
                    const minDistSq = minDist * minDist;

                    if (sepDistSq < minDistSq && sepDistSq > 0) {
                        const sepDist = Math.sqrt(sepDistSq);
                        const push = (minDist - sepDist) * 0.5;
                        const pushX = (sepDx / sepDist) * push;
                        const pushY = (sepDy / sepDist) * push;
                        e.vx += pushX;
                        e.vy += pushY;
                        other.vx -= pushX;
                        other.vy -= pushY;
                    }
                }
                
                // Update position
                e.x += e.vx * deltaTime;
                e.y += e.vy * deltaTime;

                // Transport enemy if too far from player (wrap around world)
                const relX = e.x - player.x;
                const relY = e.y - player.y;

                // If enemy is beyond 1.5 sectors away, transport to opposite side
                if (relX > SECTOR_WIDTH * 1.5) {
                    e.x -= 3 * SECTOR_WIDTH;
                } else if (relX < -SECTOR_WIDTH * 1.5) {
                    e.x += 3 * SECTOR_WIDTH;
                }

                if (relY > SECTOR_HEIGHT * 1.5) {
                    e.y -= 3 * SECTOR_HEIGHT;
                } else if (relY < -SECTOR_HEIGHT * 1.5) {
                    e.y += 3 * SECTOR_HEIGHT;
                }

                // Spinner self-destruct
                if (e.type === 'SPINNER' && gameTime - e.spawnTime > 20) {
                    pools.enemy.release(e);
                    fastRemove(enemies, i);
                    spawnExplosion(e.x, e.y, config.color, 8);
                }
            }
        }
        
        function fireSpinnerBullets(enemy) {
            const bulletCount = 6;
            for (let i = 0; i < bulletCount; i++) {
                const angle = (360 / bulletCount) * i + enemy.angle;
                const rad = angle * Math.PI / 180;
                const bullet = pools.enemyBullet.acquire();
                bullet.x = enemy.x;
                bullet.y = enemy.y;
                bullet.vx = Math.cos(rad) * 260;
                bullet.vy = Math.sin(rad) * 260;
                bullet.life = 2;
                enemyBullets.push(bullet);
            }
        }
        
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.x += b.vx * deltaTime;
                b.y += b.vy * deltaTime;
                b.life -= deltaTime;

                // Remove enemy bullets that are too far from camera or expired
                // Allow bullets to travel across adjacent sectors
                const distFromCamera = Math.sqrt(
                    Math.pow(b.x - camera.x, 2) +
                    Math.pow(b.y - camera.y, 2)
                );
                const maxDistance = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 3; // 5760px

                if (b.life <= 0 || distFromCamera > maxDistance) {
                    pools.enemyBullet.release(b);
                    fastRemove(enemyBullets, i);
                }
            }
        }
        
        function killEnemy(enemy, index) {
            const config = ENEMY_TYPES[enemy.type];
            
            // Add score with chain multiplier
            const chainIndex = Math.min(Math.floor(chainMultiplier), CHAIN_MULTIPLIERS.length - 1);
            const mult = CHAIN_MULTIPLIERS[chainIndex];
            const points = Math.floor(config.points * mult);
            score += points;
            
            // Update chain
            chainMultiplier = Math.min(chainMultiplier + 0.5, 5);
            lastKillTime = gameTime;
            
            // Spawn explosion
            spawnExplosion(enemy.x, enemy.y, config.color, 12);
            
            // Direct XP gain
            const xpValue = enemy.type === 'TANK' ? 3 : (enemy.type === 'SPINNER' ? 2 : 1);
            collectXP(xpValue);
            
            // Tank splits into scouts
            if (enemy.type === 'TANK') {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const scout = pools.enemy.acquire();
                    scout.x = enemy.x + Math.cos(angle) * 30;
                    scout.y = enemy.y + Math.sin(angle) * 30;
                    scout.vx = Math.cos(angle) * 60;
                    scout.vy = Math.sin(angle) * 60;
                    scout.angle = angle * 180 / Math.PI;
                    scout.type = 'SCOUT';
                    scout.hp = 1;
                    scout.maxHp = 1;
                    scout.fireTimer = 0;
                    scout.burstCooldown = 0;
                    scout.spawnTime = gameTime;
                    scout.offScreenTime = 0;
                    enemies.push(scout);
                }
            }
            
            // Maybe spawn pickup
            if (Math.random() < 0.08) {
                spawnPickup(enemy.x, enemy.y);
            }

            // Spawn alien drones if skill unlocked
            spawnAlienDrone(enemy.x, enemy.y);

            pools.enemy.release(enemy);
            fastRemove(enemies, index);
        }

        // ============================================================
        // PICKUPS
        // ============================================================
        
        function spawnPickup(x, y) {
            // Always try to spawn a pickup, but the type determines if we actually do it
            const rand = Math.random();
            let type = null;

            // 20% Health
            // 80% Nothing

            if (rand < 0.20) {
                type = 'health';
            } else {
                return; // 80% chance of no pickup
            }
            
            const pickup = pools.pickup.acquire();
            pickup.x = x;
            pickup.y = y;
            pickup.type = type;
            pickup.life = 10;
            pickup.bobTimer = Math.random() * Math.PI * 2;
            pickups.push(pickup);
        }
        
        function updatePickups() {
            if (!player) return; // Safety check

            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                p.life -= deltaTime;
                p.bobTimer += deltaTime;

                if (p.life <= 0) {
                    pools.pickup.release(p);
                    fastRemove(pickups, i);
                    continue;
                }

                // Transport pickup if too far from player (wrap around world)
                const relX = p.x - player.x;
                const relY = p.y - player.y;

                if (relX > SECTOR_WIDTH * 1.5) {
                    p.x -= 3 * SECTOR_WIDTH;
                } else if (relX < -SECTOR_WIDTH * 1.5) {
                    p.x += 3 * SECTOR_WIDTH;
                }

                if (relY > SECTOR_HEIGHT * 1.5) {
                    p.y -= 3 * SECTOR_HEIGHT;
                } else if (relY < -SECTOR_HEIGHT * 1.5) {
                    p.y += 3 * SECTOR_HEIGHT;
                }

                // Check collision with player
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < PLAYER_COLLISION_RADIUS + 15) {
                    if (p.type === 'health') {
                        if (player.hp < PLAYER_MAX_HP) {
                            player.hp++;
                            spawnFloatingText(p.x, p.y, '+HP', COLORS.POWERUP);
                        } else {
                            score += 50;
                            spawnFloatingText(p.x, p.y, '+50', COLORS.GOLD);
                        }
                    } else {
                        score += 20;
                        spawnFloatingText(p.x, p.y, '+20', COLORS.GOLD);
                    }

                    // Pickup effect
                    for (let j = 0; j < 8; j++) {
                        const angle = (Math.PI * 2 / 8) * j;
                        particles.push({
                            x: p.x,
                            y: p.y,
                            vx: Math.cos(angle) * 80,
                            vy: Math.sin(angle) * 80,
                            life: 0.4,
                            maxLife: 0.4,
                            size: 4,
                            color: p.type === 'health' ? COLORS.POWERUP : COLORS.GOLD,
                            type: 'pickup'
                        });
                    }

                    pools.pickup.release(p);
                    fastRemove(pickups, i);
                }
            }
        }

        // ============================================================
        // XP & LEVEL SYSTEM
        // ============================================================

        function collectXP(amount) {
            playerXP += amount;

            let levelsGained = 0;
            while (playerXP >= xpToNextLevel) {
                playerXP -= xpToNextLevel;
                playerLevel++;
                xpToNextLevel = Math.floor(XP_PER_LEVEL_BASE * Math.pow(XP_PER_LEVEL_GROWTH, playerLevel - 1));
                skillPoints++;
                levelsGained++;
            }

            // Only trigger effects and open skill tree once if leveled up
            if (levelsGained > 0) {
                levelUp(levelsGained);
            }
        }

        function levelUp(levelsGained = 1) {
            // Only show upgrade panel if there are still skills to unlock
            if (!allSkillsUnlocked()) {
                showUpgradePanel();
            }

            // Effects (more intense if multiple levels)
            const intensity = Math.min(levelsGained, 3);
            triggerFlash(COLORS.XP, 0.2 + intensity * 0.1, 200);
            triggerSlowmo(100 * intensity);

            // Show floating text for multiple levels
            if (levelsGained > 1 && player) {
                spawnFloatingText(player.x, player.y - 40, 'LEVEL UP x' + levelsGained + '!', COLORS.XP);
            }
        }
        
        // Check if a skill can be unlocked
        function canUnlockSkill(skillId) {
            if (unlockedSkills.includes(skillId)) return false;
            if (skillPoints < SKILL_TREE[skillId].cost) return false;
            
            const skill = SKILL_TREE[skillId];
            for (const prereq of skill.prereqs) {
                if (!unlockedSkills.includes(prereq)) return false;
            }
            return true;
        }
        
        // Get list of available (unlockable) skills
        function getAvailableSkills() {
            const available = [];
            for (const skillId of Object.keys(SKILL_TREE)) {
                if (canUnlockSkill(skillId)) {
                    available.push(skillId);
                }
            }
            return available;
        }
        
        // Check if all skills have been unlocked
        function allSkillsUnlocked() {
            // Count total unlockable skills (excluding the base 'arsenal' and 'laser_cannon' skills)
            const totalSkills = Object.keys(SKILL_TREE).filter(skillId => 
                skillId !== 'arsenal' && skillId !== 'laser_cannon'
            ).length;
            const unlockedCount = unlockedSkills.filter(skillId => 
                skillId !== 'arsenal' && skillId !== 'laser_cannon'
            ).length;
            return unlockedCount >= totalSkills;
        }
        
        // Generate 3 random upgrade options from available skills
        function generateUpgradeOptions() {
            const available = getAvailableSkills();
            if (available.length <= 3) return [...available];
            const shuffled = [...available].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 3);
        }

        // Draw a skill icon on a canvas context
        function drawSkillIcon(ctx, icon, cx, cy, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            if (icon === 'arsenal') {
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'laser') {
                ctx.beginPath();
                ctx.moveTo(cx + 10, cy);
                ctx.lineTo(cx - 6, cy - 7);
                ctx.lineTo(cx - 3, cy);
                ctx.lineTo(cx - 6, cy + 7);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'rocket') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - 10);
                ctx.lineTo(cx + 5, cy + 8);
                ctx.lineTo(cx, cy + 5);
                ctx.lineTo(cx - 5, cy + 8);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'orbital') {
                ctx.beginPath();
                ctx.arc(cx, cy, 9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'lightning') {
                ctx.beginPath();
                ctx.moveTo(cx + 2, cy - 9);
                ctx.lineTo(cx - 3, cy);
                ctx.lineTo(cx + 1, cy);
                ctx.lineTo(cx - 2, cy + 9);
                ctx.lineTo(cx + 4, cy - 2);
                ctx.lineTo(cx, cy - 2);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'rate') {
                ctx.beginPath();
                ctx.moveTo(cx - 5, cy - 5);
                ctx.lineTo(cx + 2, cy);
                ctx.lineTo(cx - 5, cy + 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + 1, cy - 5);
                ctx.lineTo(cx + 8, cy);
                ctx.lineTo(cx + 1, cy + 5);
                ctx.stroke();
            } else if (icon === 'beam') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillRect(cx - 10, cy - 1, 20, 2);
            } else if (icon === 'spread') {
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy - 7);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx - 7, cy);
                ctx.lineTo(cx + 7, cy + 7);
                ctx.stroke();
            } else if (icon === 'target') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'cluster') {
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 - Math.PI / 4;
                    ctx.beginPath();
                    ctx.arc(cx + Math.cos(angle) * 6, cy + Math.sin(angle) * 6, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (icon === 'damage') {
                ctx.beginPath();
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx + 6, cy + 2);
                ctx.lineTo(cx + 2, cy + 2);
                ctx.lineTo(cx + 2, cy + 8);
                ctx.lineTo(cx - 2, cy + 8);
                ctx.lineTo(cx - 2, cy + 2);
                ctx.lineTo(cx - 6, cy + 2);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'regen') {
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 1.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + 5, cy);
                ctx.lineTo(cx + 9, cy - 3);
                ctx.lineTo(cx + 9, cy + 3);
                ctx.closePath();
                ctx.fill();
            } else if (icon === 'shockwave') {
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 8, Math.PI * 0.2, Math.PI * 0.8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 8, Math.PI * 1.2, Math.PI * 1.8);
                ctx.stroke();
            } else if (icon === 'absorb') {
                ctx.beginPath();
                ctx.arc(cx, cy, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillRect(cx - 4, cy - 1, 8, 2);
                ctx.fillRect(cx - 1, cy - 4, 2, 8);
            } else if (icon === 'chain') {
                ctx.beginPath();
                ctx.arc(cx - 3, cy - 1, 4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx + 3, cy + 1, 4, 0, Math.PI * 2);
                ctx.stroke();
            } else if (icon === 'discharge') {
                for (let i = 0; i < 3; i++) {
                    const ox = (i - 1) * 5;
                    ctx.beginPath();
                    ctx.moveTo(cx + ox + 1, cy - 5);
                    ctx.lineTo(cx + ox - 1, cy);
                    ctx.lineTo(cx + ox, cy);
                    ctx.lineTo(cx + ox - 1, cy + 5);
                    ctx.stroke();
                }
            } else if (icon === 'arc') {
                ctx.beginPath();
                ctx.arc(cx, cy, 8, -Math.PI * 0.6, Math.PI * 0.6);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 5, -Math.PI * 0.6, Math.PI * 0.6);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'aura') {
                // Aura rings
                ctx.beginPath();
                ctx.arc(cx, cy, 9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'expand') {
                // Expanding arrows
                ctx.beginPath();
                ctx.moveTo(cx - 8, cy);
                ctx.lineTo(cx - 4, cy);
                ctx.moveTo(cx + 4, cy);
                ctx.lineTo(cx + 8, cy);
                ctx.moveTo(cx, cy - 8);
                ctx.lineTo(cx, cy - 4);
                ctx.moveTo(cx, cy + 4);
                ctx.lineTo(cx, cy + 8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.stroke();
            } else if (icon === 'pulse') {
                // Pulsing rings
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'drone') {
                // Hexagon drone shape
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * 8;
                    const y = cy + Math.sin(angle) * 8;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (icon === 'swarm') {
                // Two small drones
                [-5, 5].forEach(ox => {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                        const x = cx + ox + Math.cos(angle) * 5;
                        const y = cy + Math.sin(angle) * 5;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                });
            } else if (icon === 'explosion') {
                // Explosion burst
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerR = 3;
                    const outerR = 9;
                    const r = i % 2 === 0 ? outerR : innerR;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }

        // Show the upgrade selection panel
        function showUpgradePanel() {
            upgradeOptions = generateUpgradeOptions();

            if (upgradeOptions.length === 0) return;

            upgradeSelectionActive = true;
            gameState = 'skilltree';

            // Hide joystick
            joystickActive = false;
            joystickMagnitude = 0;
            const joystickBase = document.getElementById('joystickBase');
            const joystickZone = document.getElementById('joystickZone');
            if (joystickBase) joystickBase.style.display = 'none';
            if (joystickZone) joystickZone.style.display = 'none';

            // Build cards
            const cardsContainer = document.getElementById('upgradeCards');
            cardsContainer.innerHTML = '';

            upgradeOptions.forEach((skillId, index) => {
                const skill = SKILL_TREE[skillId];
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.style.setProperty('--skill-color', skill.color);
                card.style.setProperty('--skill-color-glow', skill.color + '40');

                const isMobile = window.matchMedia('(pointer: coarse)').matches;
                const keyHint = isMobile ? '' : `<div class="upgrade-key">${index + 1}</div>`;

                card.innerHTML = `
                    <div class="upgrade-icon" style="background: ${skill.color}15; border: 2px solid ${skill.color};">
                        <canvas class="skill-icon-canvas" width="40" height="40" data-icon="${skill.icon}" data-color="${skill.color}"></canvas>
                    </div>
                    <div class="upgrade-info">
                        <div class="upgrade-name" style="color: ${skill.color};">${skill.name}</div>
                        <div class="upgrade-desc">${skill.description}</div>
                    </div>
                    ${keyHint}
                `;

                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectUpgrade(skillId);
                });

                cardsContainer.appendChild(card);
            });

            // Render icons on mini canvases
            const canvases = document.querySelectorAll('.skill-icon-canvas');
            canvases.forEach(c => {
                const iconCtx = c.getContext('2d');
                drawSkillIcon(iconCtx, c.dataset.icon, 20, 20, c.dataset.color);
            });

            document.getElementById('upgradePanel').classList.add('active');
        }

        // Select an upgrade option
        function selectUpgrade(skillId) {
            if (!upgradeSelectionActive) return;
            if (!canUnlockSkill(skillId)) return;

            const skill = SKILL_TREE[skillId];
            skillPoints -= skill.cost;
            unlockedSkills.push(skillId);

            spawnFloatingText(player.x, player.y - 40, skill.name + '!', skill.color);

            // Celebration particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(angle) * (80 + Math.random() * 60),
                    vy: Math.sin(angle) * (80 + Math.random() * 60),
                    life: 0.5, maxLife: 0.5,
                    size: 4 + Math.random() * 4,
                    color: skill.color,
                    type: 'levelup'
                });
            }

            hideUpgradePanel();

            // Show again if more skill points remain
            if (skillPoints > 0 && !allSkillsUnlocked()) {
                setTimeout(() => showUpgradePanel(), 300);
            }
        }

        // Hide upgrade panel and resume game
        function hideUpgradePanel() {
            upgradeSelectionActive = false;
            document.getElementById('upgradePanel').classList.remove('active');
            gameState = 'playing';

            // Re-enable joystick zone
            const joystickZone = document.getElementById('joystickZone');
            if (joystickZone) joystickZone.style.display = 'block';
        }
        
        // ============================================================
        // WEAPON SYSTEMS
        // ============================================================
        
        function updateWeapons() {
            // Orbital shields
            if (unlockedSkills.includes('orbital_shield')) {
                updateOrbitals();
            }
            // Plasma Field
            if (unlockedSkills.includes('plasma_field')) {
                updateAura();
            }
            // Lightning effects
            updateLightningEffects();
        }

        function updateLightningEffects() {
            for (let i = lightningEffects.length - 1; i >= 0; i--) {
                const effect = lightningEffects[i];
                effect.life -= deltaTime;

                if (effect.life <= 0) {
                    lightningEffects.splice(i, 1);
                }
            }
        }

        function updateOrbitals() {
            let orbitalCount = 3; // Base count from orbital_shield
            if (unlockedSkills.includes('regen_capacitors')) orbitalCount += 2; // Orbital Expansion adds 2 (total 5)
            const orbitalRadius = ORBITAL_RADIUS; // Radio centralizado
            let orbitalSpeed = ORBITAL_SPEED; // Velocidad centralizada

            // Handle orbital count changes with equidistant positioning
            if (orbitals.length !== orbitalCount) {
                // Preserve the first orbital's angle to maintain rotation continuity
                const baseAngle = orbitals.length > 0 ? orbitals[0].angle : 0;
                const angleIncrement = Math.PI * 2 / orbitalCount;

                // Recalculate all orbitals with new equidistant positions
                orbitals = [];
                for (let i = 0; i < orbitalCount; i++) {
                    orbitals.push({
                        angle: baseAngle + angleIncrement * i,
                        hitCooldown: 0
                    });
                }
            }

            // Update orbital positions and check collisions
            for (let i = 0; i < orbitals.length; i++) {
                const orb = orbitals[i];
                orb.angle += orbitalSpeed * deltaTime;
                if (!orb.hitEnemies) orb.hitEnemies = {}; // Track cooldown per enemy

                const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;

                // Check collision with nearby enemies (using spatial grid)
                const nearbyEnemies = spatialGrid.queryRadius(orbX, orbY, 50);
                for (const e of nearbyEnemies) {
                    // Per-enemy cooldown check
                    if (orb.hitEnemies[e.id] && orb.hitEnemies[e.id] > 0) {
                        orb.hitEnemies[e.id] -= deltaTime;
                        continue;
                    }

                    const config = ENEMY_TYPES[e.type];
                    const dx = orbX - e.x;
                    const dy = orbY - e.y;
                    const distSq = dx * dx + dy * dy;
                    const collisionDist = config.radius + ORBITAL_SIZE;

                    if (distSq < collisionDist * collisionDist) {
                        let orbitalDamage = 16; // Base damage
                        if (unlockedSkills.includes('energy_absorption')) orbitalDamage += 16; // Energy Absorption boost
                        e.hp -= orbitalDamage;
                        orb.hitEnemies[e.id] = 0.15; // Cooldown per enemy (can hit same enemy again after 0.15s)

                        // Show damage floating text
                        spawnFloatingText(e.x, e.y - config.radius, orbitalDamage.toString(), SKILL_TREE['orbital_shield'].color);
                        spawnHitParticles(e.x, e.y, config.color);

                        if (e.hp <= 0) {
                            const enemyIndex = enemies.indexOf(e);
                            if (enemyIndex !== -1) killEnemy(e, enemyIndex);
                        }
                        // No break - can hit multiple enemies per frame
                    }
                }
            }
        }

        function updateAura() {
            const stats = getWeaponStats();
            if (!stats.hasAura || !player) return;

            // Update pulse animation
            auraState.pulseAnimation += deltaTime * 3;

            // Update tick timer
            auraState.tickTimer += deltaTime;

            // Only deal damage on tick intervals
            if (auraState.tickTimer < stats.auraTickRate) return;
            auraState.tickTimer = 0;

            // Find all enemies within aura radius
            const nearbyEnemies = spatialGrid.queryRadius(player.x, player.y, stats.auraRadius);

            for (const e of nearbyEnemies) {
                const config = ENEMY_TYPES[e.type];
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const distSq = dx * dx + dy * dy;
                const effectiveRadius = stats.auraRadius + config.radius;

                if (distSq < effectiveRadius * effectiveRadius) {
                    // Apply damage
                    e.hp -= stats.auraDamage;

                    // Visual feedback
                    spawnFloatingText(e.x, e.y - config.radius, stats.auraDamage.toString(), SKILL_TREE['plasma_field'].color);
                    spawnHitParticles(e.x, e.y, SKILL_TREE['plasma_field'].color);

                    // Check for death
                    if (e.hp <= 0) {
                        const enemyIndex = enemies.indexOf(e);
                        if (enemyIndex !== -1) killEnemy(e, enemyIndex);
                    }
                }
            }
        }

        // ============================================================
        // COLLISIONS
        // ============================================================

        // Swept collision: checks if line segment intersects circle
        // Returns true if the line from (x1,y1) to (x2,y2) passes through circle at (cx,cy) with radius r
        function lineCircleCollision(x1, y1, x2, y2, cx, cy, r) {
            // Vector from start to end of line
            const dx = x2 - x1;
            const dy = y2 - y1;

            // Vector from start to circle center
            const fx = x1 - cx;
            const fy = y1 - cy;

            // Quadratic equation coefficients: at^2 + bt + c = 0
            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;

            // If bullet didn't move (a ≈ 0), just check current position
            if (a < 0.0001) {
                return c <= 0;
            }

            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) {
                return false; // No intersection
            }

            const sqrtDisc = Math.sqrt(discriminant);
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);

            // Check if intersection happens within the line segment (t between 0 and 1)
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }

        function checkCollisions() {
            if (!player) return;
            
            // Bullet vs Enemy (using spatial grid for optimization)
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                let bulletDestroyed = false;

                // Use previous position for swept collision (fallback to current if first frame)
                const prevX = b.prevX !== undefined ? b.prevX : b.x;
                const prevY = b.prevY !== undefined ? b.prevY : b.y;

                // Query enemies along the bullet's path (expand search radius to cover movement)
                const moveDistSq = (b.x - prevX) * (b.x - prevX) + (b.y - prevY) * (b.y - prevY);
                const moveDist = Math.sqrt(moveDistSq);
                const searchRadius = 100 + moveDist;
                const midX = (b.x + prevX) / 2;
                const midY = (b.y + prevY) / 2;
                const nearbyEnemies = spatialGrid.queryRadius(midX, midY, searchRadius);

                for (const e of nearbyEnemies) {
                    const config = ENEMY_TYPES[e.type];
                    const hitRadius = config.radius * 0.9; // Shrink hitbox 10%
                    const collisionDist = hitRadius + 4;

                    // Use swept collision detection (line-circle intersection)
                    if (lineCircleCollision(prevX, prevY, b.x, b.y, e.x, e.y, collisionDist)) {
                        // Check if piercing bullet already hit this enemy
                        if (b.piercing && b.hitEnemies && b.hitEnemies.has(e)) {
                            continue;
                        }

                        const damage = b.damage || 1;
                        e.hp -= damage;

                        // Show damage floating text
                        spawnFloatingText(e.x, e.y - config.radius, damage.toString(), b.color || COLORS.BULLET);

                        // Hit effect
                        spawnHitParticles(b.x, b.y, config.color);

                        if (e.hp <= 0) {
                            const enemyIndex = enemies.indexOf(e);
                            if (enemyIndex !== -1) {
                                killEnemy(e, enemyIndex);
                            }
                        }

                        // Handle bullet destruction/piercing
                        if (b.piercing) {
                            if (!b.hitEnemies) b.hitEnemies = new Set();
                            b.hitEnemies.add(e);
                        } else {
                            bulletDestroyed = true;
                            break;
                        }
                    }
                }

                if (bulletDestroyed) {
                    // Rocket explosion damage in area
                    if (b.type === 'rocket' && b.explosionRadius > 0) {
                        const explosionX = b.x;
                        const explosionY = b.y;
                        const explosionRadius = b.explosionRadius;
                        const explosionDamage = b.explosionDamage;

                        // Visual explosion effect - more impactful
                        spawnRocketExplosion(explosionX, explosionY, explosionRadius);

                        // Damage all enemies in explosion radius
                        const enemiesInBlast = spatialGrid.queryRadius(explosionX, explosionY, explosionRadius);
                        for (const blastEnemy of enemiesInBlast) {
                            const dx = blastEnemy.x - explosionX;
                            const dy = blastEnemy.y - explosionY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= explosionRadius) {
                                // Damage falls off with distance
                                const falloff = 1 - (dist / explosionRadius) * 0.5;
                                const dmg = Math.ceil(explosionDamage * falloff);
                                blastEnemy.hp -= dmg;
                                const config = ENEMY_TYPES[blastEnemy.type];
                                spawnFloatingText(blastEnemy.x, blastEnemy.y - config.radius, dmg.toString(), COLORS.PLAYER);
                                spawnHitParticles(blastEnemy.x, blastEnemy.y, COLORS.PLAYER);
                                if (blastEnemy.hp <= 0) {
                                    const idx = enemies.indexOf(blastEnemy);
                                    if (idx !== -1) killEnemy(blastEnemy, idx);
                                }
                            }
                        }

                        // Ricochet: spawn 2 smaller homing missiles
                        if (b.hasRicochet) {
                            const ricochetTargets = spatialGrid.queryRadius(explosionX, explosionY, 400);
                            let targetsFound = 0;
                            for (const target of ricochetTargets) {
                                if (targetsFound >= 2) break;
                                if (target.hp <= 0) continue;

                                const angle = Math.atan2(target.y - explosionY, target.x - explosionX);
                                const spread = (Math.random() - 0.5) * 0.3;

                                const miniRocket = pools.bullet.acquire();
                                miniRocket.x = explosionX;
                                miniRocket.y = explosionY;
                                miniRocket.vx = Math.cos(angle + spread) * 550;
                                miniRocket.vy = Math.sin(angle + spread) * 550;
                                miniRocket.life = 1.5;
                                miniRocket.damage = Math.ceil(b.damage * 0.5);
                                miniRocket.explosionDamage = 0;
                                miniRocket.explosionRadius = 0;
                                miniRocket.hasRicochet = false;
                                miniRocket.type = 'mini_rocket';
                                miniRocket.color = COLORS.PLAYER;
                                miniRocket.piercing = false;
                                miniRocket.turnRate = 250;
                                miniRocket.size = 0.6;
                                miniRocket.trail = [];
                                bullets.push(miniRocket);
                                targetsFound++;
                            }
                        }
                    }

                    pools.bullet.release(b);
                    fastRemove(bullets, i);
                }
            }

            // Enemy vs Player (using spatial grid for nearby enemies only)
            const nearbyEnemiesForPlayer = spatialGrid.queryRadius(player.x, player.y, 100);
            for (const e of nearbyEnemiesForPlayer) {
                const config = ENEMY_TYPES[e.type];

                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const distSq = dx * dx + dy * dy;
                const collisionDist = PLAYER_COLLISION_RADIUS + config.radius * 0.9;
                const collisionDistSq = collisionDist * collisionDist;
                const nearMissDistSq = (collisionDist + NEAR_MISS_RADIUS) * (collisionDist + NEAR_MISS_RADIUS);

                // Near-miss check
                if (distSq < nearMissDistSq && distSq > collisionDistSq) {
                    if (!e.nearMissTriggered) {
                        e.nearMissTriggered = true;
                        triggerNearMiss();
                    }
                }

                // Collision
                if (distSq < collisionDistSq && player.invulnerable <= 0) {
                    damagePlayer();

                    // Kamikaze dies on contact
                    if (e.type === 'KAMIKAZE') {
                        spawnExplosion(e.x, e.y, config.color, 10);
                        const idx = enemies.indexOf(e);
                        if (idx !== -1) {
                            pools.enemy.release(e);
                            fastRemove(enemies, idx);
                        }
                    }
                }
            }
            
            // Enemy bullet vs Player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];

                const dx = player.x - b.x;
                const dy = player.y - b.y;
                const distSq = dx * dx + dy * dy;
                const collisionDistSq = PLAYER_COLLISION_RADIUS * PLAYER_COLLISION_RADIUS;
                const nearMissDistSq = (PLAYER_COLLISION_RADIUS + NEAR_MISS_RADIUS) * (PLAYER_COLLISION_RADIUS + NEAR_MISS_RADIUS);

                // Near-miss
                if (distSq < nearMissDistSq && distSq > collisionDistSq) {
                    if (!b.nearMissTriggered) {
                        b.nearMissTriggered = true;
                        triggerNearMiss();
                    }
                }

                if (distSq < collisionDistSq && player.invulnerable <= 0) {
                    damagePlayer();
                    pools.enemyBullet.release(b);
                    fastRemove(enemyBullets, i);
                }
            }
        }
        
        function damagePlayer() {
            // Reset shield regen timer
            player.shieldRegenTimer = 0;

            if (player.shield > 0) {
                // Shield absorbs damage
                player.shield = Math.max(0, player.shield - SHIELD_DAMAGE_ABSORPTION);
                player.shieldFlashTimer = 0.15;

                // Visual effects for shield hit (less intense)
                triggerShake(SHAKE_INTENSITY_HIT * 0.5, SHAKE_DURATION_HIT * 0.6);
                triggerFlash(COLORS.SHIELD, 0.2, 100);

                // Brief invulnerability when shield breaks
                if (player.shield <= 0) {
                    player.invulnerable = 0.5;
                    triggerFlash('#FFDD57', 0.4, 200);
                }
            } else {
                // No shield: direct HP damage
                player.hp--;
                player.invulnerable = 1.5;

                triggerShake(SHAKE_INTENSITY_HIT, SHAKE_DURATION_HIT);
                triggerFlash('#FF6B6B', 0.3, 150);

                if (player.hp <= 0) {
                    gameOver();
                }
            }
        }
        
        function triggerNearMiss() {
            score += NEAR_MISS_POINTS;
            chainMultiplier = Math.min(chainMultiplier + 0.02, 5);
            
            spawnFloatingText(player.x + (Math.random() - 0.5) * 30, player.y - 30, '+' + NEAR_MISS_POINTS, COLORS.PLAYER);
            triggerSlowmo(SLOWMO_DURATION);
            triggerFlash(COLORS.PLAYER, 0.22, 180);
            
            // Burst particles
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                particles.push({
                    x: player.x + Math.cos(angle) * PLAYER_COLLISION_RADIUS,
                    y: player.y + Math.sin(angle) * PLAYER_COLLISION_RADIUS,
                    vx: Math.cos(angle) * 100,
                    vy: Math.sin(angle) * 100,
                    life: 0.3,
                    maxLife: 0.3,
                    size: 3,
                    color: COLORS.PLAYER,
                    type: 'nearmiss'
                });
            }
        }
        
        function gameOver() {
            // Save high score
            try {
                const savedHighScore = parseInt(localStorage.getItem('StellarSwarm_highscore_v1') || '0');
                if (score > savedHighScore) {
                    localStorage.setItem('StellarSwarm_highscore_v1', Math.floor(score).toString());
                }
            } catch (e) {
                console.warn('Could not save high score to localStorage:', e);
            }

            // Death explosion
            spawnDeathExplosion();
            
            triggerShake(10, SHAKE_DURATION_DEATH);
            triggerFlash('#FFFFFF', 0.6, 120);
            triggerSlowmo(240);
            
            setTimeout(() => {
                gameState = 'gameOver';
            }, 800);
        }
        
        function spawnDeathExplosion() {
            // Shards
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i + Math.random() * 0.5;
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (100 + Math.random() * 80) + player.vx * 0.3,
                    vy: Math.sin(angle) * (100 + Math.random() * 80) + player.vy * 0.3,
                    life: 0.9,
                    maxLife: 0.9,
                    size: 12,
                    color: COLORS.PLAYER,
                    type: 'shard',
                    angle: angle * 180 / Math.PI,
                    rotSpeed: (Math.random() - 0.5) * 400
                });
            }
            
            // Small particles
            for (let i = 0; i < 18; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * (50 + Math.random() * 150),
                    vy: Math.sin(angle) * (50 + Math.random() * 150),
                    life: 0.6 + Math.random() * 0.3,
                    maxLife: 0.8,
                    size: 3 + Math.random() * 4,
                    color: Math.random() > 0.5 ? COLORS.PLAYER : COLORS.THRUSTER,
                    type: 'debris'
                });
            }
        }

        // ============================================================
        // PARTICLES & EFFECTS
        // ============================================================
        
        function spawnExplosion(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const p = pools.particle.acquire();
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * (40 + Math.random() * 100);
                p.vy = Math.sin(angle) * (40 + Math.random() * 100);
                p.life = 0.4 + Math.random() * 0.3;
                p.maxLife = 0.6;
                p.size = 3 + Math.random() * 5;
                p.color = color;
                p.type = 'explosion';
                particles.push(p);
            }
        }

        // Rocket explosion - more impactful visual
        function spawnRocketExplosion(x, y, radius) {
            // Shockwave ring effect
            const shockwave = pools.particle.acquire();
            shockwave.x = x;
            shockwave.y = y;
            shockwave.vx = 0;
            shockwave.vy = 0;
            shockwave.life = 0.3;
            shockwave.maxLife = 0.3;
            shockwave.size = 5;
            shockwave.maxSize = radius * 1.5;
            shockwave.color = COLORS.PLAYER;
            shockwave.type = 'shockwave';
            particles.push(shockwave);

            // Outer ring of particles
            const ringCount = 12;
            for (let i = 0; i < ringCount; i++) {
                const angle = (i / ringCount) * Math.PI * 2;
                const p = pools.particle.acquire();
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * (120 + Math.random() * 60);
                p.vy = Math.sin(angle) * (120 + Math.random() * 60);
                p.life = 0.4 + Math.random() * 0.2;
                p.maxLife = 0.5;
                p.size = 3 + Math.random() * 2;
                p.color = COLORS.PLAYER;
                p.type = 'explosion';
                particles.push(p);
            }

            // Inner burst particles
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const p = pools.particle.acquire();
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * (40 + Math.random() * 40);
                p.vy = Math.sin(angle) * (40 + Math.random() * 40);
                p.life = 0.3 + Math.random() * 0.2;
                p.maxLife = 0.4;
                p.size = 4 + Math.random() * 3;
                p.color = COLORS.PLAYER;
                p.type = 'explosion';
                particles.push(p);
            }
        }

        function spawnHitParticles(x, y, color) {
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const p = pools.particle.acquire();
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * (30 + Math.random() * 50);
                p.vy = Math.sin(angle) * (30 + Math.random() * 50);
                p.life = 0.2 + Math.random() * 0.15;
                p.maxLife = 0.3;
                p.size = 2 + Math.random() * 3;
                p.color = color;
                p.type = 'hit';
                particles.push(p);
            }
        }
        
        function spawnFloatingText(x, y, text, color) {
            const ft = pools.floatingText.acquire();
            ft.x = x;
            ft.y = y;
            ft.text = text;
            ft.color = color;
            ft.life = 0.7;
            ft.maxLife = 0.7;
            floatingTexts.push(ft);
        }
        
        function updateParticles() {
            // Dynamic particle limit based on total entity count
            const totalEntities = bullets.length + enemies.length + enemyBullets.length;
            let maxParticles = 300;
            if (totalEntities > 150) {
                maxParticles = 150;
            } else if (totalEntities > 100) {
                maxParticles = 200;
            } else if (lowPerfMode) {
                maxParticles = 100;
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.life -= deltaTime;
                
                if (p.type === 'shard' && p.rotSpeed) {
                    p.angle += p.rotSpeed * deltaTime;
                }
                
                // Drag on particles
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                if (p.life <= 0) {
                    pools.particle.release(p);
                    fastRemove(particles, i);
                }
            }

            // Limit particles for performance (remove oldest first)
            while (particles.length > maxParticles) {
                pools.particle.release(particles[0]);
                particles.shift(); // shift is O(n) but only happens when over limit
            }
        }
        
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const t = floatingTexts[i];
                t.y -= 40 * deltaTime;
                t.life -= deltaTime;
                
                if (t.life <= 0) {
                    pools.floatingText.release(t);
                    fastRemove(floatingTexts, i);
                }
            }
        }

        function updateEffects() {
            // Shake
            if (shakeDuration > 0) {
                shakeTimer += deltaTime * 1000;
                if (shakeTimer >= shakeDuration) {
                    shakeDuration = 0;
                    shakeIntensity = 0;
                }
            }
            
            // Flash
            if (flashDuration > 0) {
                flashDuration -= deltaTime * 1000;
                if (flashDuration <= 0) {
                    flashColor = null;
                    flashOpacity = 0;
                }
            }
            
            // Milestone
            if (milestoneActive) {
                milestoneTimer -= deltaTime * 1000;
                if (milestoneTimer <= 0) {
                    milestoneActive = false;
                }
            }
        }
        
        function triggerShake(intensity, duration) {
            shakeIntensity = intensity;
            shakeDuration = duration;
            shakeTimer = 0;
        }
        
        function triggerFlash(color, opacity, duration) {
            flashColor = color;
            flashOpacity = opacity;
            flashDuration = duration;
        }
        
        function triggerSlowmo(duration) {
            slowmoTimer = duration;
            slowmoDuration = duration;
        }
        
        function checkMilestones() {
            const milestone = Math.floor(score / MILESTONE_INTERVAL) * MILESTONE_INTERVAL;
            if (milestone > lastMilestone && milestone > 0) {
                lastMilestone = milestone;
                milestoneActive = true;
                milestoneTimer = 1200;

                // Gold particles
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: Math.random() * CANVAS_WIDTH,
                        y: -20,
                        vx: (Math.random() - 0.5) * 100,
                        vy: 100 + Math.random() * 100,
                        life: 1.5,
                        maxLife: 1.5,
                        size: 4 + Math.random() * 4,
                        color: COLORS.GOLD,
                        type: 'confetti'
                    });
                }
            }
        }

        // ============================================================
        // RENDERING
        // ============================================================
        
        function render() {
            // Apply shake
            ctx.save();
            if (shakeDuration > 0) {
                const progress = shakeTimer / shakeDuration;
                const currentIntensity = shakeIntensity * (1 - progress);
                ctx.translate(
                    (Math.random() - 0.5) * currentIntensity * 2,
                    (Math.random() - 0.5) * currentIntensity * 2
                );
            }

            // Background (rendered without camera offset)
            renderBackground();

            // *** APPLY CAMERA TRANSFORM FOR ALL GAME ENTITIES ***
            ctx.save();
            const cameraOffset = worldToScreen(0, 0);
            ctx.translate(cameraOffset.x, cameraOffset.y);

            // Game entities (all rendered in world coordinates)
            if (gameState === 'playing' || gameState === 'paused' || gameState === 'gameOver') {
                renderPickups();
                renderEnemies();
                renderBullets();
                renderDrones();
                renderEnemyBullets();
                if (player && gameState !== 'gameOver') {
                    renderAura();
                    renderPlayer();
                    renderOrbitals();
                    renderLightning();
                }
                renderParticles();
                renderFloatingTexts();
            }


            ctx.restore(); // Restore camera transform

            ctx.restore(); // Restore shake transform

            // Flash overlay (screen space)
            if (flashColor && flashOpacity > 0) {
                ctx.fillStyle = flashColor;
                ctx.globalAlpha = flashOpacity * (flashDuration / 180);
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.globalAlpha = 1;
            }

            // UI
            renderUI();

            // Debug overlay (toggle with B key)
            if (showDebugOverlay) {
                perfMonitor.renderDebug();
            }
        }

        function renderBackground() {
            // 1. Base gradient (cached in initBackgroundCache)
            ctx.fillStyle = cachedBgGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Skip fancy effects in low performance mode
            if (lowPerfMode) return;

            // 3. Fade-in for grid effects (0 → 1 over 3 seconds)
            const gridFadeIn = Math.min(1, gameTime / 5);
            if (gridFadeIn < 0.01) return;

            // 4. Parallax grid (2 layers)
            // Helper to handle negative modulo correctly
            const mod = (n, m) => ((n % m) + m) % m;

            // Far layer: sparse grid, slow parallax (distant feel)
            const farSpacing = 120;
            const farSpeed = 0.15;
            const farOpacity = 0.025;
            const farLineWidth = 1;
            const farOffsetX = mod(camera.x * farSpeed, farSpacing);
            const farOffsetY = mod(camera.y * farSpeed, farSpacing);
            ctx.strokeStyle = `rgba(127, 219, 255, ${farOpacity * gridFadeIn})`;
            ctx.lineWidth = farLineWidth;
            ctx.beginPath();
            for (let x = -farOffsetX; x <= CANVAS_WIDTH + farSpacing; x += farSpacing) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
            }
            for (let y = -farOffsetY; y <= CANVAS_HEIGHT + farSpacing; y += farSpacing) {
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
            }
            ctx.stroke();

            // Near layer: larger grid, faster parallax (closer feel)
            const nearSpacing = 400;
            const nearSpeed = 0.4;
            const nearOpacity = 0.04;
            const nearLineWidth = 1.5;
            const nearOffsetX = mod(camera.x * nearSpeed, nearSpacing);
            const nearOffsetY = mod(camera.y * nearSpeed, nearSpacing);
            ctx.strokeStyle = `rgba(127, 219, 255, ${nearOpacity * gridFadeIn})`;
            ctx.lineWidth = nearLineWidth;
            ctx.beginPath();
            for (let x = -nearOffsetX; x <= CANVAS_WIDTH + nearSpacing; x += nearSpacing) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_HEIGHT);
            }
            for (let y = -nearOffsetY; y <= CANVAS_HEIGHT + nearSpacing; y += nearSpacing) {
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_WIDTH, y);
            }
            ctx.stroke();

            // 5. CRT Scanlines (cached pattern)
            ctx.globalAlpha = 0.3 * gridFadeIn;
            ctx.fillStyle = cachedScanlinePattern;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.globalAlpha = 1;

            // 6. Vignette (cached gradient)
            ctx.globalAlpha = gridFadeIn;
            ctx.fillStyle = cachedVignetteGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.globalAlpha = 1;
        }


        function renderPlayer() {
            const p = player;
            ctx.save();
            ctx.translate(p.x, p.y + p.bobOffset);
            ctx.rotate(p.angle * Math.PI / 180);
            ctx.translate(-PLAYER_PIVOT_OFFSET, 0);  // Aplica el offset del pivote

            // Invulnerability flash
            if (p.invulnerable > 0 && Math.floor(p.invulnerable * 10) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }
            
            // Shield ring when invulnerable
            if (p.invulnerable > 0) {
                ctx.strokeStyle = COLORS.PLAYER;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.arc(0, 0, PLAYER_VISUAL_RADIUS + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            // Thruster flame
            if (p.thrusterScale > 0) {
                ctx.fillStyle = COLORS.PLAYER;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                const flameLength = 15 + p.thrusterScale * 20;
                ctx.moveTo(-12, -6);
                ctx.lineTo(-12 - flameLength, 0);
                ctx.lineTo(-12, 6);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Ship body (triangle) - outline only style
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 3;
            ctx.shadowColor = COLORS.PLAYER;
            ctx.shadowBlur = 20;
            
            ctx.beginPath();
            ctx.moveTo(22, 0);
            ctx.lineTo(-12, -16);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-12, 16);
            ctx.closePath();
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function renderAura() {
            if (!unlockedSkills.includes('plasma_field') || !player) return;

            const stats = getWeaponStats();
            const auraColor = SKILL_TREE['plasma_field'].color;
            const pulseOffset = Math.sin(auraState.pulseAnimation) * 5;
            const currentRadius = stats.auraRadius + pulseOffset;

            ctx.save();

            // Outer glow ring
            ctx.strokeStyle = auraColor;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            ctx.shadowColor = auraColor;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 15 : 0;
            ctx.beginPath();
            ctx.arc(player.x, player.y, currentRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Semi-transparent fill
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = auraColor;
            ctx.fill();

            // Inner ring
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 1.5;
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(player.x, player.y, currentRadius * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        function renderOrbitals() {
            if (!unlockedSkills.includes('orbital_shield') || !player) return;

            const orbitalRadius = ORBITAL_RADIUS;
            let orbitalSize = ORBITAL_SIZE; // Base size
            if (unlockedSkills.includes('shockwave_emitter')) orbitalSize *= 1.5; // +50% size boost

            // Outline style for orbitals
            ctx.strokeStyle = COLORS.PLAYER;
            ctx.lineWidth = 2.5;
            ctx.shadowColor = COLORS.PLAYER;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

            for (const orb of orbitals) {
                const orbX = player.x + Math.cos(orb.angle) * orbitalRadius;
                const orbY = player.y + Math.sin(orb.angle) * orbitalRadius;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbitalSize, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function renderLightning() {
            if (lightningEffects.length === 0) return;

            for (const effect of lightningEffects) {
                if (effect.points.length < 2) continue;

                const alpha = effect.life / effect.maxLife;

                // Render 3 layers: outer glow, mid glow, core
                for (let layer = 2; layer >= 0; layer--) {
                    ctx.beginPath();
                    ctx.moveTo(effect.points[0].x, effect.points[0].y);

                    // Draw through all pre-computed zigzag points
                    for (let i = 1; i < effect.points.length; i++) {
                        ctx.lineTo(effect.points[i].x, effect.points[i].y);
                    }

                    // Layer styling (narrow lightning)
                    if (layer === 0) {
                        // Core: bright white
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.lineWidth = 1.5;
                    } else if (layer === 1) {
                        // Mid: purple
                        ctx.strokeStyle = `rgba(159, 122, 234, ${alpha * 0.8})`;
                        ctx.lineWidth = 3;
                    } else {
                        // Outer: blue glow
                        ctx.strokeStyle = `rgba(99, 179, 237, ${alpha * 0.5})`;
                        ctx.lineWidth = 6;
                    }

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                }
            }
        }

        function renderBullets() {
            // Sort bullets by type for batched rendering
            const byType = { laser: [], beam: [], rocket: [], spread: [], mini_rocket: [] };

            for (const b of bullets) {
                if (shouldRenderEntity(b, CULLING_DISTANCES.bullets)) {
                    const type = b.type || 'laser';
                    if (byType[type]) byType[type].push(b);
                    else byType.laser.push(b);
                }
            }

            // Batch render lasers
            if (byType.laser.length > 0) {
                ctx.strokeStyle = COLORS.BULLET;
                ctx.shadowColor = COLORS.BULLET;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

                for (const b of byType.laser) {
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.lineWidth = 5;
                    const len = 24;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render beams
            if (byType.beam.length > 0) {
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

                for (const b of byType.beam) {
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.strokeStyle = b.color || COLORS.BULLET;
                    ctx.shadowColor = b.color || COLORS.BULLET;
                    ctx.lineWidth = 5;

                    const len = 24;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render spread shots
            if (byType.spread.length > 0) {
                ctx.strokeStyle = COLORS.GOLD;
                ctx.shadowColor = COLORS.GOLD;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;
                ctx.lineWidth = 2;

                for (const b of byType.spread) {
                    const angle = Math.atan2(b.vy, b.vx);
                    const len = 10;
                    ctx.beginPath();
                    ctx.moveTo(b.x - Math.cos(angle) * len, b.y - Math.sin(angle) * len);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }

            // Batch render rockets with trail
            if (byType.rocket.length > 0) {
                ctx.shadowColor = COLORS.PLAYER;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 10 : 0;

                for (const b of byType.rocket) {
                    // Draw trail as fading line
                    if (b.trail && b.trail.length > 1) {
                        for (let t = 0; t < b.trail.length - 1; t++) {
                            const alpha = 1 - (t / b.trail.length);
                            const width = 2 * (1 - t / b.trail.length);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                            ctx.lineWidth = width;
                            ctx.beginPath();
                            ctx.moveTo(b.trail[t].x, b.trail[t].y);
                            ctx.lineTo(b.trail[t + 1].x, b.trail[t + 1].y);
                            ctx.stroke();
                        }
                    }

                    // Draw rocket
                    ctx.strokeStyle = COLORS.PLAYER;
                    ctx.lineWidth = 2;
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(-6, -5);
                    ctx.lineTo(-4, 0);
                    ctx.lineTo(-6, 5);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Batch render mini rockets with trail (same player color)
            if (byType.mini_rocket.length > 0) {
                ctx.shadowColor = COLORS.PLAYER;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;

                for (const b of byType.mini_rocket) {
                    // Draw trail as fading line
                    if (b.trail && b.trail.length > 1) {
                        for (let t = 0; t < b.trail.length - 1; t++) {
                            const alpha = 1 - (t / b.trail.length);
                            const width = 1.5 * (1 - t / b.trail.length);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                            ctx.lineWidth = width;
                            ctx.beginPath();
                            ctx.moveTo(b.trail[t].x, b.trail[t].y);
                            ctx.lineTo(b.trail[t + 1].x, b.trail[t + 1].y);
                            ctx.stroke();
                        }
                    }

                    // Draw mini rocket
                    ctx.strokeStyle = COLORS.PLAYER;
                    ctx.lineWidth = 1.5;
                    const angle = Math.atan2(b.vy, b.vx);
                    const scale = b.size || 0.6;
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle);
                    ctx.scale(scale, scale);
                    ctx.beginPath();
                    ctx.moveTo(8, 0);
                    ctx.lineTo(-5, -4);
                    ctx.lineTo(-3, 0);
                    ctx.lineTo(-5, 4);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
        }
        
        function renderEnemyBullets() {
            ctx.strokeStyle = COLORS.ENEMY_BULLET;
            ctx.lineWidth = 2;
            ctx.shadowColor = COLORS.ENEMY_BULLET;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;

            for (const b of enemyBullets) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(b, CULLING_DISTANCES.enemyBullets)) continue;

                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function renderDrones() {
            if (drones.length === 0) return;

            const droneColor = COLORS.PLAYER;

            for (const d of drones) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(d, CULLING_DISTANCES.drones)) continue;

                // Draw trail
                if (d.trail.length > 1) {
                    ctx.strokeStyle = droneColor;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.moveTo(d.trail[0].x, d.trail[0].y);
                    for (let i = 1; i < d.trail.length; i++) {
                        ctx.globalAlpha = 0.4 * (1 - i / d.trail.length);
                        ctx.lineTo(d.trail[i].x, d.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Draw drone body
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.angle * Math.PI / 180);

                // Drone shape (small hexagon)
                ctx.strokeStyle = droneColor;
                ctx.fillStyle = droneColor;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * DRONE_SIZE;
                    const y = Math.sin(angle) * DRONE_SIZE;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.stroke();

                // Inner glow dot
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function renderEnemies() {
            // Sort enemies by type for batched rendering
            const byType = { SCOUT: [], KAMIKAZE: [], SPINNER: [], TANK: [] };

            for (const e of enemies) {
                if (shouldRenderEntity(e, CULLING_DISTANCES.enemies)) {
                    byType[e.type].push(e);
                }
            }

            // Batch render scouts
            if (byType.SCOUT.length > 0) {
                const config = ENEMY_TYPES['SCOUT'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;
                ctx.shadowColor = config.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

                for (const e of byType.SCOUT) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.4;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.restore();
                }
            }

            // Batch render kamikazes
            if (byType.KAMIKAZE.length > 0) {
                const config = ENEMY_TYPES['KAMIKAZE'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;
                ctx.shadowColor = config.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

                for (const e of byType.KAMIKAZE) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.moveTo(config.radius, 0);
                    ctx.lineTo(-config.radius, -config.radius * 0.7);
                    ctx.lineTo(-config.radius * 0.5, 0);
                    ctx.lineTo(-config.radius, config.radius * 0.7);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                }
            }

            // Batch render spinners
            if (byType.SPINNER.length > 0) {
                const config = ENEMY_TYPES['SPINNER'];
                ctx.strokeStyle = config.color;
                ctx.shadowColor = config.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

                for (const e of byType.SPINNER) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * config.radius;
                        const y = Math.sin(angle) * config.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    ctx.lineWidth = 2;
                    const rimAngle = gameTime * 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius - 5, rimAngle, rimAngle + Math.PI * 0.5);
                    ctx.stroke();

                    ctx.restore();
                }
            }

            // Batch render tanks (special case - has HP bar)
            if (byType.TANK.length > 0) {
                const config = ENEMY_TYPES['TANK'];
                ctx.strokeStyle = config.color;
                ctx.lineWidth = 3;
                ctx.shadowColor = config.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

                for (const e of byType.TANK) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle * Math.PI / 180);

                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.4;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, config.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    // HP indicator
                    if (e.hp < e.maxHp) {
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.6;
                        const hpWidth = (e.hp / e.maxHp) * config.radius * 2;
                        ctx.beginPath();
                        ctx.moveTo(-config.radius, config.radius + 6);
                        ctx.lineTo(-config.radius + hpWidth, config.radius + 6);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }

                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
        }
        
        function renderPickups() {
            for (const p of pickups) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(p, CULLING_DISTANCES.pickups)) continue;

                const bob = Math.sin(p.bobTimer * 4) * 3;
                const pulse = 1 + Math.sin(p.bobTimer * 6) * 0.1;
                
                ctx.save();
                ctx.translate(p.x, p.y + bob);
                ctx.scale(pulse, pulse);
                
                // Outline style
                if (p.type === 'health') {
                    ctx.strokeStyle = COLORS.POWERUP;
                    ctx.shadowColor = COLORS.POWERUP;
                } else {
                    ctx.strokeStyle = COLORS.GOLD;
                    ctx.shadowColor = COLORS.GOLD;
                }
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 12 : 0;

                // Fade when about to expire
                if (p.life < 2) {
                    ctx.globalAlpha = p.life / 2;
                }

                if (p.type === 'health') {
                    // Diamond shape - outline only
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 0);
                    ctx.closePath();
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        function renderParticles() {
            for (const p of particles) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(p, CULLING_DISTANCES.particles)) continue;

                const alpha = p.life / p.maxLife;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 6 : 0;
                ctx.lineWidth = 2;

                if (p.type === 'shockwave') {
                    // Expanding ring effect
                    const progress = 1 - (p.life / p.maxLife);
                    const currentSize = p.size + (p.maxSize - p.size) * progress;
                    ctx.lineWidth = 3 * alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.type === 'shard') {
                    // Line spark style
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle * Math.PI / 180);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(p.size * 1.5, 0);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    // Small line spark
                    const angle = Math.atan2(p.vy || 0, p.vx || 0);
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + Math.cos(angle) * p.size * 2, p.y + Math.sin(angle) * p.size * 2);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function renderFloatingTexts() {
            ctx.textAlign = 'center';
            ctx.font = 'bold 16px "Segoe UI", sans-serif';

            for (const t of floatingTexts) {
                // Skip rendering if too far from camera
                if (!shouldRenderEntity(t, CULLING_DISTANCES.floatingTexts)) continue;

                const alpha = t.life / t.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = t.color;
                ctx.shadowColor = t.color;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 4 : 0;
                ctx.fillText(t.text, t.x, t.y);
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function renderUI() {
            if (gameState === 'menu') {
                renderMenu();
            } else if (gameState === 'playing' || gameState === 'paused' || gameState === 'skilltree') {
                renderHUD();
                if (gameState === 'paused') {
                    renderPauseOverlay();
                }
                // skilltree rendering is handled by HTML panel
            } else if (gameState === 'gameOver') {
                renderHUD();
                renderGameOver();
            }
            
            // Milestone banner
            if (milestoneActive) {
                renderMilestoneBanner();
            }
        }
        
        function renderMenu() {
            // Darken background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            
            // Title
            ctx.font = 'bold 64px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.PLAYER;
            ctx.shadowColor = COLORS.PLAYER;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 20 : 0;
            ctx.fillText('STELLAR SWARM', CANVAS_WIDTH / 2, 140);
            ctx.shadowBlur = 0;
            
            // Tagline
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Drift. Survive. Swarm the stars.', CANVAS_WIDTH / 2, 175);
            
            // High score
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.GOLD;
            ctx.fillText('HIGH SCORE: ' + highScore, CANVAS_WIDTH / 2, 220);
            
            // Start prompt
            ctx.font = 'bold 24px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            ctx.globalAlpha = pulse;
            ctx.fillText('Press ENTER or TAP to Start', CANVAS_WIDTH / 2, 280);
            ctx.globalAlpha = 1;
            
            // Controls
            renderControlsHelp(340);
        }
        
        function renderControlsHelp(startY) {
            ctx.textAlign = 'left';
            ctx.font = '14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            
            const controls = [
                ['W / ↑', 'Thrust'],
                ['S / ↓', 'Reverse'],
                ['A / ←', 'Rotate Left'],
                ['D / →', 'Rotate Right'],
                ['P / ESC', 'Pause']
            ];
            
            const colWidth = 180;
            const startX = CANVAS_WIDTH / 2 - colWidth;
            
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.font = 'bold 16px "Segoe UI", sans-serif';
            ctx.fillText('CONTROLS', startX, startY);
            
            ctx.font = '14px "Segoe UI", sans-serif';
            for (let i = 0; i < controls.length; i++) {
                const y = startY + 25 + i * 22;
                ctx.fillStyle = COLORS.PLAYER;
                ctx.fillText(controls[i][0], startX, y);
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText(controls[i][1], startX + 80, y);
            }
            
            // Touch controls note
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.font = 'italic 12px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Touch: Use joystick to move', CANVAS_WIDTH / 2, startY + 180);
        }
        
        function renderHUD() {
            if (!player) return; // Safety check

            // Score (top-left)
            ctx.textAlign = 'left';
            ctx.font = 'bold 24px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('SCORE: ' + Math.floor(score), 20, 35);

            // Chain multiplier
            if (chainMultiplier > 0) {
                const chainIndex = Math.min(Math.floor(chainMultiplier), CHAIN_MULTIPLIERS.length - 1);
                const mult = CHAIN_MULTIPLIERS[chainIndex];
                ctx.font = 'bold 18px "Segoe UI", sans-serif';
                ctx.fillStyle = COLORS.GOLD;
                ctx.fillText('CHAIN: x' + mult.toFixed(1), 20, 60);
            }

            // XP Bar (top-center)
            const xpBarWidth = 300;
            const xpBarHeight = 12;
            const xpBarX = (CANVAS_WIDTH - xpBarWidth) / 2;
            const xpBarY = 75;
            const xpProgress = playerXP / xpToNextLevel;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(xpBarX - 2, xpBarY - 2, xpBarWidth + 4, xpBarHeight + 4);
            
            // Empty bar
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(xpBarX, xpBarY, xpBarWidth, xpBarHeight);
            
            // Filled bar
            ctx.fillStyle = COLORS.XP;
            ctx.shadowColor = COLORS.XP;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 8 : 0;
            ctx.fillRect(xpBarX, xpBarY, xpBarWidth * xpProgress, xpBarHeight);
            ctx.shadowBlur = 0;
            
            // Level indicator
            ctx.textAlign = 'center';
            ctx.font = 'bold 14px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('LV ' + playerLevel, CANVAS_WIDTH / 2, xpBarY - 5);

            // HP (top-right)
            ctx.textAlign = 'right';
            const heartSize = 20;
            for (let i = 0; i < PLAYER_MAX_HP; i++) {
                const x = CANVAS_WIDTH - 25 - i * 28;
                const y = 25;

                if (i < player.hp) {
                    ctx.fillStyle = '#FF6B6B';
                } else {
                    ctx.fillStyle = '#444444';
                }
                
                // Heart shape
                ctx.beginPath();
                ctx.moveTo(x, y + 5);
                ctx.bezierCurveTo(x, y, x - 10, y, x - 10, y + 7);
                ctx.bezierCurveTo(x - 10, y + 13, x, y + 18, x, y + 20);
                ctx.bezierCurveTo(x, y + 18, x + 10, y + 13, x + 10, y + 7);
                ctx.bezierCurveTo(x + 10, y, x, y, x, y + 5);
                ctx.fill();
            }

            // === SHIELD BAR (futuristic style) ===
            const shieldBarWidth = 100;
            const shieldBarHeight = 12;
            const shieldBarX = CANVAS_WIDTH - 20 - shieldBarWidth;
            const shieldBarY = 52;
            const shieldPercent = player.shield / PLAYER_MAX_SHIELD;
            const isRegenerating = player.shieldRegenTimer >= SHIELD_REGEN_DELAY && player.shield < PLAYER_MAX_SHIELD;

            ctx.save();

            // Outer frame
            ctx.beginPath();
            ctx.roundRect(shieldBarX - 2, shieldBarY - 2, shieldBarWidth + 4, shieldBarHeight + 4, 3);
            ctx.strokeStyle = 'rgba(58, 154, 217, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Background with gradient
            const bgGrad = ctx.createLinearGradient(shieldBarX, 0, shieldBarX + shieldBarWidth, 0);
            bgGrad.addColorStop(0, '#0a1628');
            bgGrad.addColorStop(1, '#0d2035');
            ctx.fillStyle = bgGrad;
            ctx.beginPath();
            ctx.roundRect(shieldBarX, shieldBarY, shieldBarWidth, shieldBarHeight, 2);
            ctx.fill();

            // Shield fill with gradient
            if (shieldPercent > 0) {
                const fillGrad = ctx.createLinearGradient(shieldBarX, 0, shieldBarX + shieldBarWidth * shieldPercent, 0);

                if (player.shieldFlashTimer > 0) {
                    fillGrad.addColorStop(0, '#FFFFFF');
                    fillGrad.addColorStop(1, '#88DDFF');
                } else if (isRegenerating) {
                    const pulse = Math.sin(Date.now() / 80) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    fillGrad.addColorStop(0, '#2A7AB8');
                    fillGrad.addColorStop(0.5, '#5AC8FA');
                    fillGrad.addColorStop(1, '#2A7AB8');
                } else {
                    fillGrad.addColorStop(0, '#1E5A8A');
                    fillGrad.addColorStop(0.5, '#3A9AD9');
                    fillGrad.addColorStop(1, '#1E5A8A');
                }

                ctx.fillStyle = fillGrad;
                ctx.beginPath();
                ctx.roundRect(shieldBarX + 1, shieldBarY + 1, (shieldBarWidth - 2) * shieldPercent, shieldBarHeight - 2, 2);
                ctx.fill();

                // Glow effect when shield is high
                if (shieldPercent > 0.5 && ENABLE_GLOW_EFFECTS) {
                    ctx.shadowColor = '#3A9AD9';
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            ctx.globalAlpha = 1.0;

            // Segment lines (energy cells look)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 4; i++) {
                const segX = shieldBarX + (shieldBarWidth / 4) * i;
                ctx.beginPath();
                ctx.moveTo(segX, shieldBarY + 2);
                ctx.lineTo(segX, shieldBarY + shieldBarHeight - 2);
                ctx.stroke();
            }

            // Shield icon (small hexagon)
            const iconX = shieldBarX - 18;
            const iconY = shieldBarY + shieldBarHeight / 2;
            const iconSize = 6;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 2;
                const px = iconX + Math.cos(angle) * iconSize;
                const py = iconY + Math.sin(angle) * iconSize;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = shieldPercent > 0 ? COLORS.SHIELD : '#333';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
            // === END SHIELD BAR ===

            // Time (bottom-center)
            ctx.textAlign = 'center';
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            ctx.fillText('TIME: ' + minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0'), CANVAS_WIDTH / 2, CANVAS_HEIGHT - 20);
            
            // Controls hint (bottom-left)
            ctx.textAlign = 'left';
            ctx.font = '11px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('CONTROLS:', 15, CANVAS_HEIGHT - 65);
            ctx.fillText('W/↑ THRUST', 15, CANVAS_HEIGHT - 50);
            ctx.fillText('A/← ROTATE L', 15, CANVAS_HEIGHT - 35);
            ctx.fillText('D/→ ROTATE R', 15, CANVAS_HEIGHT - 20);

            // Unlocked skills indicators (right side)
            ctx.textAlign = 'right';
            ctx.font = '12px "Segoe UI", sans-serif';
            let skillY = 75;
            for (const skillId of unlockedSkills) {
                if (skillId === 'arsenal') continue; // Don't show base skill
                const skill = SKILL_TREE[skillId];
                ctx.fillStyle = skill.color;
                ctx.fillText(skill.name, CANVAS_WIDTH - 20, skillY);
                skillY += 18;
            }
            
            // Skill points indicator if any available
            if (skillPoints > 0) {
                ctx.fillStyle = COLORS.GOLD;
                ctx.font = 'bold 14px "Segoe UI", sans-serif';
                ctx.fillText('SKILL POINTS: ' + skillPoints, CANVAS_WIDTH - 20, skillY + 10);
            }
        }
        function renderPauseOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            ctx.font = 'bold 48px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
            
            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Press P or ESC to Resume', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.fillText('Press R to Restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
        }
        
        function renderGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.textAlign = 'center';
            
            // Game Over title
            ctx.font = 'bold 56px "Segoe UI", sans-serif';
            ctx.fillStyle = '#FF6B6B';
            ctx.shadowColor = '#FF6B6B';
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 15 : 0;
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 80);
            ctx.shadowBlur = 0;
            
            // Score
            ctx.font = 'bold 32px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            ctx.fillText('SCORE: ' + Math.floor(score), CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            
            // High score
            ctx.font = '24px "Segoe UI", sans-serif';
            if (isNewHighScore) {
                ctx.fillStyle = COLORS.GOLD;
                ctx.shadowColor = COLORS.GOLD;
                ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 10 : 0;
                ctx.fillText('★ NEW HIGH SCORE! ★', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = COLORS.UI_SECONDARY;
                ctx.fillText('BEST: ' + highScore, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            }
            
            // Time survived
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            ctx.font = '18px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_SECONDARY;
            ctx.fillText('Time: ' + minutes + 'm ' + seconds + 's', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 55);
            
            // Retry prompt
            ctx.font = 'bold 22px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.UI_PRIMARY;
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            ctx.globalAlpha = pulse;
            ctx.fillText('Press R or TAP to Retry', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 100);
            ctx.globalAlpha = 1;
        }
        
        function renderMilestoneBanner() {
            const progress = milestoneTimer / 1200;
            const slideY = progress > 0.8 ? (1 - progress) / 0.2 * 60 : (progress < 0.2 ? (0.2 - progress) / 0.2 * 60 : 0);
            
            ctx.fillStyle = 'rgba(255, 221, 87, 0.2)';
            ctx.fillRect(0, 60 - slideY, CANVAS_WIDTH, 50);
            
            ctx.textAlign = 'center';
            ctx.font = 'bold 24px "Segoe UI", sans-serif';
            ctx.fillStyle = COLORS.GOLD;
            ctx.shadowColor = COLORS.GOLD;
            ctx.shadowBlur = ENABLE_GLOW_EFFECTS ? 10 : 0;
            ctx.fillText(lastMilestone + ' POINTS!', CANVAS_WIDTH / 2, 92 - slideY);
            ctx.shadowBlur = 0;
        }

        // ============================================================
        // UTILITIES
        // ============================================================
        
        function normalizeAngle(angle) {
            while (angle > 180) angle -= 360;
            while (angle < -180) angle += 360;
            return angle;
        }

        // ============================================================
        // START GAME
        // ============================================================
        
        init();
        
    })();
    </script>
</body>
</html>
